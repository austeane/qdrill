## Practice Plans Feature Review

This section reviews the code related to browsing, creating, viewing, and editing practice plans.

**Files Reviewed:**

*   `src/routes/practice-plans/+page.server.js`:
    *   **Notes:** Loads all practice plans using `practicePlanService`. Correctly uses `locals.user.id` for potential filtering/permissions (although `getAll` implementation needs checking if it uses the `userId`). Parses `drillId` query parameters from the URL to fetch initial drill names using `drillService`, handling multiple IDs and potential errors gracefully. Hardcodes `filterOptions` which is simple but less flexible than fetching from a service/DB if these options change.
    *   **Potential Issues:**
        *   No pagination or filtering applied when fetching `practicePlans`. Could lead to performance issues if the list grows large. Assumes `practicePlanService.getAll` fetches everything.
        *   Hardcoded `filterOptions` might become stale or require code changes if options evolve. Consider fetching these dynamically if they are likely to change.
        *   Fetching drill names one by one (`selectedDrillIds.map(async (id) => ...`) inside `Promise.all` could be inefficient if many `drillId` params are present. A `drillService.getByIds` method would be better.
        *   Assumes `practicePlanService.getAll` returns `{ items: [...] }`; verify this structure.
*   `src/routes/practice-plans/+page.svelte`:
    *   **Notes:** Displays the list of practice plans fetched from the `load` function. Implements client-side filtering based on search query, phase of season, practice goals, estimated participants, and contained drills. Uses the `FilterPanel` component for filter inputs. Integrates `sortStore` for reactive sorting. Manages the 'Contains drill' filter state and updates the URL query parameters (`drillId`) using `history.replaceState` (debounced). Includes a 'Create Plan' button that checks the `cartStore` and shows a modal if the cart is empty before navigating. Uses `UpvoteDownvote` and `DeletePracticePlan` components per card. Filtering logic uses helper functions (`filterByThreeState`, `filterByThreeStateArray`) to handle three-state checkbox logic (Required, Included, Excluded). Layout uses TailwindCSS grid.
    *   **Potential Issues:**
        *   **Client-Side Filtering/Sorting Scalability:** All filtering and sorting happen client-side. This will become slow and memory-intensive as the number of practice plans grows. Filtering and sorting should ideally be handled server-side (via API calls triggered by filter/sort changes) with pagination.
        *   **Complex Filter Logic:** The `filterByThreeState` and `filterByThreeStateArray` functions handle complex logic. While functional, ensure they cover all edge cases correctly. Server-side filtering would simplify this component significantly.
        *   **URL State Management:** Managing the `drillId` query parameters directly via `history.replaceState` works but couples the component tightly to the URL structure. SvelteKit's built-in features (`$page.url.searchParams`) could potentially be used more declaratively, especially if combined with server-side data loading based on these params. Debouncing the URL update is good practice.
        *   **Data Consistency:** The `DeletePracticePlan` component removes the plan directly from the local `practicePlans` array upon successful deletion. This avoids a full reload but might lead to inconsistencies if the deletion fails silently or if other users are modifying data concurrently. A more robust approach might involve re-fetching or using a more sophisticated state management strategy.
        *   **Initial Data Handling:** Uses safety checks (`Array.isArray(data.practicePlans) ? data.practicePlans : []`) which is good, but also indicates the `load` function might not always return the expected structure.
        *   **Store Usage:** Imports specific filter state stores (`selectedPhaseOfSeason`, etc.) from `practicePlanStore`. Consider if `practicePlanStore` could expose a single filter object store for easier management.
        *   Minor: Uses `lodash/debounce`, adding a dependency. Svelte has patterns for debouncing without external libraries if preferred.
*   `src/routes/practice-plans/[id]/+page.server.js`:
    *   **Notes:** Simple load function. Correctly extracts the `id` from `params`. Fetches the specific practice plan data using an internal API call (`/api/practice-plans/${id}`). Includes basic error handling, throwing a 500 error if the fetch fails.
    *   **Potential Issues:**
        *   The error handling is generic (500). It could be more specific, e.g., returning a 404 if the API response indicates the plan wasn't found. This requires checking the `response.status` more granularly.
        *   Relies entirely on the API endpoint (`/api/practice-plans/${id}`) for data fetching and authorization logic.
*   `src/routes/practice-plans/[id]/+page.svelte`:
    *   **Notes:** Displays detailed practice plan information received from the `load` function (`data.practicePlan`). Calculates total duration and section start times. Determines edit permission based on `created_by` field and `$page.data.session`. Uses components: `Breadcrumb`, `Comments`, `UpvoteDownvote`, `Timeline`, `Section`, `DeletePracticePlan`. Implements Intersection Observer to track the currently visible section and highlight it in the `Timeline` component. Handles scrolling to sections when selected via the timeline. Includes 'Edit', 'Duplicate', and 'Delete' actions. Uses `{@html}` for the description. Provides "Show more/less" functionality for the description. Uses `svelte-toast` for feedback on duplication.
    *   **Potential Issues:**
        *   **`{@html}` Usage:** Uses `{@html practicePlan.description}`. Requires verification that the description content is properly sanitized on the backend or during input to prevent XSS vulnerabilities.
        *   **Complex Calculations:** Calculates `totalDuration` and `sectionStartTime` client-side. While likely okay for typical plan sizes, complex plans could potentially make these calculations slightly heavy. Pre-calculating these on the server might be more efficient. The `addMinutes` helper is basic and assumes no date changes.
        *   **Permission Logic:** Edit permission (`canEdit`) is derived client-side based on `$page.data.session` and plan data. While convenient, critical authorization should always be enforced server-side (e.g., in the edit page's load function and API endpoints), but displaying the button based on this client-side check is reasonable.
        *   **Duplication API Call:** Calls the duplication endpoint (`/api/practice-plans/${practicePlan.id}/duplicate`) directly via `fetch`. Consider abstracting API calls to a service/store layer for better organization and reusability.
        *   **Intersection Observer:** Uses `document.querySelectorAll` and direct DOM manipulation (`scrollIntoView`). While standard for Intersection Observer, Svelte often provides ways to achieve similar effects more declaratively using actions or component bindings, although this approach is perfectly valid.
        *   **Timeline Component:** Relies on the `Timeline` component for visualization, which is hidden on mobile. Ensure the user experience without the timeline on smaller screens is adequate.
*   `src/routes/practice-plans/[id]/edit/+page.server.js`:
    *   **Notes:** Similar to the detail view server file, it extracts the `id` and fetches the practice plan data using the internal API (`/api/practice-plans/${id}`). Includes basic error handling and `console.log` statements for debugging.
    *   **Potential Issues:**
        *   **Crucial Missing Authorization:** This `load` function **MUST** include an authorization check. It currently fetches the plan data but doesn't verify if the logged-in user (`locals.user`) has permission to edit this specific plan (`practicePlan.created_by` or `is_editable_by_others`). This is a significant security vulnerability. Access control needs to be added here, similar to the `drills/[id]/edit/+page.server.js` example.
        *   **Generic Error Handling:** Returns a generic 500 error object shape (`{ status: 500, error: 'Internal Server Error' }`) instead of using `throw error(500, ...)`. While functional, using SvelteKit's `error` helper is more standard. Also, should return 404 if the plan isn't found.
        *   Relies entirely on the API endpoint for data fetching; any authorization within the API might prevent fetching, but the page-level load function should have its own check.
        *   Presence of `console.log` statements.
*   `src/routes/practice-plans/[id]/edit/+page.svelte`:
    *   **Notes:** Very simple wrapper component. Uses reactive destructuring (`$: ({ practicePlan } = data);`) to get the `practicePlan` data loaded by the server. Passes the `practicePlan` data to the `PracticePlanForm.svelte` component, which handles the actual editing UI and logic. Includes a basic loading state.
    *   **Potential Issues:**
        *   **Security:** Relies entirely on the server `load` function (`+page.server.js`) to provide the correct `practicePlan` data *and* to perform authorization. As noted above, the server file is currently missing the authorization check, making this page potentially accessible to unauthorized users who could see the form pre-filled (even if saving is blocked by the API).
        *   **Error Handling:** The loading state is basic (`<p>Loading practice plan...</p>`). It doesn't explicitly handle the error case where `+page.server.js` might return an error status (e.g., 404, 403, 500). The component would likely just render the loading message indefinitely or potentially break depending on how SvelteKit handles the errored load data. Proper error display should be added.
        *   Presence of `console.log`.
*   `src/routes/practice-plans/PracticePlanForm.svelte`:
    *   **Notes:** Handles both creation (optionally initialized from `cartStore`) and editing (initialized from `practicePlan` prop). Uses numerous Svelte stores (`practicePlanStore`, `sectionsStore`, `historyStore`, `cartStore`, `page`) to manage form state, sections/items, undo/redo, and authentication status. Integrates `TinyMCE` for the description field (dynamically imported). Uses child components for modals (`EmptyCartModal`, `DrillSearchModal`, `TimelineSelectorModal`) and section display/interaction (`SectionContainer`). Implements an authentication flow using `@auth/sveltekit/client`'s `signIn`: if a non-logged-in user tries to save a non-public plan, it prompts for login, stores form data in `sessionStorage`, initiates login, and attempts to restore the data upon return. A similar flow exists to associate an anonymously created plan with a user post-creation. Includes undo/redo functionality via `historyStore` and keyboard shortcuts. Displays validation errors from the `$errors` store (populated by `submitPracticePlan` in the store).
    *   **Potential Issues:**
        *   **High Complexity & Store Dependency:** The component is very large and deeply coupled to multiple stores. Managing the interactions and ensuring data consistency across `practicePlanStore`, `sectionsStore`, `historyStore`, and `cartStore` could be challenging. State logic is spread between the component and the stores. Consider consolidating store logic or using more component-level state where appropriate.
        *   **Fragile Auth Flow (SessionStorage):** Relying on `sessionStorage` to persist form state across a login redirect (`signIn`) is inherently fragile. `sessionStorage` can be cleared by browser settings or extensions, leading to data loss. The restoration logic for complex nested state (like `$sections`) from the stringified JSON also needs careful testing. The post-creation association flow using `sessionStorage` has similar fragility.
        *   **Initial State Logic:** The `onMount` function has complex conditional logic for initializing the form based on whether it's a create/edit scenario and whether there's pending data in `sessionStorage`. This complexity increases the chance of bugs. Initializing sections from the cart (`$cart.map...`) involves assumptions about default durations and structure.
        *   **Direct Store Updates:** The component sometimes updates store values directly (e.g., `$practiceGoals[index] = e.target.value` in the input `on:input`, though `updatePracticeGoal` is also called; adding cart items directly to `$sections` in `onMount`). Prefer using dedicated store methods for all state mutations to encapsulate logic and ensure consistency (like `addPracticeGoal`, `removePracticeGoal`).
        *   **Submit Logic Location:** The core submission logic (`submitPracticePlan`) resides within the `practicePlanStore`, which the component calls. This couples the store to API interactions and navigation (`goto`). Consider moving API calls to a dedicated service layer or SvelteKit form actions for better separation of concerns.
        *   **Validation:** Validation appears to happen primarily within the `submitPracticePlan` store function, with errors populated back into `$errors`. Client-side validation before attempting submission would provide better UX.
        *   **Undo/Redo Complexity:** Implementing reliable undo/redo for complex, nested state involving multiple stores (`practicePlanStore` basics + `sectionsStore` structure) is difficult. Thorough testing is required to ensure `historyStore` correctly captures and restores all relevant state changes without corruption. The keyboard shortcut listener disables undo/redo when an input is focused, which is generally correct.
        *   **TinyMCE Integration:** Dynamic import is good. Ensure the API key (`VITE_TINY_API_KEY`) is handled securely. The fallback `<textarea>` provides basic functionality if the editor fails to load.
*   `src/routes/practice-plans/create/+page.server.js`:
    *   **Notes:** Fetches all drills using an internal API call (`/api/drills?all=true`). This data is presumably used by the `DrillSearchModal` within the `PracticePlanForm`. Returns the drills data or an error object.
    *   **Potential Issues:**
        *   **Scalability:** Fetching *all* drills (`?all=true`) in the `load` function could be very inefficient if the number of drills is large. This sends a potentially large amount of data to the client, even if the user never opens the drill search modal. The drill search modal should ideally fetch drills dynamically based on user input rather than relying on pre-loaded data.
        *   **Data Structure Assumption:** Assumes the API response structure is `{ drills: [...] }`. Verify this.
        *   **Generic Error Handling:** Uses the generic error object return `{ status: 500, error: '...' }` instead of `throw error(...)`.
*   `src/routes/practice-plans/create/+page.svelte`:
    *   **Notes:** Extremely simple wrapper component. It only imports and renders the `PracticePlanForm.svelte` component, passing no props (so the form knows it's in 'create' mode).
    *   **Potential Issues:** None specific to this file, but inherits any issues from `PracticePlanForm.svelte`. The data loaded by `create/+page.server.js` (all drills) isn't explicitly used here but is presumably available to `PracticePlanForm` via `$page.data` if needed (though the form doesn't seem to use it directly, relying on modals instead).
*   `src/routes/api/practice-plans/+server.js`:
    *   **Notes:** Handles GET (list) and POST (create) for practice plans. Uses `practicePlanService` for business logic. `GET` handler retrieves plans via `practicePlanService.getAll`, potentially filtering by `userId` if the service implements it. `POST` handler parses the request body, gets the `userId` from `locals`, and calls `practicePlanService.createPracticePlan`. Returns the created plan's ID and a 201 status on success. Includes a custom `PracticePlanError` class and uses it in the `POST` error handling to return specific status codes. Provides more detailed error logging in `POST`.
    *   **Potential Issues:**
        *   **GET Scalability:** The `GET` handler returns `result.items` from `getAll`. Similar to the page server file, this implies fetching and returning *all* practice plans without pagination or server-side filtering/sorting capabilities exposed via URL parameters. This needs to be implemented for scalability.
        *   **GET Authorization:** The `GET` handler passes `userId` to `getAll`, but it's unclear if `getAll` filters based on visibility rules (public, unlisted, private) or just returns plans created by the user (if any filtering is done at all). The service implementation needs verification to ensure users only see plans they are allowed to.
        *   **POST Authorization:** The `POST` handler gets `userId` but relies on `practicePlanService.createPracticePlan` to correctly associate the plan with the user and handle anonymous creation (if `userId` is undefined). Verification of the service logic is needed.
        *   **Error Handling Discrepancy:** `GET` uses basic error handling returning a generic 500 JSON payload, while `POST` uses the `PracticePlanError` class and more detailed logging/response structure. Error handling could be made more consistent.
        *   **Custom Error Class:** The `PracticePlanError` class is defined locally. If used across multiple API endpoints, it should be moved to a shared utility location.
*   `src/routes/api/practice-plans/[id]/+server.js`:
    *   **Notes:** Handles GET (one), PUT (update), and DELETE for specific practice plan IDs. Correctly extracts the `id` from `params`. Uses `practicePlanService` for all operations, passing the `userId` obtained from `locals` to the service methods for authorization checks. GET uses `getPracticePlanById`, PUT uses `updatePracticePlan`, DELETE uses `deletePracticePlan`. Implements more specific error handling than the collection endpoint, catching errors from the service and returning appropriate 404 (Not Found) and 403 (Unauthorized) status codes based on error messages. Uses `authGuard` wrapper for the DELETE handler to ensure user is authenticated before attempting deletion.
    *   **Potential Issues:**
        *   **DELETE `dev` Mode Logic:** The DELETE handler includes an `if (dev)` block. The comment suggests it bypasses permissions in development, but the code calls `practicePlanService.deletePracticePlan(id, userId)` in both the `if` and `else` branches. If the service correctly enforces permissions based on `userId`, this `dev` check is redundant and potentially misleading. If the intent *was* to bypass auth in dev, the service call should likely omit the `userId` or the service needs a specific flag. This logic should be clarified or removed.
        *   **Error Message Dependency:** Relies on specific error message strings ("Practice plan not found", "Unauthorized", etc.) from the service layer to determine 404/403 status. This is functional but slightly brittle; if service error messages change, the API error handling breaks. Using custom error classes or codes returned by the service would be more robust.
        *   Consistency: Error handling is better here than in the collection endpoint, highlighting inconsistency.
*   `src/routes/api/practice-plans/[id]/associate/+server.js`:
    *   **Notes:** Handles POST requests to associate a practice plan (specified by `id` in the URL) with the currently logged-in user. Intended for the flow where a user creates a plan anonymously and then logs in. Checks for an active session; returns 401 if not logged in. Parses the `planId`. Calls `practicePlanService.associatePracticePlan` with the `planId` and `userId`. Returns the updated plan on success. Handles specific errors from the service: 404 if the plan isn't found, and gracefully handles the case where the plan already has an owner by fetching and returning the existing plan data (effectively a no-op success).
    *   **Potential Issues:**
        *   **Error Message Dependency:** Similar to the main `[id]/+server.js`, it relies on specific error message strings ("Practice plan not found", "Practice plan already has an owner") from the service.
        *   **Idempotency:** While the handling of already-owned plans prevents errors, the endpoint isn't truly idempotent in the strict HTTP sense (POST usually implies resource creation/change, though it's used here for an update action). A PUT might be semantically slightly more appropriate, but POST is acceptable.
*   `src/routes/api/practice-plans/[id]/duplicate/+server.js`:
    *   **Notes:** Handles POST requests to duplicate a practice plan (specified by `id`). Gets the `userId` of the logged-in user (who will become the owner of the duplicate). Calls `practicePlanService.duplicatePracticePlan` with the original `id` and the `userId`. Returns a success message and the `id` of the *newly created* duplicate plan. Handles "not found" errors specifically (404) and generic errors (500).
    *   **Potential Issues:**
        *   **Authorization:** While it gets the `userId`, it relies entirely on `practicePlanService.duplicatePracticePlan` to check if the user has permission to *read* the original plan (`id`) they are trying to duplicate. If the original plan is private to another user, this endpoint might fail, but it depends on the service implementation. Adding a check here to ensure the user can access the source plan `id` before calling duplicate would be safer.
        *   **Error Message Dependency:** Again, relies on the "Practice plan not found" string from the service.
*   `src/lib/server/services/practicePlanService.js`:
    *   **Notes:** Extends `BaseEntityService` (presumably for common CRUD and permission logic). Defines methods for `getAll`, `getPracticePlanById`, `createPracticePlan`, `updatePracticePlan`, `deletePracticePlan`, `duplicatePracticePlan`, and `associatePracticePlan`. Uses database transactions (`withTransaction`, likely from `BaseEntityService` or `db`) for complex operations (create, getById, update, delete, duplicate) ensuring atomicity. Implements specific logic for handling nested sections and items (drills/breaks) within plans. Includes validation (`validatePracticePlan`), data formatting (`formatDrillItem`), and calculation helpers (`calculateSectionDuration`). Handles permissions by checking visibility (`public`, `unlisted`, `private`) and `created_by` / `is_editable_by_others` flags, often leveraging base service methods like `canUserView` and `canUserEdit`. Handles anonymous users appropriately in create/update/associate methods. `getPracticePlanById` fetches the plan, its sections, and its items (joining with the `drills` table for linked drills) and structures the data for the frontend. `createPracticePlan` and `updatePracticePlan` handle inserting/updating the plan, sections, and items into their respective tables. `duplicatePracticePlan` correctly copies the plan, sections, and items, assigning the new user. `associatePracticePlan` updates the `created_by` field for anonymously created plans.
    *   **Potential Issues:**
        *   **`getAll` Scalability:** The `getAll` method fetches all practice plans matching visibility rules, aggregates drill IDs/durations, but lacks pagination and filtering parameters. This will not scale well. It needs parameters for pagination (limit/offset), sorting, and filtering (by name, goals, etc.) to be passed down to the SQL query.
        *   **Update Strategy (Efficiency):** `updatePracticePlan` uses a "delete all sections/items then re-insert" strategy. This is simple to implement but inefficient, especially for large plans or minor changes (e.g., reordering one item). A more granular update approach (updating/inserting/deleting only changed items) would be more performant but significantly more complex to implement correctly.
        *   **Data Normalization/Formatting:** `formatDrillItem` reconstructs the client-side representation from potentially joined DB data. This logic is crucial for the frontend; ensure it correctly handles all item types (drill, one-off, break) and data structures. The mapping of 'one-off' type in the client to 'drill' type with a null `drill_id` in the DB is a specific convention to be aware of. `calculateSectionDuration` handles parallel items, which adds complexity.
        *   **Complexity:** The service handles complex nested data structures (plan -> sections -> items) and relationships. Methods like `create`, `update`, `getById`, and `duplicate` involve multiple dependent database operations within transactions, increasing complexity and potential for bugs.
        *   **Base Class Dependency:** Relies heavily on the `BaseEntityService` for transactions, core CRUD (`getById`, `update`), timestamp handling (`addTimestamps`), and permission checks (`enableStandardPermissions`, `canUserView`, `canUserEdit`). The correctness of `practicePlanService` depends significantly on the correct implementation of `BaseEntityService`.
        *   **Validation:** `validatePracticePlan` provides basic checks (name, presence of drills, phase). More comprehensive validation (e.g., item durations, structure) might be needed depending on requirements. Validation errors throw generic `Error` objects; using custom error types could improve API error handling.
        *   **Error Handling:** Uses `throw new Error('Message')`. The API layers rely on specific message strings for status codes. This works but is less robust than custom error classes/codes.
        *   **Default Section Logic:** `getPracticePlanById` creates a default section if none are found in the DB. This might hide underlying data issues if sections were expected but missing. Consider if this fallback is appropriate.
*   `src/lib/stores/practicePlanStore.js`:
    *   **Notes:** Defines numerous `writable` stores for individual form fields (`planName`, `planDescription`, `phaseOfSeason`, etc.), UI state (`isSubmitting`, `errors`, `formInitialized`), and importantly, the `practiceGoals` array. Exports constants (`phaseOfSeasonOptions`) and utility functions (`formatTime`, `addMinutes`). Includes a `derived` store (`totalPlanDuration`) that calculates the plan duration based on the `$sections` store (imported from `sectionsStore`). Provides functions for managing practice goals (`add/remove/updatePracticeGoal`). Contains `initializeForm` to populate stores from an existing `practicePlan` object. Includes `validateForm` for basic client-side validation. Contains the `submitPracticePlan` async function, which orchestrates validation, data normalization (`normalizeItems`), API call (`fetch`), error handling (updating `$errors` store), and displaying toasts. Contains helper functions (`normalizeItems`, `updateFilterState`, `handleDrillMove`, `mergeIntoParallelGroup`, `removeFromParallelGroup`) - some seem related to filtering or drag/drop which feel misplaced in a *form* state store.
    *   **Potential Issues:**
        *   **Bloated Store / Mixed Concerns:** The store mixes form field state, form UI state, form submission logic (including API calls and toasts), form initialization, validation, utility functions, *and* unrelated filter state stores (`selectedPhaseOfSeason`, etc.) and drag/drop helpers (`handleDrillMove`, etc.). This violates the single responsibility principle.
            *   **Recommendation:**
                *   Move filter-related stores (`selected...`) to a dedicated `practicePlanFilterStore.js`.
                *   Move form submission logic (`submitPracticePlan`) potentially to a SvelteKit Form Action or keep it within the `PracticePlanForm.svelte` component itself, calling the service layer directly. This decouples the store from API calls and side effects like toasts/navigation.
                *   Move drag/drop helpers (`handleDrillMove`, etc.) to `sectionsStore.js` or a dedicated drag/drop management store, as they operate on section items.
                *   Keep the core form field stores (`planName`, `planDescription`, etc.), `practiceGoals` management, `initializeForm`, and `validateForm` within this store, focusing it purely on the form's data state and basic validation.
        *   **Granular Stores:** Uses separate `writable` stores for almost every form field. While simple, managing many individual stores can be verbose. Consider consolidating related fields into a single store holding an object (e.g., a `planMetadata` store) if preferred, though the current approach is also valid.
        *   **Dependency on `sectionsStore`:** The `totalPlanDuration` calculation relies on importing and deriving from the `sections` store. This creates a tight coupling between the two stores. Calculating duration might be better placed within `sectionsStore` itself or passed as needed. The `submitPracticePlan` also directly uses `sectionsData` passed in as an argument.
        *   **Complex `normalizeItems`:** The `normalizeItems` function contains complex logic to prepare the `sections` data structure (from `sectionsStore`) for the API payload, handling parallel groups and item types/IDs. This logic is critical and needs careful testing; errors here would lead to incorrect data saving.
        *   **Validation Placement:** Validation logic (`validateForm`) is in the store but only checks a subset of fields. More validation happens implicitly within `submitPracticePlan` (checking for empty items). Consolidating validation logic would be clearer. Client-side validation before enabling the submit button would improve UX.
*   `src/lib/stores/sectionsStore.js`:
    *   **Notes:** Manages the primary `sections` store (an array of section objects, each with an array of `items`). Includes state for managing timeline selection (`selectedTimelines`, `selectedSectionId`) and custom timeline appearance (`customTimelineColors`, `customTimelineNames`). Provides default section structures (`DEFAULT_SECTIONS`) and timeline configurations (`DEFAULT_TIMELINE_NAMES`, `DEFAULT_TIMELINE_COLORS`). Exports numerous functions for manipulating this structure: adding/removing sections and items (`addSection`, `removeSection`, `addBreak`, `addOneOffDrill`, `addDrillToPlan`, `removeItem`), managing parallel groups (`createParallelBlock`, `handleUngroup`, `updateParallelBlockTimelines`, `removeTimelineFromGroup`), and managing timeline appearance (`updateTimelineName`, `updateTimelineColor`). Includes crucial helper functions for data transformation (`formatDrillItem`) and initialization from loaded data (`initializeSections`, `initializeTimelinesFromPlan`). Integrates with `historyStore` by calling `addToHistory` within many mutation functions. Calculates durations considering parallel blocks (`getParallelBlockDuration`, `calculateTimelineDurations`).
    *   **Potential Issues:**
        *   **Extreme Complexity:** This is a very large store (>1000 lines) handling highly complex, nested state (sections containing items, items potentially in parallel groups with multiple timelines). The logic for manipulating this structure, especially parallel blocks and their associated timelines (`groupTimelines` property seems critical), is intricate and spread across many functions (`createParallelBlock`, `updateParallelBlockTimelines`, `removeTimelineFromGroup`, `handleUngroup`, `formatDrillItem`, initialization logic). This significantly increases the risk of bugs and makes maintenance difficult.
        *   **State Structure & Immutability:** Managing the `sections` array with nested `items` directly in a `writable` store requires careful handling of immutable updates. Complex operations (like modifying parallel groups or reordering) can be cumbersome and potentially inefficient for large plans.
        *   **Data Formatting/Initialization (`formatDrillItem`, `initializeSections`)**: These functions are critical for translating between DB/API structures and the store's structure. Their complexity, especially around handling parallel groups, one-off items (identified by negative IDs or null `drill_id`), and ensuring properties like `groupTimelines` are correctly populated, makes them prone to errors.
        *   **History Integration:** Ensuring `addToHistory` captures the correct state and that undo/redo operations reliably restore this complex, nested state (especially involving parallel groups) is challenging and needs thorough testing.
        *   **Side Effects:** Some functions (`addDrillToPlan`, `addOneOffDrill`, `handleUngroup`) directly call `toast`, mixing UI side effects with state logic.
        *   **`selectedItems` Store:** This store is initialized (`writable([])`) and populated during `initializeSections`, but it doesn't appear to be actively used elsewhere in the reviewed form code. It might be leftover from previous implementations or used in unreviewed child components. Needs verification.
        *   **Global Counter:** Uses a module-level `sectionCounter` for generating IDs. This is generally discouraged in state management as it can cause issues; using UUIDs or other methods is often preferred. The use of negative timestamps for one-off drill IDs is a specific convention.
        *   **Misplaced Logic:** As noted in the `practicePlanStore` review, drag-and-drop helpers (`handleDrillMove`, `mergeIntoParallelGroup`, `removeFromParallelGroup`) logically belong here as they operate directly on the `items` within sections, but seem to have been moved to `practicePlanStore`.

**Files Pending Review:**

*(List remaining files)* 

## Practice Plan Viewer Components

- `src/routes/practice-plans/viewer/DrillCard.svelte`:
- `src/routes/practice-plans/viewer/ParallelGroup.svelte`:
- `src/routes/practice-plans/viewer/Section.svelte`:
- `src/routes/practice-plans/viewer/Timeline.svelte`: 