This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: CLAUDE.md, README.md, package.json, svelte.config.js, src/app.html, src/app.d.ts, src/hooks.server.js, src/lib/auth.js, src/lib/utils.ts, src/lib/server/db.js, src/lib/server/services/baseEntityService.js, src/lib/server/services/drillService.js, src/lib/stores/drillsStore.js, src/lib/stores/practiceStore.js, src/lib/validation/drillSchema.ts, src/lib/validation/practicePlanSchema.ts, src/routes/+layout.svelte, src/routes/+layout.server.js, src/routes/+page.svelte, src/routes/api/drills/+server.js, src/routes/api/drills/[id]/+server.js, src/routes/api/practice-plans/+server.js, src/routes/drills/+page.svelte, src/routes/practice-plans/+page.svelte, docs/architecture/index.md, docs/implementation/service-layer.md
- Files matching these patterns are excluded: **/*.test.js, **/*.spec.js, **/__tests__/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
QDrill Technical Review - Core Architecture (~55k tokens)

This package contains the essential architectural files for understanding QDrill:
- Project configuration and setup
- Database and authentication layer
- Key service layer implementations
- Core stores for state management
- Representative route examples
</user_provided_header>

<directory_structure>
docs/
  architecture/
    index.md
  implementation/
    service-layer.md
src/
  lib/
    server/
      services/
        baseEntityService.js
        drillService.js
      db.js
    stores/
      drillsStore.js
    validation/
      drillSchema.ts
      practicePlanSchema.ts
    auth.js
    utils.ts
  routes/
    api/
      drills/
        [id]/
          +server.js
        +server.js
      practice-plans/
        +server.js
    drills/
      +page.svelte
    practice-plans/
      +page.svelte
    +layout.server.js
    +layout.svelte
    +page.svelte
  app.d.ts
  app.html
  hooks.server.js
CLAUDE.md
package.json
README.md
svelte.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/architecture/index.md">
# QDrill Architecture

This section documents the architectural design, patterns, and decisions for the QDrill application.

## Contents

- Component Architecture
- Data Flow
- State Management
- API Design
- Database Schema

## Component Architecture

The QDrill application is built using a modular component architecture focused on reusability and separation of concerns.

### Key Components

_(Note: A recent code review identified several components, such as `ExcalidrawWrapper` and `PracticePlanForm`, as having high complexity and handling multiple concerns. The use of `ExcalidrawWrapper` also introduces a React dependency into the Svelte project. Refactoring these into smaller, focused components is recommended. See `code-review/` for details.)_

#### Base Components

- **Breadcrumb**: Navigation breadcrumb component for site navigation
- **Cart**: Manages selected drills for practice plan creation
- **Comments**: Allows users to comment on drills and practice plans
- **FeedbackButton/FeedbackModal**: User feedback submission system
- **FilterPanel**: Advanced filtering interface for drills
- **LoginButton**: Authentication interface component
- **Spinner**: Loading indicator for asynchronous operations
- **ThreeStateCheckbox**: Enhanced checkbox with intermediate state
- **UpvoteDownvote**: Voting component for drills and comments

#### Practice Plan Components

**Items**:

- **DrillItem**: Individual drill representation in practice plans
- **ParallelGroup**: Container for position-specific parallel timelines
- **TimelineColumn**: Column within a parallel group for specific positions

**Modals**:

- **DrillSearchModal**: Interface for searching and selecting drills
- **EmptyCartModal**: Alert when attempting to create plan with empty cart
- **TimelineSelectorModal**: Interface for configuring parallel timelines

**Sections**:

- **SectionContainer**: Groups related drills in a practice plan
- **SectionHeader**: Section header with editing capabilities

### Component Hierarchies

1. **Practice Plan Editor Flow**:

   - SectionContainer → DrillItem/ParallelGroup
   - ParallelGroup → TimelineColumn → DrillItem
   - Modals provide user interactions for drill selection and timeline configuration

   See the [drag-and-drop implementation](/docs/implementation/drag-and-drop.md) for details on the interactive movement of these components.

2. **Drill Management Flow**:
   - FilterPanel → Drill listings
   - Cart component for collecting drills before plan creation

## Data Flow

The application follows a unidirectional data flow pattern with Svelte's reactive store system as the central state management mechanism.

### Primary Data Flows

1. **Drill Selection Flow**:

   - User browses/filters drills → Adds to cart → Creates practice plan
   - Cart persists across pages via localStorage

2. **Practice Plan Building Flow**:

   - Sections contain items (drills, breaks)
   - Items can be grouped into parallel timelines (position-specific activities)
   - Drag-and-drop system for organizing items
   - History tracking for undo/redo functionality

3. **Authentication Flow**:
   - Login via Google OAuth
   - Session management for protected operations
   - Authorization checks for content ownership

## State Management

QDrill uses Svelte's store pattern for state management with specialized stores for different application concerns.

_(Note: The code review identified significant complexity and tight coupling in several key stores, particularly `sectionsStore` and `practicePlanStore`. State duplication exists between the practice plan wizard (`wizardStore`) and the main form/cart (`practicePlanStore`, `sectionsStore`), leading to maintenance challenges. Components are often tightly coupled to specific store implementations. The old `dragStore.js` file was unused and has been removed. Refactoring state management for better separation of concerns, reduced coupling, and eliminating duplication is a key recommendation. See `code-review/` for details.)_

### Key Stores

- **cartStore**: Manages selected drills using localStorage for persistence
- **dragManager**: Implements complex drag-and-drop functionality
- **sectionsStore**: Core practice plan state management with sections, timelines, parallel groups
- **practicePlanStore**: Manages overall practice plan metadata and operations
- **wizardStore/wizardValidation**: Multi-step practice plan creation wizard state
- **drillsStore**: Drill data and filtering operations
- **historyStore**: Undo/redo functionality with state snapshots
- **feedbackStore**: User feedback submission and management

### State Management Patterns

- **Reactive Declarations**: Using Svelte's `$store` syntax for subscribing to state changes
- **Immutable Updates**: State modifications use spread operators for immutable updates
- **Local Storage Persistence**: Critical user state persists between sessions
- **History Tracking**: State snapshots for undo/redo capabilities
- **Store Interactions**: Coordinated updates between interdependent stores (e.g., dragManager, sectionsStore, and historyStore during drag operations)
- **Error Recovery**: State backups before complex operations with restoration on error

## API Design

QDrill implements a RESTful API structure with consistent patterns for operations.

_(Note: The code review highlighted several areas for improvement in the API design and implementation. Key findings include scalability bottlenecks due to reliance on client-side filtering/sorting for major entities (drills, practice plans), inconsistent error handling approaches across different endpoints, missing or inconsistent authorization checks (including risky `dev` mode bypasses), some non-standard REST conventions, and instances where API routes bypass the service layer or shared database connection pool. Addressing these issues, particularly implementing server-side pagination/filtering/sorting and strengthening authorization, is crucial for scalability and security. See `code-review/` for details.)_

### API Endpoints Structure

- **/api/drills/**

  - GET: List/search drills
  - POST: Create new drill
  - PUT/PATCH: Update drill
  - DELETE: Remove drill
  - Specialized endpoints for filtering, searching, and variations

- **/api/practice-plans/**

  - CRUD operations for practice plans
  - Specialized endpoints for duplication and sharing

- **/api/auth/**

  - Authentication endpoints for Google OAuth
  - Session management

- **/api/feedback/**

  - Feedback submission and management
  - Voting on feedback items

- **/api/votes/**
  - Voting operations for drills and comments

### API Design Patterns

- **Standardized Responses**: Consistent JSON response structure
- **Error Handling**: Proper HTTP status codes with descriptive messages
- **Authorization**: Endpoint protection for authenticated operations
- **Pagination**: Offset-based pagination for list operations

## Database Schema

The application uses PostgreSQL (Neon) with a relational schema.

### Key Tables

- **drills**: Stores drill information (name, descriptions, skill levels, etc.)
- **skills**: Tracks skills focused on in drills
- **practice_plans**: Practice plan metadata
- **sections**: Practice plan organizational sections
- **items**: Individual items within practice plan sections
- **users**: User authentication and profile information
- **feedback**: User-submitted feedback
- **votes**: Voting records for drills and feedback
</file>

<file path="docs/implementation/service-layer.md">
# Service Layer Architecture

This document describes the service layer architecture implemented for QDrill. The service layer provides a clean separation between API endpoints and database operations, improving code organization, reusability, and maintainability.

_(Note: A [recent code review](../code-review/holistic-summary.md) evaluated the service layer implementation. Key findings include limitations in the `BaseEntityService`'s filtering capabilities and permission model rigidity, leading to inheriting services often bypassing it with direct DB calls or complex overrides. Some services contain highly complex logic (`DrillService`, `PracticePlanService`), potential normalization inconsistencies (e.g., JSON handling), and performance concerns (`UserService.getUserProfile`). The hardcoded admin check in `UserService` and its redundant permission logic were also noted. While the pattern provides benefits, addressing these limitations and ensuring consistent usage across all entities is recommended.)_

## Overview

The service layer pattern centralizes business logic and data access in specialized service classes, separating these concerns from the API routes. This architecture was first implemented with the Formations feature and provides a blueprint for future development.

## Key Components

### BaseEntityService

The `BaseEntityService` class provides a foundation for entity-specific services with common CRUD operations:

```javascript
export class BaseEntityService {
	constructor(tableName, primaryKey = 'id', defaultColumns = ['*']) {
		this.tableName = tableName;
		this.primaryKey = primaryKey;
		this.defaultColumns = defaultColumns;
	}

	// Common operations like getAll, getById, create, update, delete
	async getAll(options = {}) {
		/* ... */
	}
	async getById(id, columns = this.defaultColumns) {
		/* ... */
	}
	async create(data) {
		/* ... */
	}
	async update(id, data) {
		/* ... */
	}
	async delete(id) {
		/* ... */
	}
	async exists(id) {
		/* ... */
	}
	async search(searchTerm, searchColumns, options = {}) {
		/* ... */
	}
}
```

### Entity-Specific Services

Entity-specific services extend the BaseEntityService and implement domain-specific functionality:

```javascript
export class FormationService extends BaseEntityService {
	constructor() {
		super('formations', 'id', ['*']);
	}

	// Formation-specific methods
	async createFormation(formationData, userId = null) {
		/* ... */
	}
	async updateFormation(id, formationData) {
		/* ... */
	}
	async searchFormations(searchTerm, options = {}) {
		/* ... */
	}

	// Helper methods
	normalizeFormationData(data) {
		/* ... */
	}
}
```

## Benefits

1. **Code Reusability**: Common operations are defined once in the base service
2. **Consistent Error Handling**: Standardized approach across all entities
3. **Simplified API Endpoints**: Routes focus on request/response handling, not data logic
4. **Improved Testability**: Service methods can be tested in isolation
5. **Cleaner Abstractions**: Clear separation of concerns
6. **Future Extensibility**: Easy to add new entity types following the same pattern

## Implementation Details

### Database Connection

All services use a shared database connection layer (`db.js`) for consistent handling:

```javascript
// Database connection from db.js
export async function query(text, params) {
	const client = await getPool().connect();
	try {
		const res = await client.query(text, params);
		return res;
	} catch (err) {
		console.error('Database query error:', err);
		throw err;
	} finally {
		client.release();
	}
}
```

### Full-Text Search (FTS)

To provide efficient text searching, the application utilizes PostgreSQL's full-text search capabilities. This involves:

1.  **`tsvector` Column**: Tables containing searchable text content (e.g., `drills`, `practice_plans`, `formations`) include a `search_vector` column of type `tsvector`.
2.  **Update Function & Trigger**: A PostgreSQL function (e.g., `update_drill_search_vector`) and a corresponding trigger (e.g., `drill_search_vector_update`) are created for each searchable table. These automatically update the `search_vector` column whenever relevant text fields (like `name`, `description`) are inserted or updated. The function uses `to_tsvector` and `setweight` to combine and rank different text fields.
3.  **GIN Index**: A GIN (Generalized Inverted Index) is created on the `search_vector` column (e.g., `idx_gin_drill_search_vector`) to significantly speed up full-text queries.
4.  **Service Layer Integration**: The `BaseEntityService.search` method (and custom queries like in `PracticePlanService.getAll`) uses the `@@` operator with `plainto_tsquery` (or `to_tsquery`) against the `search_vector` column, replacing inefficient `LIKE` queries. Relevance sorting is often applied using `ts_rank_cd`.

**Update (Ticket #20):** The core FTS logic (querying the `search_vector` column with `plainto_tsquery` and ranking with `ts_rank_cd`) has been centralized within the enhanced `BaseEntityService.search` method. Services like `DrillService`, `PracticePlanService`, and `FormationService` now leverage this base method, passing the search term and relying on the base implementation. They still require the underlying database setup (tsvector column, function, trigger, index).

**Note:** When adding new searchable entities or fields, ensure the corresponding table has the `search_vector` column, update function, trigger, and GIN index configured. Migration scripts should handle the initial population of the `search_vector` for existing rows.

### API Integration

API endpoints use service instances to handle business logic:

```javascript
// Example API endpoint using service layer
export async function GET({ url }) {
	const searchTerm = url.searchParams.get('q') || '';
	const page = parseInt(url.searchParams.get('page')) || 1;
	const limit = parseInt(url.searchParams.get('limit')) || 10;

	try {
		const result = await formationService.searchFormations(searchTerm, {
			page,
			limit
		});

		return json(result);
	} catch (error) {
		console.error('Error searching formations:', error);
		return json({ error: 'An error occurred', details: error.message }, { status: 500 });
	}
}
```

## Implementation Plan

### Priority Ranking (Impact vs. Difficulty)

1. **DrillService** - ⭐⭐⭐⭐⭐

   - Impact: High (core functionality, many endpoints, complex logic)
   - Effort: 4-5 days
   - Key benefits: Centralizes complex filtering, standardizes drill operations, addresses most duplicated code

2. **PracticePlanService** - ⭐⭐⭐⭐

   - Impact: High (complex entity relationships, timeline management)
   - Effort: 5-6 days
   - Key benefits: Separates timeline logic from API, improves transaction handling

3. **UserService** - ⭐⭐⭐

   - Impact: Medium-High (auth integration, permission management)
   - Effort: 2-3 days
   - Key benefits: Consistent permission checks, simplified API endpoints

4. **SkillService** - ⭐⭐

   - Impact: Medium (simpler model but frequent usage)
   - Effort: 1-2 days
   - Key benefits: Quick win with low complexity

5. **CommentService** - ⭐⭐

   - Impact: Medium (improves consistency in comment handling)
   - Effort: 1-2 days
   - Key benefits: Standardized CRUD operations, better validation

6. **VoteService** - ⭐
   - Impact: Medium-Low (limited functionality)
   - Effort: 1-2 days
   - Key benefits: Handles race conditions, standardizes voting operations

### Implementation Status

#### DrillService

**Implementation Status: Completed**

1. ✅ Created DrillService class extending BaseEntityService
2. ✅ Implemented drill-specific methods:
   ```javascript
   async createDrill(drillData, userId)
   async updateDrill(id, drillData, userId)
   async deleteDrill(id, userId)
   async getDrillWithVariations(id)
   async createVariation(parentId, variationData, userId)
   async searchDrills(searchTerm, options)
   async getFilteredDrills(filters, options)
   async getDrillNames()
   async setAsPrimaryVariant(drillId, userId)
   async canUserEditDrill(drillId, userId)
   async updateSkillCounts(skillsToAdd, skillsToRemove, drillId)
   async updateSkills(skills, drillId)
   ```
3. ✅ Implemented normalizeDrillData() with comprehensive validation
4. ✅ Added transaction support for variant operations
5. ✅ Added permission checks for edit/delete actions
6. ✅ Exported singleton instance for use across API endpoints
7. ✅ Added comprehensive unit tests with Vitest

**Next Steps:**

- Refactor remaining API endpoints to use the service:
  - `/api/drills/[id]/upvote/+server.js`
  - `/api/drills/[id]/set-variant/+server.js`
  - `/api/drills/associate/+server.js`
  - `/api/drills/filter-options/+server.js`
  - `/api/drills/bulk-upload/+server.js`
  - `/api/drills/import/+server.js`

**Dependencies:**

- BaseEntityService
- SkillService (for skill updates)

#### PracticePlanService

**Implementation Status: Completed**

1. ✅ Created PracticePlanService class extending BaseEntityService
2. ✅ Implemented integrated section management rather than separate services
3. ✅ Implemented practice plan-specific methods:
   ```javascript
   async getAll(options)
   async createPracticePlan(planData, userId)
   async getPracticePlanById(id, userId)
   async updatePracticePlan(id, planData, userId)
   async deletePracticePlan(id, userId)
   async duplicatePracticePlan(id, userId)
   async validatePracticePlan(plan)
   ```
4. ✅ Implemented helper methods for data formatting and calculations:
   ```javascript
   formatDrillItem(item);
   calculateSectionDuration(items);
   ```
5. ✅ Added transaction support for section and drill management
6. ✅ Added proper permission checks for view/edit/delete operations
7. ✅ Exported singleton instance for use across API endpoints
8. ✅ Refactored API endpoints to use the service
9. ✅ Added comprehensive unit tests with Vitest

**Next Steps:**

- Further refine timeline management logic

**Dependencies:**

- BaseEntityService
- DrillService (for drill references)

#### FormationService

**Implementation Status: Completed**

1. ✅ Created FormationService class extending BaseEntityService
2. ✅ Implemented formation-specific methods:
   ```javascript
   async createFormation(formationData, userId)
   async updateFormation(id, formationData)
   async searchFormations(searchTerm, options)
   async getFormationsByUser(userId, options)
   ```
3. ✅ Implemented normalizeFormationData() with validation
4. ✅ Exported singleton instance for use across API endpoints
5. ✅ Refactored API endpoints to use the service
6. ✅ Added unit tests for formation operations

**Dependencies:**

- BaseEntityService

#### UserService

**Implementation Status: Planned**

1. Create UserService class extending BaseEntityService
2. Implement user-specific methods:
   ```javascript
   async getUserByEmail(email)
   async getUserProfile(userId)
   async isAdmin(userId)
   async canUserPerformAction(userId, actionType, entityType, entityId)
   ```
3. Create integration with Auth.js
4. Refactor user-related API endpoints to use service

**Implementation Details:**

- Use Auth.js users table structure
- Build methods for retrieving user-created content
- Add admin role checking
- Create centralized permission management

**Dependencies:**

- BaseEntityService
- Auth.js integration

#### SkillService

**Implementation Status: Planned**

1. Create SkillService class extending BaseEntityService
2. Implement skill-specific methods:
   ```javascript
   async getAllSkills(options)
   async updateSkillCounts(skillsToAdd, skillsToRemove, drillId)
   async getSkillsForDrill(drillId)
   async getMostUsedSkills(limit)
   ```
3. Refactor drill-related skill operations to use this service

**Implementation Details:**

- Centralize skill management across drill operations
- Create methods for tracking usage statistics
- Add skill filtering and recommendation functionality

**Dependencies:**

- BaseEntityService

### Testing Benefits

- **Isolation**: Testing business logic separate from API endpoints
- **Mocking**: Database operations can be mocked more easily
- **Edge Cases**: Better testing of validation and error handling
- **Unit Tests**: Focused tests for service functions without API overhead
- **Integration Tests**: Simpler setup with standardized service interfaces

### Unit Testing Implementation

Unit tests have been implemented for all service layer classes using Vitest:

1. **BaseEntityService Tests**:

   - Constructor and initialization tests
   - Column validation and sort order tests
   - Array field normalization tests
   - Timestamp handling tests
   - Error handling and transaction management tests

2. **DrillService Tests**:

   - Data normalization tests
   - CRUD operations tests
   - Permission checking tests
   - Drill variation management tests
   - Skill association tests
   - Search and filtering tests
   - User authorization tests

3. **PracticePlanService Tests**:

   - Duration calculation tests with parallel timelines
   - Data formatting tests
   - Plan validation tests
   - Section management tests
   - Duplication logic tests
   - Timeline organization tests

4. **FormationService Tests**:
   - Data normalization tests
   - CRUD operations tests
   - Diagram data validation tests

Additionally, API endpoint tests have been implemented to test the integration between API routes and the service layer:

1. **Drill API Tests**:

   - GET/POST/PUT/DELETE endpoint tests
   - Search functionality tests
   - Variation management tests
   - Error handling tests

2. **Practice Plan API Tests**:
   - Plan creation and retrieval tests
   - Plan update and deletion tests
   - Plan duplication tests
   - Permission and authorization tests

All tests can be run using:

- `pnpm run test:unit:run` - Run all unit tests
- `pnpm run test:unit` - Run tests in watch mode
- `pnpm run test:unit:coverage` - Run tests with coverage reporting

### Implementation Approach

1. **Incremental Migration**:

   - Implement one service at a time
   - Keep dual implementation during transition
   - Test thoroughly before removing old code

2. **Common Patterns**:

   - Use consistent method naming across services
   - Follow the same error handling pattern
   - Return standardized response objects

3. **Transaction Management**:
   - Add transaction support for multi-entity operations
   - Ensure proper rollback on errors
   - Consider adding transaction management to BaseEntityService

## Immediate Next Steps

### 1. Complete DrillService API Integration

**Priority: High**
**Effort: 1-2 days**

- Refactor remaining drill API endpoints to use DrillService
- Focus on endpoints in `/api/drills/` that still use direct DB access
- Prioritize high-traffic endpoints (upvote, search, filter)
- Ensure consistent error handling across all endpoints

### 2. Implement UserService

**Priority: High**
**Effort: 2-3 days**

- Create UserService based on Auth.js integration
- Implement profile management functionality
- Create centralized permission checking methods
- Refactor user-related API endpoints

### 3. Implement SkillService

**Priority: Medium**
**Effort: 1-2 days**

- Create SkillService with skill management methods
- Refactor DrillService to use SkillService
- Implement skill statistics and recommendations

### 4. Enhance BaseEntityService

**Priority: Medium**
**Effort: 1-2 days**

- Add caching support for frequently accessed data
- Implement advanced filtering capabilities
- Add event emitters for entity lifecycle events
- Improve transaction management

## Future Improvements

1. **Caching Layer**: Implement caching for frequently accessed data
2. **Advanced Filtering**: Enhance query building for complex filter conditions
3. **Event System**: Add event emitters for entity lifecycle events (create, update, delete)
4. **API Documentation**: Generate OpenAPI documentation from service definitions
5. **Performance Optimization**: Add database indexing strategy and query optimization

## Best Practices

When using the service layer:

1. **Keep Services Focused**: Each service should represent a single entity type
2. **Use Dependency Injection**: Pass dependencies to services rather than creating them internally
3. **Maintain Singleton Instances**: Create a single instance of each service for better resource management
4. **Normalize Data**: Use service methods to normalize data before storing/returning
5. **Comprehensive Error Handling**: Handle and transform database errors into appropriate API responses
6. **Consistent Response Format**: Return standardized objects with pagination, metadata, and data
7. **Testable Units**: Design services to be easily testable with mock dependencies
</file>

<file path="src/lib/server/db.js">
// import pkg from 'pg';
// const { Pool } = pkg;
import { createPool } from '@vercel/postgres'; // Import Vercel's createPool
import { Kysely, PostgresDialect, sql } from 'kysely'; // Import Kysely, PostgresDialect, and sql

// Create a Vercel-managed pool instance
let pool;

function getPool() {
	if (!pool) {
		const connectionString = process.env.POSTGRES_URL || process.env.DATABASE_URL;

		if (connectionString) {
			// Create a real pool when a connection string is available (dev/production runtime)
			pool = createPool({ connectionString });
		} else {
			// Fallback stub during build or when running without DB access (e.g. CI, static analysis)
			pool = {
				async query() {
					return { rows: [], rowCount: 0 };
				},
				async connect() {
					return {
						query: async () => ({ rows: [], rowCount: 0 }),
						release: () => {}
					};
				},
				async end() {}
			};
		}
	}
	return pool;
}

// Export the pool instance directly for use in other modules
export const vercelPool = getPool();

// Create and export a Kysely instance configured with the Vercel pool
export const kyselyDb = new Kysely({
	dialect: new PostgresDialect({
		pool: vercelPool
	})
});

// Re-export sql from Kysely so other modules can import it from here
export { sql };

export async function query(text, params) {
	// Use the Vercel pool directly
	try {
		const res = await vercelPool.query(text, params); // Use exported pool
		return res;
	} catch (err) {
		console.error('Database query error:', err);
		throw err;
	}
	// No manual client connect/release needed for simple queries with pool.query()
}

// Update getClient to use Vercel pool's connect method
export async function getClient() {
	return vercelPool.connect(); // Use exported pool
}

// Update end function
export async function end() {
	// Check the original variable, not the export
	if (pool) {
		await pool.end(); // Use the internal pool variable to end
		pool = null;
	}
}

// Alias for compatibility with hooks.server.js
export const cleanup = end;
</file>

<file path="src/lib/stores/drillsStore.js">
import { writable, derived } from 'svelte/store';
import { PREDEFINED_SKILLS } from '$lib/constants/skills';
import { selectedSortOption, selectedSortOrder } from './sortStore.js';
import { FILTER_STATES } from '$lib/constants';

// Pagination stores
export const currentPage = writable(1);
export const totalPages = writable(1);
export const totalItems = writable(0);
export const drillsPerPage = writable(10);
export const isLoading = writable(false);

// Filter stores
export const selectedSkillLevels = writable({});
export const selectedComplexities = writable({});
export const selectedSkillsFocusedOn = writable({});
export const selectedPositionsFocusedOn = writable({});
export const selectedNumberOfPeopleMin = writable(null);
export const selectedNumberOfPeopleMax = writable(null);
export const selectedSuggestedLengthsMin = writable(null);
export const selectedSuggestedLengthsMax = writable(null);
export const selectedHasVideo = writable(null);
export const selectedHasDiagrams = writable(null);
export const selectedHasImages = writable(null);
export const searchQuery = writable('');
export const selectedDrillTypes = writable({});

// Skills store
export const allSkills = writable(PREDEFINED_SKILLS);
export const sortedSkills = derived(allSkills, ($allSkills) =>
	[...$allSkills].sort((a, b) => a.name.localeCompare(b.name))
);
</file>

<file path="src/lib/validation/drillSchema.ts">
import { z } from 'zod';

// Constants reused from frontend/backend
const skillLevelOptions = [
	'New to Sport',
	'Beginner',
	'Intermediate',
	'Advanced',
	'Expert'
] as const;

const complexityOptions = ['Low', 'Medium', 'High'] as const;

const positionOptions = ['Chaser', 'Beater', 'Keeper', 'Seeker'] as const;

const drillTypeOptions = [
	'Competitive',
	'Skill-focus',
	'Tactic-focus',
	'Warmup',
	'Conditioning',
	'Cooldown',
	'Contact',
	'Match-like situation'
] as const;

const visibilityOptions = ['public', 'unlisted', 'private'] as const;

// Base schema for a drill
export const drillSchema = z.object({
	id: z.number().int().positive().optional(), // Optional for creation
	name: z.string().trim().min(1, 'Name is required'),
	brief_description: z.string().trim().min(1, 'Brief description is required'),
	detailed_description: z.string().trim().optional(), // Made optional based on Yup schema, tighten if needed
	skill_level: z.array(z.enum(skillLevelOptions)).min(1, 'At least one skill level is required'),
	complexity: z.enum(complexityOptions).nullable().optional(), // Optional field
	suggested_length: z
		.object({
			min: z.number().int().min(0, 'Suggested length min must be a non-negative integer'),
			max: z.number().int().min(0, 'Suggested length max must be a non-negative integer')
		})
		.refine((data) => data.max >= data.min, {
			message: 'Suggested length max must be greater than or equal to min',
			path: ['max'] // Attach error to the 'max' field
		}),
	number_of_people: z
		.object({
			min: z
				.number()
				.int()
				.positive('Number of people min must be a positive integer')
				.nullable()
				.optional(),
			max: z
				.number()
				.int()
				.positive('Number of people max must be a positive integer')
				.nullable()
				.optional()
		})
		.refine((data) => data.max == null || data.min == null || data.max >= data.min, {
			message: 'Number of people max must be greater than or equal to min',
			path: ['max'] // Attach error to the 'max' field
		})
		.nullable()
		.optional(), // The whole object is optional
	skills_focused_on: z
		.array(z.string().trim().min(1)) // Allow any non-empty string for now
		.min(1, 'At least one skill is required'),
	positions_focused_on: z
		.array(z.enum(positionOptions))
		.min(1, 'At least one position is required'),
	video_link: z.string().url('Video link must be a valid URL').nullable().optional(),
	diagrams: z.array(z.any()).optional(), // Representing Excalidraw data; could be stricter later
	drill_type: z.array(z.enum(drillTypeOptions)).min(1, 'At least one drill type is required'),

	// Metadata fields (useful for creation/update)
	created_by: z.number().int().positive().nullable().optional(), // Nullable for anonymous uploads/creations initially
	visibility: z.enum(visibilityOptions).default('public').optional(),
	is_editable_by_others: z.boolean().default(false).optional(),

	// Timestamps (generally handled by service, but useful for validation context)
	created_at: z.string().datetime().optional(),
	updated_at: z.string().datetime().optional(),

	// Added for bulk upload context if needed, not part of core drill data
	errors: z.array(z.string()).optional(),
	row: z.number().int().optional(),
	isEditing: z.boolean().optional(),
	editableDiagramIndex: z.number().int().nullable().optional()
});

// Schema specifically for creating a new drill (e.g., POST request)
// Omits fields generated by the server (id, timestamps, etc.)
export const createDrillSchema = drillSchema.omit({
	id: true,
	created_at: true,
	errors: true, // Not relevant for creation payload
	row: true,
	isEditing: true,
	editableDiagramIndex: true
});

// Schema for updating an existing drill (e.g., PUT request)
// Requires 'id' and makes other fields potentially optional if using PATCH semantics,
// but for PUT, usually, all relevant fields are expected.
// Let's assume PUT requires most fields but makes server-managed ones optional.
export const updateDrillSchema = drillSchema
	.extend({
		id: z.number().int().positive('Valid Drill ID is required for update')
	})
	.omit({
		created_at: true,
		errors: true, // Not relevant for update payload
		row: true,
		isEditing: true,
		editableDiagramIndex: true
	});

// Schema for the bulk upload *input* from the CSV parsing stage
// This needs to match the structure created by `parseDrill` before Yup validation was run
// Mapping the numeric codes back for skill/complexity
export const bulkUploadDrillInputSchema = z.object({
	name: z.string().trim().min(1, 'Name is required'),
	brief_description: z.string().trim().min(1, 'Brief description is required'),
	detailed_description: z.string().trim().optional(),
	skill_level: z.array(z.enum(skillLevelOptions)).min(1, 'At least one skill level is required'), // Already mapped in parseDrill
	complexity: z.enum(complexityOptions).nullable().optional(), // Already mapped in parseDrill
	suggested_length: z
		.object({
			min: z
				.number()
				.int()
				.min(0, 'Suggested length min must be a non-negative integer')
				.nullable(), // Allow null from parseInteger
			max: z.number().int().min(0, 'Suggested length max must be a non-negative integer').nullable() // Allow null from parseInteger
		})
		.refine((data) => data.min !== null, {
			message: 'Suggested length min is required',
			path: ['min']
		})
		.refine((data) => data.max !== null, {
			message: 'Suggested length max is required',
			path: ['max']
		})
		.refine((data) => data.min === null || data.max === null || data.max >= data.min, {
			message: 'Suggested length max must be greater than or equal to min',
			path: ['max']
		}),
	number_of_people: z
		.object({
			min: z
				.number()
				.int()
				.positive('Number of people min must be a positive integer')
				.nullable()
				.optional(), // Allow null from parseInteger
			max: z
				.number()
				.int()
				.positive('Number of people max must be a positive integer')
				.nullable()
				.optional() // Allow null from parseInteger
		})
		.refine((data) => data.max == null || data.min == null || data.max >= data.min, {
			message: 'Number of people max must be greater than or equal to min',
			path: ['max']
		})
		.nullable()
		.optional(),
	skills_focused_on: z.array(z.string().trim().min(1)).min(1, 'At least one skill is required'),
	positions_focused_on: z
		.array(z.enum(positionOptions))
		.min(1, 'At least one position is required'),
	video_link: z
		.string()
		.url('Video link must be a valid URL')
		.or(z.literal(''))
		.nullable()
		.optional(), // Allow empty string from CSV
	drill_type: z.array(z.enum(drillTypeOptions)).min(1, 'At least one drill type is required'),

	// Metadata added during parsing
	created_by: z.number().int().positive().nullable(), // Will be set from locals
	visibility: z.enum(visibilityOptions), // Will be set from form data
	is_editable_by_others: z.boolean(), // Will be set
	diagrams: z.array(z.any()).optional(), // Defaulted to []
	errors: z.array(z.string()).optional() // Defaulted to []
});

// Type helper
export type Drill = z.infer<typeof drillSchema>;
export type CreateDrillInput = z.infer<typeof createDrillSchema>;
export type UpdateDrillInput = z.infer<typeof updateDrillSchema>;
export type BulkUploadDrillInput = z.infer<typeof bulkUploadDrillInputSchema>;
</file>

<file path="src/lib/validation/practicePlanSchema.ts">
import { z } from 'zod';
import { drillSchema } from './drillSchema'; // Import the drill schema if needed for item validation

// Constants
const phaseOfSeasonOptions = [
	'Offseason',
	'Early season, new players',
	'Mid season, skill building',
	'Tournament tuneup',
	'End of season, peaking'
] as const;

const visibilityOptions = ['public', 'unlisted', 'private'] as const;
const practicePlanItemType = z.enum(['drill', 'break', 'one-off']); // Add 'one-off' if it's a valid type

// Base schema for Practice Plan Item (reused in Create/Update)
const practicePlanItemSchema = z.object({
	id: z.number().optional(), // Optional for creation, required for update/association
	type: z.enum(['drill', 'break', 'activity', 'formation']), // Added 'activity' and 'formation'
	name: z.string().min(1, 'Item name is required'),
	duration: z.number().int().min(1, 'Duration must be at least 1 minute'),
	drill_id: z.number().int().nullable().optional(), // Null for breaks or one-offs/activities
	formation_id: z.number().int().nullable().optional(), // For formation items
	diagram_data: z.string().nullable().optional(),
	parallel_group_id: z.string().nullable().optional(), // This identifies the item's role/timeline name
	parallel_timeline: z.string().nullable().optional(), // Will be hydrated to be same as parallel_group_id
	group_timelines: z.array(z.string()).nullable().optional(), // Will be hydrated with all timeline names in this item's parallel block
	order: z.number().int().optional() // Handled server-side during creation/update usually
});

// Base schema for Practice Plan Section (reused in Create/Update)
const practicePlanSectionSchema = z.object({
	id: z.number().optional(),
	name: z.string().min(1, 'Section name is required'),
	order: z.number().int().optional(), // Handled server-side
	goals: z.array(z.string()).optional(), // Assuming goals are strings
	notes: z.string().optional(),
	items: z
		.array(practicePlanItemSchema)
		.min(1, 'Each section must have at least one item')
		.refine(
			(items) => {
				// Ensure parallel items have group_id and timeline
				const parallelItems = items.filter((item) => item.parallel_group_id);
				return parallelItems.every((item) => item.parallel_group_id && item.parallel_timeline);
			},
			{ message: 'Parallel items must have both a group ID and a timeline.' }
		)
});

// Full Practice Plan schema (potentially for retrieval or updates including everything)
export const practicePlanSchema = z.object({
	id: z.number().optional(),
	name: z
		.string()
		.min(1, 'Plan name is required')
		.max(255, 'Plan name cannot exceed 255 characters'),
	description: z.string().optional(),
	phase_of_season: z.string().nullable().optional(), // Could add enum if phases are fixed
	estimated_number_of_participants: z
		.number()
		.int()
		.positive('Number of participants must be positive')
		.nullable()
		.optional(),
	practice_goals: z.array(z.string().min(1, 'Goal cannot be empty')).optional(),
	visibility: z.enum(['public', 'private', 'unlisted']).default('public'),
	is_editable_by_others: z.boolean().default(false),
	start_time: z
		.string()
		.regex(/^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/, 'Invalid start time format (HH:MM:SS)')
		.nullable()
		.optional(), // HH:MM:SS format
	sections: z
		.array(practicePlanSectionSchema)
		.min(1, 'A practice plan must have at least one section'),
	// Include other fields like user_id, created_at, updated_at if needed for validation context,
	// but they are usually handled server-side.
	total_duration: z.number().int().positive().optional(), // Often calculated, might not be directly validated
	user_id: z.string().optional(),
	created_at: z.string().datetime().optional(),
	updated_at: z.string().datetime().optional()
});

// Schema specifically for CREATING a new practice plan via API
export const createPracticePlanSchema = practicePlanSchema
	.omit({
		id: true, // ID is generated by DB
		user_id: true, // Should be set based on authenticated user server-side
		created_at: true,
		updated_at: true,
		total_duration: true // Calculated server-side
	})
	.extend({
		// Make sections/items require necessary fields for creation
		sections: z
			.array(
				practicePlanSectionSchema.omit({ id: true }).extend({
					// Omit section ID for creation
					items: z
						.array(
							practicePlanItemSchema.omit({ id: true }) // Omit item ID for creation
						)
						.min(1, 'Each section must have at least one item')
				})
			)
			.min(1, 'A practice plan must have at least one section')
	});

// Schema specifically for UPDATING an existing practice plan via API
// Might need refinement based on how updates work (e.g., partial updates)
export const updatePracticePlanSchema = practicePlanSchema.partial().required({
	id: true // Require ID for updating
});

// Schema for validating just the metadata (e.g., in the form before sections/items are added)
export const practicePlanMetadataSchema = practicePlanSchema
	.pick({
		name: true,
		description: true,
		phase_of_season: true,
		estimated_number_of_participants: true,
		practice_goals: true,
		visibility: true,
		is_editable_by_others: true,
		start_time: true
	})
	.extend({
		// Adjust types/validation if the form input differs slightly from the final DB model
		estimated_number_of_participants: z.preprocess(
			(val) => (val === '' || val === null || val === undefined ? null : Number(val)),
			z.number().int().positive('Number of participants must be positive').nullable().optional()
		),
		practice_goals: z
			.array(z.string().min(1, 'Goal cannot be empty'))
			.refine((goals) => goals.length > 0, { message: 'At least one practice goal is required' })
			.optional()
	});

// Schema specifically for the Wizard's Basic Info step
export const practicePlanBasicInfoSchema = z.object({
	name: z
		.string()
		.min(1, 'Plan name is required')
		.max(255, 'Plan name cannot exceed 255 characters'),
	description: z.string().optional(),
	phaseOfSeason: z.string().nullable().optional(), // Renamed from phase_of_season to match form state
	participants: z.preprocess(
		// Renamed from estimated_number_of_participants
		(val) => (val === '' || val === null || val === undefined ? null : Number(val)),
		z.number().int().positive('Number of participants must be positive').nullable().optional()
	),
	practiceGoals: z
		.array(z.string().min(1, 'Goal cannot be empty')) // Renamed from practice_goals
		.refine((goals) => goals.length > 0, { message: 'At least one practice goal is required' })
		.optional(),
	visibility: z.enum(['public', 'private', 'unlisted']).default('public'),
	isEditableByOthers: z.boolean().default(false) // Renamed from is_editable_by_others
	// Omitting start_time as it's not currently in the basic-info form
	// Omitting skillLevel, totalTime as they aren't in the final plan metadata schema
});

// Schema for Associating Drills/Breaks (e.g., adding items to a section)
export const associateItemSchema = z.object({
	sectionId: z.number().int(),
	item: practicePlanItemSchema // Validate the item being added
});

// Schema for associating existing drills/formations to a practice plan item
export const associateExistingSchema = z.object({
	practicePlanId: z.number().int(),
	sectionId: z.number().int(),
	itemId: z.number().int(), // The practice plan item ID (break/placeholder)
	resourceId: z.number().int(), // The ID of the drill or formation
	resourceType: z.enum(['drill', 'formation'])
});

// Type helpers
export type PracticePlan = z.infer<typeof practicePlanSchema>;
export type PracticePlanSection = z.infer<typeof practicePlanSectionSchema>;
export type PracticePlanItem = z.infer<typeof practicePlanItemSchema>;
export type CreatePracticePlanInput = z.infer<typeof createPracticePlanSchema>;
export type UpdatePracticePlanInput = z.infer<typeof updatePracticePlanSchema>;
export type PracticePlanMetadata = z.infer<typeof practicePlanMetadataSchema>;
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
import { cubicOut } from 'svelte/easing';
import type { TransitionConfig } from 'svelte/transition';

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

type FlyAndScaleParams = {
	y?: number;
	x?: number;
	start?: number;
	duration?: number;
};

export const flyAndScale = (
	node: Element,
	params: FlyAndScaleParams = { y: -8, x: 0, start: 0.95, duration: 150 }
): TransitionConfig => {
	const style = getComputedStyle(node);
	const transform = style.transform === 'none' ? '' : style.transform;

	const scaleConversion = (valueA: number, scaleA: [number, number], scaleB: [number, number]) => {
		const [minA, maxA] = scaleA;
		const [minB, maxB] = scaleB;

		const percentage = (valueA - minA) / (maxA - minA);
		const valueB = percentage * (maxB - minB) + minB;

		return valueB;
	};

	const styleToString = (style: Record<string, number | string | undefined>): string => {
		return Object.keys(style).reduce((str, key) => {
			if (style[key] === undefined) return str;
			return str + `${key}:${style[key]};`;
		}, '');
	};

	return {
		duration: params.duration ?? 200,
		delay: 0,
		css: (t) => {
			const y = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);
			const x = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);
			const scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);

			return styleToString({
				transform: `${transform} translate3d(${x}px, ${y}px, 0) scale(${scale})`,
				opacity: t
			});
		},
		easing: cubicOut
	};
};
</file>

<file path="src/routes/api/drills/[id]/+server.js">
import { json, error as svelteKitError } from '@sveltejs/kit';
import { drillService } from '$lib/server/services/drillService';
import { dev } from '$app/environment';
import * as db from '$lib/server/db';
import { authGuard } from '$lib/server/authGuard';
import {
	AppError,
	NotFoundError,
	ForbiddenError,
	ValidationError,
	DatabaseError
} from '$lib/server/errors';

const ERROR_MESSAGES = {
	NOT_FOUND: (id) => `Drill with ID ${id} not found`,
	UNAUTHORIZED: 'Unauthorized access',
	DB_ERROR: 'Database operation failed',
	INVALID_INPUT: 'Invalid input data'
};

// Helper function to convert AppError to SvelteKit error response
function handleApiError(err) {
	if (err instanceof AppError) {
		console.warn(`[API Warn] (${err.status} ${err.code}): ${err.message}`);
		const body = { error: { code: err.code, message: err.message } };
		if (err instanceof ValidationError && err.details) {
			body.error.details = err.details;
		}
		return json(body, { status: err.status });
	} else {
		// Handle potential database constraint errors specifically if needed
		if (err?.code === '23503') {
			// Foreign key violation
			console.warn('[API Warn] Foreign key constraint violation:', err.detail);
			return json(
				{ error: { code: 'CONFLICT', message: 'Cannot perform operation due to related items.' } },
				{ status: 409 }
			);
		} else if (err?.code === '23505') {
			// Unique constraint violation
			console.warn('[API Warn] Unique constraint violation:', err.detail);
			return json(
				{ error: { code: 'CONFLICT', message: 'An item with this identifier already exists.' } },
				{ status: 409 }
			);
		}

		console.error('[API Error] Unexpected error:', err);
		return json(
			{
				error: {
					code: 'INTERNAL_SERVER_ERROR',
					message: 'An unexpected internal server error occurred'
				}
			},
			{ status: 500 }
		);
	}
}

export async function GET({ params, locals, url }) {
	const { id } = params;
	const includeVariants = url.searchParams.get('includeVariants') === 'true';
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		let drill;
		if (includeVariants) {
			drill = await drillService.getDrillWithVariations(drillId);
		} else {
			drill = await drillService.getById(drillId);
		}

		// Check visibility and ownership
		if (drill.visibility === 'private') {
			if (!userId || drill.created_by !== userId) {
				throw new ForbiddenError('Unauthorized to view this private drill');
			}
		}

		// If this is a variation, get the parent name
		if (drill.parent_drill_id && !drill.variations) {
			try {
				const parentDrill = await drillService.getById(drill.parent_drill_id);
				if (parentDrill) {
					drill.parent_drill_name = parentDrill.name;
				}
			} catch (parentErr) {
				if (parentErr instanceof NotFoundError) {
					console.warn(
						`Parent drill ID ${drill.parent_drill_id} not found for variation ${drill.id}`
					);
					drill.parent_drill_name = '[Parent Deleted]'; // Indicate parent is gone
				} else {
					throw parentErr; // Re-throw unexpected errors getting parent
				}
			}
		}

		return json(drill);
	} catch (err) {
		return handleApiError(err);
	}
}

// Wrap PUT handler with authGuard
export const PUT = authGuard(async ({ params, request, locals }) => {
	const { id } = params;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		const drillData = await request.json();

		// Basic validation
		if (!drillData.name || !drillData.brief_description) {
			throw new ValidationError('Required fields missing: name, brief_description');
		}

		// Use DrillService to update the drill (now also updates votes)
		const updatedDrill = await drillService.updateDrill(drillId, drillData, userId);

		return json(updatedDrill);
	} catch (err) {
		return handleApiError(err);
	}
});

// Define core delete logic (used by guarded handler)
const handleDelete = async ({ params, locals }) => {
	const { id } = params;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		// Pass userId for authorization check within the service
		const success = await drillService.deleteDrill(drillId, userId);

		if (!success) {
			// Service returns false if not found, true if deleted
			throw new NotFoundError(`Drill with ID ${drillId} not found for deletion.`);
		}

		return json({ message: 'Drill deleted successfully' }, { status: 200 });
	} catch (err) {
		// Catch FK constraint errors specifically if service doesn't handle them gracefully
		if (err?.code === '23503') {
			throw new DatabaseError('Cannot delete: drill is referenced by other items', err); // Wrap it
		}
		// Re-throw other errors to be handled by the main handler/helper
		throw err;
	}
};

// Export DELETE handler, applying authGuard only when not in dev mode
export const DELETE = async (event) => {
	try {
		const { id } = event.params;
		const session = event.locals.session;
		const userId = session?.user?.id || null; // Used for dev check

		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		if (dev) {
			console.log(`[DEV MODE BYPASS] Attempting deletion for drill ${drillId} with related data.`);
			// Call the service method with deleteRelated: true
			// Pass userId (can be null) - service checks if drill.created_by === userId OR (drill.created_by === null AND deleteRelated)
			const result = await drillService.deleteDrill(drillId, userId, { deleteRelated: true });

			if (!result) {
				// Service handles not found case by returning false
				throw new NotFoundError(`Drill with ID ${drillId} not found for deletion (dev mode).`);
			}

			return json(
				{ success: true, message: 'Drill and related data deleted (dev mode)' },
				{ status: 200 }
			);
		} else {
			// In production, use the authGuard with the original handleDelete logic
			const guardedDelete = authGuard(handleDelete);
			return await guardedDelete(event); // Ensure guarded function is awaited
		}
	} catch (err) {
		return handleApiError(err);
	}
};
</file>

<file path="src/routes/api/drills/+server.js">
import { json, error as svelteKitError } from '@sveltejs/kit';
import { authGuard } from '$lib/server/authGuard';
import { drillService } from '$lib/server/services/drillService';
import { AppError, DatabaseError, ValidationError, NotFoundError } from '$lib/server/errors'; // Import NotFoundError
import { z } from 'zod'; // Import zod
import { createDrillSchema, updateDrillSchema } from '$lib/validation/drillSchema'; // Import Zod schemas

// Helper function to convert AppError to SvelteKit error response
function handleApiError(err) {
	// Handle Zod validation errors specifically
	if (err instanceof z.ZodError) {
		console.warn(`[API Warn] Validation failed:`, err.flatten());
		// Convert Zod errors to the format expected by the frontend/ValidationError
		const details = err.flatten().fieldErrors;
		const validationError = new ValidationError('Validation failed', details);
		return json(
			{
				error: {
					code: validationError.code,
					message: validationError.message,
					details: validationError.details
				}
			},
			{ status: validationError.status }
		);
	}
	// Handle custom AppErrors
	else if (err instanceof AppError) {
		console.warn(`[API Warn] (${err.status} ${err.code}): ${err.message}`);
		const body = { error: { code: err.code, message: err.message } };
		if (err instanceof ValidationError && err.details) {
			body.error.details = err.details;
		}
		return json(body, { status: err.status });
	}
	// Handle generic errors
	else {
		console.error('[API Error] Unexpected error:', err);
		return json(
			{
				error: {
					code: 'INTERNAL_SERVER_ERROR',
					message: 'An unexpected internal server error occurred'
				}
			},
			{ status: 500 }
		);
	}
}

export const GET = async ({ url, locals }) => {
	// Get session info to pass userId for filtering
	const session = locals.session;
	const userId = session?.user?.id;

	// Pagination
	const page = parseInt(url.searchParams.get('page') || '1');
	const limit = parseInt(url.searchParams.get('limit') || '10');

	// Sorting
	const sortBy = url.searchParams.get('sort'); // e.g., 'name', 'date_created'
	const sortOrder = url.searchParams.get('order') || 'desc'; // 'asc' or 'desc'

	// Filters - Parse all specified filters from performance.md
	const filters = {};
	const parseCommaSeparated = (param) =>
		url.searchParams.has(param)
			? url.searchParams
					.get(param)
					.split(',')
					.map((t) => t.trim().toLowerCase())
					.filter((t) => t)
			: undefined;

	filters.skill_level = parseCommaSeparated('skillLevel');
	filters.complexity = url.searchParams.get('complexity')?.toLowerCase();
	filters.skills_focused_on = parseCommaSeparated('skills');
	filters.positions_focused_on = parseCommaSeparated('positions');
	filters.drill_type = parseCommaSeparated('types');

	const minPeople = url.searchParams.get('minPeople');
	const maxPeople = url.searchParams.get('maxPeople');
	if (minPeople) filters.number_of_people_min = parseInt(minPeople);
	if (maxPeople) filters.number_of_people_max = parseInt(maxPeople);

	const minLength = url.searchParams.get('minLength');
	const maxLength = url.searchParams.get('maxLength');
	// Assuming suggested_length is stored in minutes (or some numeric unit)
	if (minLength) filters.suggested_length_min = parseInt(minLength);
	if (maxLength) filters.suggested_length_max = parseInt(maxLength);

	const parseBooleanFilter = (param) => {
		const value = url.searchParams.get(param)?.toLowerCase();
		return value === 'true' ? true : value === 'false' ? false : undefined;
	};
	filters.hasVideo = parseBooleanFilter('hasVideo');
	filters.hasDiagrams = parseBooleanFilter('hasDiagrams');
	filters.hasImages = parseBooleanFilter('hasImages');

	filters.searchQuery = url.searchParams.get('q');

	// Add userId to filters
	if (userId) filters.userId = userId;

	// Remove undefined filters
	Object.keys(filters).forEach((key) => filters[key] === undefined && delete filters[key]);

	// Build options objects for the service
	const options = {
		page,
		limit,
		sortBy,
		sortOrder
	};

	try {
		// Call the enhanced getFilteredDrills method
		const result = await drillService.getFilteredDrills(filters, options);

		// Return structure matches the frontend expectation from Phase 2 plan
		return json(result);
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
};

export const POST = async (event) => {
	try {
		const rawData = await event.request.json();
		const session = event.locals.session;
		let userId = session?.user?.id || null;

		// Ensure userId is a number if it exists and is a string representation of a number
		if (userId && typeof userId === 'string') {
			const parsedUserId = parseInt(userId, 10);
			if (!isNaN(parsedUserId)) {
				userId = parsedUserId;
			} else {
				// Handle case where userId is a string but not a valid number - perhaps error or set to null
				console.warn(`Invalid string user ID found: ${userId}. Treating as null.`);
				userId = null;
			}
		}

		// Add userId to the data before validation if not present
		const dataWithUser = { ...rawData, created_by: userId };

		// Validate data using Zod schema
		// Use safeParse to handle validation errors explicitly
		const validationResult = createDrillSchema.safeParse(dataWithUser);

		if (!validationResult.success) {
			// Throw ZodError to be caught by handleApiError
			throw validationResult.error;
		}

		// Use the validated data
		const validatedData = validationResult.data;

		// Use the DrillService to create the drill
		const drill = await drillService.createDrill(validatedData, userId); // Pass validatedData

		return json(drill, { status: 201 }); // Return 201 Created
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
};

export const PUT = authGuard(async ({ request, locals }) => {
	try {
		const rawData = await request.json();
		const session = locals.session;
		const userId = session.user.id;

		console.log('--- RAW DATA for Zod Validation (PUT) ---', JSON.stringify(rawData, null, 2)); // Log rawData

		// Validate data using Zod schema
		const validationResult = updateDrillSchema.safeParse(rawData);

		// --- TEMPORARY LOGGING ---
		console.log('--- Zod Validation Result (PUT) ---', JSON.stringify(validationResult, null, 2));
		if (validationResult.success) {
			console.log(
				'--- Zod Validated Data (PUT) ---',
				JSON.stringify(validationResult.data, null, 2)
			);
		} else {
			console.error(
				'--- Zod Validation Errors (PUT) ---',
				JSON.stringify(validationResult.error.flatten(), null, 2)
			);
		}
		// --- END TEMPORARY LOGGING ---

		if (!validationResult.success) {
			console.error(
				'Zod validation failed in PUT /api/drills, throwing error:',
				validationResult.error.flatten()
			);
			throw validationResult.error;
		}

		// Use the validated data
		const validatedData = validationResult.data;

		// Use the DrillService to update the drill
		// Pass the drill ID and the rest of the validated data separately
		const updatedDrill = await drillService.updateDrill(validatedData.id, validatedData, userId);

		return json(updatedDrill);
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
});

export const DELETE = authGuard(async ({ params, request, locals }) => {
	// Prefer ID from URL parameter if available (e.g., if route was /api/drills/[id])
	let drillId = params.id ? parseInt(params.id) : null;

	// If ID not in params, try getting from body (less standard for DELETE)
	if (!drillId) {
		try {
			const { id } = await request.json();
			if (id) drillId = parseInt(id);
		} catch (e) {
			// Ignore errors reading body if it's empty or not JSON
		}
	}

	if (!drillId || isNaN(drillId)) {
		return handleApiError(
			new ValidationError(
				'Valid Drill ID must be provided either in the URL or request body for DELETE'
			)
		);
	}

	const session = locals.session;
	const userId = session.user.id;

	try {
		// Use the DrillService to delete the drill
		const success = await drillService.deleteDrill(drillId, userId, { deleteRelated: false }); // Default to not deleting related

		if (!success) {
			// If deleteDrill returns false, it means not found or not permitted
			// Distinguish between NotFound and Forbidden if possible, otherwise default to NotFound
			return handleApiError(
				new NotFoundError(`Drill with ID ${drillId} not found or access denied for deletion.`)
			);
		}

		return json({ message: 'Drill deleted successfully' }, { status: 200 }); // Use 200 OK or 204 No Content
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
});
</file>

<file path="src/routes/+layout.server.js">
import { dev } from '$app/environment';
import { injectAnalytics } from '@vercel/analytics/sveltekit';
import { injectSpeedInsights } from '@vercel/speed-insights/sveltekit';

injectAnalytics({ mode: dev ? 'development' : 'production' });
injectSpeedInsights();

/** @type {import('./$types').LayoutServerLoad} */
export async function load({ locals }) {
	return {
		session: locals.session
	};
}
</file>

<file path="src/app.d.ts">
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="README.md">
# QDrill

A comprehensive web-based application for sports drill management and practice planning.

## Overview

QDrill is a web-based application designed to be a sports drill bank and practice planning tool for a niche sport. The application allows users to create, manage, and share drills, as well as plan practices. The user experience (UX) is a high priority, with an emphasis on smooth, responsive interactions and a modern design. The application is expected to handle up to a few hundred concurrent users and is built with SvelteKit for both frontend and backend.

## Technology Stack

- **Frontend**: Svelte with SvelteKit
- **Backend**: SvelteKit
- **Database**: Neon (PostgreSQL)
- **Authentication**: Auth.js (using Google OAuth)
- **Diagramming**: Excalidraw (via `@excalidraw/excalidraw`, note: includes React dependency)
- **Rich Text Editing**: TinyMCE
- **Deployment**: Hosted on Vercel
- **CSS**: Tailwind CSS
- **Testing**: Vitest (unit), Playwright and Cypress (end-to-end)

## Core Features

### 1. Drill and Formation Management

- **Form-Based Drill Creation**: Users can create new drills via a form interface. Each drill will have the following attributes:
  - Name (required)
  - Brief description (required)
  - How to teach it/detailed description
  - Skill level required (required)
  - Complexity to explain
  - Suggested length of time (required)
  - Number of people required
  - Skills focused on (required)
  - Positions focused on (required)
  - Video link to drill
  - Images of drill
- **Dynamic URL Generation**: Each drill will automatically be assigned a unique URL upon creation, allowing users to share and access drills directly.
- **Public vs. Private Drills**: Users can choose to make drills public or private. Public drills are accessible by all, while private drills require a specific link. Users can also create public versions of private drills with a different description.

### 2. Drill and Formation Filtering and Viewing

- **Client-Side Filtering**: Drills and formations are currently fetched to the client-side, where filtering occurs. While this provides a responsive feel for smaller datasets, it has been identified as a scalability limitation for larger numbers of items (code review notes).
- **Listing Views**: The main views will display lists of drills or formations, showing their name, attributes, brief description, and indications of any media (pictures/videos).
- **Detail Pages**: Each drill and formation will have a dedicated page showing all of its details. Users can comment on drills, upvote them, or create variations.
- **Formations**: A specialized system for static player positions that can be created, shared, and viewed separately from the dynamic drills.

### 3. Practice Plan Creation and Management

- **Form-Based Practice Planning**: Users can create practice plans by selecting drills based on the number of players, skill levels, practice duration, and skills to focus on. Two primary methods exist: a cart-based approach (adding drills to a cart first) and a step-by-step wizard.
- **Plan Customization**: After selecting drills, users can define additional practice details, including:
  - Practice name
  - Practice goals
  - Phase of the season
  - Number of participants suited for
  - Level of experience suited for
  - Skills focused on
  - Brief overview of practice flow
  - Time dedicated to each drill
  - Breaks between drills
  - Total practice time
- **Public vs. Private Plans**: Similar to drills, practice plans can be published either privately (accessible via link) or publicly. Users can write different overviews for public/private versions if desired.

### 4. User Interaction and Profiles

- **User Accounts**: Users can create accounts via OAuth (e.g., Google). Logged-in users can create, comment on, and upvote drills or practice plans, and create variations.
- **Anonymous Interaction**: Users who are not logged in can still view and vote on drills, and create practice plans, though publishing or saving them for future editing requires logging in.
- **User Profiles**: Profiles can include optional information such as name, team played for, country, and social media links.
- **User Access**: All users will have the same level of access. Each user will have their own private drills and practice plans, and they can save public drills and plans. Users can see the drills and plans they have saved.

### 5. Backend and Data Management

- **Vercel Postgres Database**: Used for storing all application data, including drills, practice plans, user accounts, and comments.
- **API Integration**: The SvelteKit frontend will communicate with the SvelteKit backend via RESTful APIs to manage drill creation, filtering, user management, and more.
- **Media Management**: Images will be hosted directly on the application, while videos will be linked from external sources (e.g., YouTube, cloud storage).

### 6. Deployment and Hosting

- **Frontend**: Hosted on Vercel with the custom domain (e.g., qdrill.app).
- **Backend**: Hosted on Vercel's serverless functions or as a separate service if needed, handling API requests and database interactions.

### 7. Testing and Quality Assurance

- **Vitest**: Used for unit testing the service layer and other backend functionality.
- **Playwright**: Used for end-to-end testing.
- **Cypress**: Used for additional end-to-end testing to ensure the entire user flow, from drill creation to practice plan publishing, works smoothly.

### 8. UX and Design

- **Design Aesthetic**: The design will follow a style similar to Figma, with a clean, minimalist look. The color scheme and fonts will be inspired by Figma, but with an emphasis on ensuring faster loading times and responsive filtering without noticeable delays.

## Development

### Getting Started

1. **Install dependencies**:

   ```bash
   pnpm install
   ```

2. **Run the development server**:

   ```bash
   vercel dev
   ```

3. **Check TypeScript + SvelteKit sync**:
   ```bash
   pnpm run check
   ```

### Package Management

- **Install dependencies**:

  ```bash
  pnpm install
  ```

- **Add a package**:
  ```bash
  pnpm add <package>
  ```

### Testing

- **Run Playwright tests**:

  ```bash
  pnpm run test
  ```

- **Run a specific test**:

  ```bash
  pnpm test -- tests/test.js
  ```

- **Run Vitest unit tests in watch mode**:

  ```bash
  pnpm run test:unit
  ```

- **Run Vitest unit tests once**:

  ```bash
  pnpm run test:unit:run
  ```

- **Run Vitest unit tests with coverage**:
  ```bash
  pnpm run test:unit:coverage
  ```

### Code Quality

- **Run linting checks**:

  ```bash
  pnpm run lint
  ```

- **Fix formatting issues**:
  ```bash
  pnpm run format
  ```

### Database Migrations

Database schema changes are managed using `node-pg-migrate`.

- **Create a new migration**:

  ```bash
  npx node-pg-migrate create <migration_name>
  ```

  Replace `<migration_name>` with a descriptive name (e.g., `add_user_email_column`).

- **Run migrations**:

  ```bash
  npx node-pg-migrate up
  ```

  This applies all pending migrations. Make sure your `DATABASE_URL` environment variable is set correctly (e.g., in `.env.local` or your shell environment).

- **Rollback the last migration**:
  ```bash
  npx node-pg-migrate down
  ```

### Deployment

Deployment is automatic from the GitHub main branch to Vercel.

## Documentation

Project documentation is organized in two main locations:

1. **`docs/`**: Detailed technical documentation
   - **`Architecture`**: System design, patterns, and architectural decisions
   - **`Implementation`**: Technical details and implementation specifics
     - Drag and Drop System
     - Timeline Management
     - Service Layer Architecture
2. **`code-review/`**: Contains detailed findings and notes from a comprehensive code review conducted to assess codebase health, identify areas for improvement, and align with professional development standards. See `code-review/holistic-summary.md` for an overview.

### Documentation Workflow

When making changes to the codebase:

1. First examine `/docs/index.md` to understand the documentation structure
2. Navigate to the appropriate subdirectory based on the nature of your changes:
   - `/docs/architecture/` for architectural changes or patterns
   - `/docs/implementation/` for implementation details and technical references
3. Update existing documentation files or create new ones as needed
4. Update index files to reference any new documentation

### Documentation Requirements

- Create/update documentation when modifying .js/.svelte files
- Document component descriptions, usage instructions, and relationships
- Maintain documentation consistency for directory structure
- Consider component interdependencies when making changes
- Follow best practices for Svelte documentation

## Code Style Guidelines

- **AI-Readability**: Add clear comments to make code easily understood by future AI systems
- **Comments**: Include purpose explanations, input/output expectations, and logic clarifications
- **Imports**: Group imports by source (svelte, lib, components)
- **Components**: Use Svelte components with script/markup/style structure
- **Stores**: Use reactive declarations with $ prefix for store values
- **Error Handling**: Use try/catch with specific error messages
- **API Endpoints**: Return standardized JSON responses with proper status codes
- **Database**: Use parameterized queries to prevent SQL injection
- **Naming**: Use descriptive camelCase for variables/functions, PascalCase for components
</file>

<file path="src/app.html">
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width" />
		<script>
			// Prevent theme flash on load by applying the stored or system theme ASAP
			try {
				const theme = localStorage.getItem('theme') || 'system';
				if (theme === 'system') {
					const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
					document.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
				} else {
					document.documentElement.setAttribute('data-theme', theme);
				}
			} catch (e) {
				// no-op
			}
		</script>
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
		<noscript>
			<div style="background: #f8d7da; color: #721c24; padding: 1rem; text-align: center">
				This application requires JavaScript to function properly.
			</div>
		</noscript>
	</body>
</html>
</file>

<file path="CLAUDE.md">
# QDrill Project Guide

## Project Overview

QDrill is a web-based application designed as a sports drill bank and practice planning tool for a niche sport. It allows users to create, manage, and share drills, as well as plan practices with timeline-based organization.

## Technology Stack

- **Frontend**: SvelteKit
- **Backend**: SvelteKit (API routes)
- **Database**: PostgreSQL (via Vercel Postgres)
- **Styling**: Tailwind CSS
- **Authentication**: Auth.js (Google OAuth)
- **Deployment**: Vercel
- **Diagramming**: Excalidraw
- **Testing**: Playwright, Cypress

## Core Features

### Drill Management

- Create, edit, view, and search drills
- Tag drills with skill level, positions, duration
- Upload diagrams/images for drills
- Upvote/downvote and comment on drills
- Create variations of existing drills

### Practice Plan Creation

- Wizard-based practice plan creation
- Section organization with parallel timelines
- Drag-and-drop editing interface
- Duration tracking and management
- Timeline visualization
- Share and duplicate practice plans

### User System

- Google OAuth authentication
- User profiles
- Permission-based access control
- Personal drill/plan management

## Development Commands

- `vercel dev --listen 3000 > /tmp/vercel-dev.log 2>&1 & echo $!` - Start development server with logging (always use this)
- Check logs: `tail -f /tmp/vercel-dev.log` or `cat /tmp/vercel-dev.log`
- `pnpm run check` - Check TypeScript + SvelteKit sync

## Package Management

- `pnpm install` - Install dependencies
- `pnpm add <package>` - Add a package

## Testing

- `pnpm run test` - Run Playwright tests
- `pnpm test -- tests/test.js` - Run a specific test
- `pnpm run test:unit` - Run Vitest unit tests in watch mode
- `pnpm run test:unit:run` - Run Vitest unit tests once
- `pnpm run test:unit:coverage` - Run Vitest unit tests with coverage
- `pnpm run test:unit --run <file-path>` - Run specific Vitest tests once (e.g., `pnpm run test:unit --run src/lib/stores/__tests__/dragManager.test.js`)

## Code Quality

- `pnpm run lint` - Run linting checks
- `pnpm run format` - Fix formatting issues

## Deployment

- Automatic deployment from GitHub main branch to Vercel

## Architecture

### Frontend Components

- Svelte components organized by feature area
- Modular design with reusable components
- Tailwind CSS for styling with custom components
- Interactive drag-and-drop interface for practice planning

### State Management

- Extensive use of Svelte stores
- Separate stores for different domain concerns
- Custom store implementation with methods
- History tracking with undo/redo support

### API Design

- RESTful API endpoints
- SvelteKit server endpoints (+server.js)
- Standardized response formats
- Parameterized database queries

### Database

- PostgreSQL with connection pooling
- Transaction support for complex operations
- Normalized schema design

#### Database Connection

- **Connection String**: Stored in ~/.zshrc as NEON_DB_URL environment variable
- **Connection Command**: `psql "$NEON_DB_URL"`
- **Project ID**: morning-mountain-82887088
- **Database Name**: verceldb
- **Tables**: drills, practice_plans, practice_plan_sections, practice_plan_drills, users, comments, votes, etc.
- **Query Example**: `psql "$NEON_DB_URL" -c "SELECT COUNT(*) FROM drills;"`

## Key Systems

### Authentication

- Auth.js (formerly NextAuth) integration
- Google OAuth provider
- Session-based authentication
- Authorization middleware

### Drag and Drop

- Complex drag-and-drop system for practice plan editing
- State management via Svelte stores
- Multiple drop targets and interactions
- Timeline-based organization
- Visual feedback during drag operations

### Data Filtering

- Client-side filtering for drills
- Multi-criteria filtering
- Performance optimization for large datasets

## Code Style Guidelines

- **AI-Readability**: Add clear comments to make code easily understood by future AI systems
- **Comments**: Include purpose explanations, input/output expectations, and logic clarifications
- **Imports**: Group imports by source (svelte, lib, components)
- **Components**: Use Svelte components with script/markup/style structure
- **Stores**: Use reactive declarations with $ prefix for store values
- **Error Handling**: Use try/catch with specific error messages
- **API Endpoints**: Return standardized JSON responses with proper status codes
- **Database**: Use parameterized queries to prevent SQL injection
- **Naming**: Use descriptive camelCase for variables/functions, PascalCase for components

## Areas for Improvement

### 1. Drag and Drop System Consolidation

**Impact: High**

- Currently has two parallel drag-and-drop systems
- Consolidate into a single system with consistent interface
- Implement proper state machine for drag operations
- Reduce code complexity and maintenance burden

### 2. API Data Fetching Abstraction

**Impact: High**

- Direct fetch calls scattered throughout components
- Create unified API client with standard methods
- Implement consistent error handling and retry logic
- Add caching and performance optimizations

### 3. Test Coverage Expansion

**Impact: High**

- Minimal testing despite complex UI interactions
- Add unit tests for store logic (especially drag-and-drop)
- Implement integration tests for key user flows
- Set up CI pipeline with automated testing

### 4. Store Logic Separation

**Impact: Medium**

- Store files mix different concerns (data, filtering, etc.)
- Separate into dedicated modules with single responsibilities
- Move complex logic into utility functions
- Improve maintainability and testability

### 5. Performance Optimization

**Impact: Medium**

- Filtering/sorting recalculates on every store update
- Implement memoization for expensive calculations
- Use web workers for heavy operations
- Optimize filter chains and add virtualization

## Documentation Workflow

- After completing any significant task, ALWAYS follow this documentation workflow:

1. First examine `/docs/index.md` to understand the documentation structure
2. Then navigate to the appropriate subdirectory based on the nature of your changes:
   - `/docs/architecture/` for architectural changes or patterns
   - `/docs/implementation/` for implementation details and technical references
3. Update existing documentation files or create new ones as needed
4. Update index files to reference any new documentation

## Documentation Requirements

- Create/update documentation when modifying .js/.svelte files
- Document component descriptions, usage instructions, and relationships
- Maintain documentation consistency for directory structure
- Consider component interdependencies when making changes
- Follow best practices for Svelte documentation
- Add implementation notes to `/docs/implementation/` for technical patterns
- **README Updates**: Always update the README.md file after completing substantial code edits to reflect the latest changes, features, and usage instructions

## Version Control Guidelines

- **Commit Message Standards**: Write clear, descriptive commit messages explaining what changes were made and why
- **Atomic Commits**: Keep commits focused on a single logical change
- **Pull Request Format**: Include clear descriptions of changes, impact, and testing performed
- **Code Reviews**: Request code reviews for substantial changes
- **No Automatic Commits**: Never commit changes without explicitly being asked to do so
- **Testing Before Commit**: Always run relevant tests before creating a commit
</file>

<file path="svelte.config.js">
import adapter from '@sveltejs/adapter-vercel';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	kit: {
		adapter: adapter({
			runtime: 'nodejs20.x'
		}),
		prerender: {
			entries: [],
			handleHttpError: 'warn'
		},
		csrf: {
			checkOrigin: process.env.NODE_ENV !== 'development'
		}
	},
	preprocess: vitePreprocess()
};

export default config;
</file>

<file path="src/routes/+layout.svelte">
<script>
	import { browser } from '$app/environment';
	import { page } from '$app/stores';
	import { navigating } from '$app/stores';
	import { onDestroy } from 'svelte';
    import '../app.css';
    import AppShell from '$lib/components/AppShell.svelte';
	import { SvelteToast, toast } from '@zerodevx/svelte-toast';
	import FeedbackButton from '$lib/components/FeedbackButton.svelte';
	import Spinner from '$lib/components/Spinner.svelte';
	import { apiFetch } from '$lib/utils/apiFetch.js';
	import ErrorBoundary from '$lib/components/ErrorBoundary.svelte';
	import { inject } from '@vercel/analytics';
	import { injectSpeedInsights } from '@vercel/speed-insights/sveltekit';
	import { dev } from '$app/environment';
    import { onMount } from 'svelte';
	import { useSession } from '$lib/auth-client';
    import { theme } from '$lib/stores/themeStore';

	inject({ mode: dev ? 'development' : 'production' });
	injectSpeedInsights();

	// Get session using Better Auth
const session = useSession();

let isNavigating = false;
const unsubNavigating = navigating.subscribe((v) => (isNavigating = !!v));
onDestroy(unsubNavigating);

	/** @type {import('./$types').LayoutData} */
	export let data;

	// Function to check and associate entities from sessionStorage
	async function checkAndAssociateEntities(sessionData) {
		if (!browser || !sessionData) return;

		const itemsToAssociate = [
			{ key: 'formationToAssociate', endpoint: '/api/formations' },
			{ key: 'drillToAssociate', endpoint: '/api/drills' },
			{ key: 'practicePlanToAssociate', endpoint: '/api/practice-plans' }
		];

		for (const item of itemsToAssociate) {
			const entityId = sessionStorage.getItem(item.key);
			if (entityId) {
                                try {
                                        console.log(`Found ${item.key} with ID ${entityId}, attempting to associate...`);
                                        await apiFetch(`${item.endpoint}/${entityId}/associate`, { method: 'POST' });
                                        console.log(`${item.key} ${entityId} associated successfully.`);
                                        // Optional: Show success toast
                                        // toast.push(`Successfully claimed your ${item.key.replace('ToAssociate', '')}.`);
                                } catch (error) {
                                        console.error(`Error during association call for ${item.key} ${entityId}:`, error);
                                        // Optional: Show error toast
                                        // toast.push('An error occurred while claiming your item.', { theme: { '--toastBackground': '#F56565', '--toastColor': 'white' } });
                                } finally {
                                        // Remove the item from sessionStorage regardless of success/failure
                                        sessionStorage.removeItem(item.key);
                                        console.log(`Removed ${item.key} from sessionStorage.`);
                                }
			}
		}
	}

    // Initialize theme and check for any pending entity associations
    onMount(() => {
        theme.init();
        if ($session.data) {
            checkAndAssociateEntities($session.data);
        }
    });

	// Check whenever the session data changes (e.g., after login)
	$: {
		if (browser && $session.data) {
			// Use timeout to ensure session is fully established after redirect
			setTimeout(() => checkAndAssociateEntities($session.data), 100);
		}
	}
</script>

<div class="flex flex-col min-h-screen">
  <a href="#main-content" class="skip-to-content">Skip to main content</a>

  {#if isNavigating}
    <div class="fixed top-0 left-0 right-0 z-50 h-1 bg-gradient-to-r from-blue-500 via-blue-600 to-blue-500 animate-pulse">
      <div class="h-full bg-blue-400 animate-pulse opacity-75"></div>
    </div>
  {/if}

  <AppShell>
    <ErrorBoundary>
      <slot />
    </ErrorBoundary>
  </AppShell>

  <FeedbackButton />
  <SvelteToast />

  {#if $page.url.pathname === '/'}
    <footer class="py-4 bg-gray-100">
      <div class="container mx-auto text-center">
        <a href="/privacy-policy" class="text-blue-500 hover:text-blue-700 mr-4">Privacy Policy</a>
        <a href="/terms-of-service" class="text-blue-500 hover:text-blue-700">Terms of Service</a>
      </div>
    </footer>
  {/if}
</div>

<style>
	.flex {
		display: flex;
	}
	.flex-col {
		flex-direction: column;
	}
	.min-h-screen {
		min-height: 100vh;
	}
	.flex-1 {
		flex: 1;
	}
    main { display: contents; }
</style>
</file>

<file path="src/lib/server/services/baseEntityService.js">
import * as db from '$lib/server/db.js';
import {
	NotFoundError,
	ValidationError,
	DatabaseError,
	InternalServerError,
	ForbiddenError
} from '$lib/server/errors.js';
import { sql } from 'kysely'; // Ensure sql is imported from Kysely

/**
 * Base service class for entity operations
 * Provides common CRUD functionality that can be extended by specific entity services
 */
export class BaseEntityService {
	/**
	 * @param {string} tableName - Database table name for this entity
	 * @param {string} primaryKey - Primary key column name (default: 'id')
	 * @param {Array<string>} defaultColumns - Columns to return by default (default: ['*'])
	 * @param {Array<string>} allowedColumns - Columns that can be used for filtering and sorting
	 * @param {Object} columnTypes - Map of column names to their types (e.g., { tags: 'array' })
	 * @param {Object} [permissionConfig=null] - Configuration for standard permissions
	 * @param {string} [permissionConfig.userIdColumn='created_by'] - Column for user ID
	 * @param {string} [permissionConfig.visibilityColumn='visibility'] - Column for visibility status
	 * @param {any} [permissionConfig.publicValue='public'] - Value for public visibility
	 * @param {any} [permissionConfig.unlistedValue='unlisted'] - Value for unlisted visibility
	 * @param {any} [permissionConfig.privateValue='private'] - Value for private visibility
	 */
	constructor(
		tableName,
		primaryKey = 'id',
		defaultColumns = ['*'],
		allowedColumns = [],
		columnTypes = {},
		permissionConfig = null
	) {
		this.tableName = tableName;
		this.primaryKey = primaryKey;
		this.defaultColumns = defaultColumns;
		this.allowedColumns = [...allowedColumns, primaryKey];
		this.columnTypes = columnTypes;

		// Track if this entity uses common permissions model
		this.permissionConfig = permissionConfig;
		this.useStandardPermissions = !!permissionConfig;

		// Default permission settings if enabled but not fully configured
		if (this.useStandardPermissions) {
			this.permissionConfig = {
				userIdColumn: permissionConfig?.userIdColumn || 'created_by',
				visibilityColumn: permissionConfig?.visibilityColumn || 'visibility',
				publicValue: permissionConfig?.publicValue ?? 'public', // Use ?? to allow null/false
				unlistedValue: permissionConfig?.unlistedValue ?? 'unlisted',
				privateValue: permissionConfig?.privateValue ?? 'private',
				editableByOthersColumn: permissionConfig?.editableByOthersColumn || 'is_editable_by_others' // Added for canUserEdit
			};
		}
	}

	/**
	 * Enable standard permissions model
	 * This assumes the entity has created_by and is_editable_by_others columns
	 * DEPRECATED: Pass permissionConfig to constructor instead.
	 */
	enableStandardPermissions() {
		this.useStandardPermissions = true;
		// Apply default config if enabled this way (for backward compatibility, though discouraged)
		if (!this.permissionConfig) {
			this.permissionConfig = {
				userIdColumn: 'created_by',
				visibilityColumn: 'visibility',
				publicValue: 'public',
				unlistedValue: 'unlisted',
				privateValue: 'private',
				editableByOthersColumn: 'is_editable_by_others'
			};
		}
		console.warn(
			'enableStandardPermissions() is deprecated. Pass permission configuration to the BaseEntityService constructor instead.'
		);
	}

	/**
	 * Validates if a column name is allowed for filtering and sorting
	 * @param {string} columnName - Column name to validate
	 * @returns {boolean} - True if column is allowed
	 */
	isColumnAllowed(columnName) {
		// If no allowed columns are specified, only allow the primary key
		if (this.allowedColumns.length === 0) {
			return columnName === this.primaryKey;
		}
		return this.allowedColumns.includes(columnName);
	}

	/**
	 * Validates and sanitizes sort order
	 * @param {string} sortOrder - Sort order to validate
	 * @returns {string} - Sanitized sort order
	 */
	validateSortOrder(sortOrder) {
		const order = sortOrder.toLowerCase();
		return order === 'asc' ? 'ASC' : 'DESC';
	}

	/**
	 * Builds the WHERE clause and parameters for a query based on filters and permissions.
	 * @param {Object} filters - Filter conditions (e.g., { name__like: '%test%', age__gt: 18 })
	 * @param {number|null} [userId=null] - ID of the user making the request (for permission checks)
	 * @param {number} [initialParamCount=0] - Starting index for query parameters.
	 * @returns {{ whereClause: string, queryParams: Array<any>, paramCount: number }}
	 */
	_buildWhereClause(filters = {}, userId = null, initialParamCount = 0) {
		const conditions = [];
		const queryParams = [];
		let paramCount = initialParamCount;

		// Define supported operators and their SQL generation logic
		const operators = {
			exact: (col, val) => ({ clause: `${col} = $${paramCount + 1}`, params: [val] }),
			eq: (col, val) => ({ clause: `${col} = $${paramCount + 1}`, params: [val] }),
			neq: (col, val) => ({ clause: `${col} != $${paramCount + 1}`, params: [val] }),
			gt: (col, val) => ({ clause: `${col} > $${paramCount + 1}`, params: [val] }),
			gte: (col, val) => ({ clause: `${col} >= $${paramCount + 1}`, params: [val] }),
			lt: (col, val) => ({ clause: `${col} < $${paramCount + 1}`, params: [val] }),
			lte: (col, val) => ({ clause: `${col} <= $${paramCount + 1}`, params: [val] }),
			like: (col, val) => ({ clause: `${col} LIKE $${paramCount + 1}`, params: [val] }),
			ilike: (col, val) => ({ clause: `${col} ILIKE $${paramCount + 1}`, params: [val] }),
			isnull: (col, val) => ({ clause: `${col} IS ${val ? 'NULL' : 'NOT NULL'}`, params: [] }), // Value is boolean true/false
			in: (col, val) => {
				// Expects value to be an array
				if (!Array.isArray(val) || val.length === 0) return null; // Or throw error?
				const placeholders = val.map((_, i) => `$${paramCount + 1 + i}`).join(', ');
				return { clause: `${col} IN (${placeholders})`, params: val };
			},
			any: (col, val) => {
				// Specific to PostgreSQL ANY operator for array membership
				if (!Array.isArray(val) && this.columnTypes[col] === 'array') {
					// If filter value is single for an array col, check membership
					return { clause: `$${paramCount + 1} = ANY(${col})`, params: [val] };
				} else if (Array.isArray(val) && this.columnTypes[col] === 'array') {
					// If filter value is array for array col, check overlap (&&)
					return { clause: `${col} && $${paramCount + 1}`, params: [val] };
				}
				// Fallback or error for non-array columns/values?
				console.warn(`Unsupported 'any' filter for column '${col}' with value:`, val);
				return null;
			}
			// TODO: Add support for other operators like 'between', 'not in', etc.
		};

		// Process filters
		Object.entries(filters).forEach(([key, value]) => {
			// Skip undefined values (allow null for isnull)
			if (value === undefined) {
				return;
			}

			let columnName = key;
			let operator = 'exact'; // Default operator

			// Check for operator suffix (e.g., "name__like")
			const parts = key.split('__');
			if (parts.length === 2 && operators[parts[1]]) {
				columnName = parts[0];
				operator = parts[1];
			}

			// Validate column
			if (!this.isColumnAllowed(columnName)) {
				console.warn(`Filter key '${key}' uses disallowed column '${columnName}'. Skipping.`);
				return;
			}

			// Skip null values unless using isnull operator
			if (value === null && operator !== 'isnull') {
				return;
			}

			// Get the clause and params from the operator function
			const opFunc = operators[operator];
			const result = opFunc(columnName, value);

			if (result && result.clause) {
				conditions.push(result.clause);
				queryParams.push(...result.params);
				paramCount += result.params.length; // Increment count by number of params added
			}
		});

		// Add standard permission filtering if enabled
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			const visibilityConditions = [];

			// Always allow public (if defined)
			if (publicValue !== undefined && publicValue !== null) {
				visibilityConditions.push(`${visibilityColumn} = $${paramCount + 1}`);
				queryParams.push(publicValue);
				paramCount++;
			} else {
				// If public not defined, maybe allow NULL? Or require explicit public value?
				// For now, let's assume NULL is implicitly public if publicValue isn't set.
				visibilityConditions.push(`${visibilityColumn} IS NULL`);
			}

			// Always allow unlisted (if defined)
			if (unlistedValue !== undefined && unlistedValue !== null) {
				visibilityConditions.push(`${visibilityColumn} = $${paramCount + 1}`);
				queryParams.push(unlistedValue);
				paramCount++;
			}

			// Allow private if userId matches and privateValue is defined
			if (userId !== null && privateValue !== undefined && privateValue !== null) {
				visibilityConditions.push(
					`(${visibilityColumn} = $${paramCount + 1} AND ${userIdColumn} = $${paramCount + 2})`
				);
				queryParams.push(privateValue, userId);
				paramCount += 2;
			}

			if (visibilityConditions.length > 0) {
				conditions.push(`(${visibilityConditions.join(' OR ')})`);
			} else if (userId === null && privateValue !== undefined) {
				// If user is not logged in and private items exist, explicitly exclude them
				conditions.push(`${visibilityColumn} != $${paramCount + 1}`);
				queryParams.push(privateValue);
				paramCount++;
			}
		}

		const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
		return { whereClause, queryParams, paramCount };
	}

	/**
	 * Get all entities with optional filtering and pagination
	 * @param {Object} options - Query options
	 * @param {number} options.page - Page number starting from 1 (default: 1)
	 * @param {number} options.limit - Items per page (default: 10)
	 * @param {boolean} options.all - Whether to return all records (default: false)
	 * @param {Object} options.filters - Filter conditions
	 * @param {string} options.sortBy - Column to sort by
	 * @param {string} options.sortOrder - Sort order ('asc' or 'desc', default: 'desc')
	 * @param {Array<string>} options.columns - Columns to return (default: this.defaultColumns)
	 * @param {number|null} options.userId - User ID for permission checking (if applicable)
	 * @returns {Promise<Object>} - Results with pagination info
	 */
	async getAll(options = {}) {
		const {
			page = 1,
			limit = 10,
			all = false,
			filters = {},
			sortBy = null,
			sortOrder = 'desc',
			columns = this.defaultColumns,
			userId = null // For permission filtering
		} = options;

		// Calculate offset for pagination
		const offset = (page - 1) * limit;

		const { whereClause, queryParams, paramCount } = this._buildWhereClause(filters, userId, 0);

		// Build ORDER BY clause with validation
		let orderBy;
		if (sortBy && this.isColumnAllowed(sortBy)) {
			const sanitizedSortOrder = this.validateSortOrder(sortOrder);
			if (this.primaryKey) {
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}, ${this.primaryKey} ${sanitizedSortOrder}`;
			} else {
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}`;
			}
		} else if (this.primaryKey) {
			orderBy = `ORDER BY ${this.primaryKey} DESC`;
		} else {
			orderBy = ''; // No ordering if no primary key
		}

		// Validate columns to return
		const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

		// If no valid columns, default to primary key (if it exists) or all allowed columns
		if (validColumns.length === 0) {
			if (this.primaryKey) {
				validColumns.push(this.primaryKey);
			} else {
				validColumns.push('*');
			}
		}

		try {
			return this.withTransaction(async (client) => {
				let results;
				let pagination = {};

				if (!all) {
					// Get total count for pagination
					const countQuery = `
            SELECT COUNT(*)
            FROM ${this.tableName}
            ${whereClause}
          `;

					const countResult = await client.query(countQuery, queryParams);
					const totalItems = parseInt(countResult.rows[0].count);

					pagination = {
						page: parseInt(page),
						limit: parseInt(limit),
						totalItems,
						totalPages: Math.ceil(totalItems / limit)
					};

					// Main query with pagination
					const query = `
            SELECT ${validColumns.join(', ')}
            FROM ${this.tableName}
            ${whereClause}
            ${orderBy}
            LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
          `;

					// Add pagination parameters
					const allParams = [...queryParams, limit, offset];
					const result = await client.query(query, allParams);
					results = result.rows;
				} else {
					// Query without pagination
					const query = `
            SELECT ${validColumns.join(', ')}
            FROM ${this.tableName}
            ${whereClause}
            ${orderBy}
          `;

					const result = await client.query(query, queryParams);
					results = result.rows;
				}

				return {
					items: results,
					pagination: all ? null : pagination
				};
			});
		} catch (error) {
			console.error(`Error in ${this.tableName}.getAll():`, error);
			throw new DatabaseError(`Failed to retrieve ${this.tableName}`, error);
		}
	}

	/**
	 * Get a single entity by ID
	 * @param {number|string} id - Entity ID
	 * @param {Array<string>} columns - Columns to return (default: this.defaultColumns)
	 * @param {number|null} [userId=null] - User ID for permission checking (if applicable)
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Entity object
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 */
	async getById(id, columns = this.defaultColumns, userId = null, client = null) {
		try {
			// Validate columns to return
			const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

			// If no valid columns, default to primary key
			if (validColumns.length === 0) {
				validColumns.push(this.primaryKey);
			}

			// Use the provided client or the default db connection
			const dbInterface = client || db;

			const query = `
        SELECT ${validColumns.join(', ')}
        FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
      `;

			const result = await dbInterface.query(query, [id]);

			// Throw NotFoundError if no rows are returned
			if (result.rows.length === 0) {
				throw new NotFoundError(`${this.tableName.slice(0, -1)} with ID ${id} not found`);
			}

			const entity = result.rows[0];

			// Check view permission if standard permissions are enabled
			if (this.useStandardPermissions && !this.canUserView(entity, userId)) {
				throw new ForbiddenError(
					`User not authorized to view ${this.tableName.slice(0, -1)} with ID ${id}`
				);
			}

			return result.rows[0];
		} catch (error) {
			// Re-throw NotFoundError directly
			if (error instanceof NotFoundError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.getById(${id}):`, error);
			// Wrap other errors as DatabaseError
			throw new DatabaseError(
				`Failed to retrieve ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Create a new entity
	 * @param {Object} data - Entity data
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Created entity
	 */
	async create(data, client = null) {
		const dbInterface = client || db;
		try {
			// Create a copy of the data
			const dataCopy = { ...data };

			// Remove id field if it exists - let the database generate it
			if (this.primaryKey in dataCopy) {
				delete dataCopy[this.primaryKey];
			}

			// Filter out undefined values and validate columns
			const columns = Object.keys(dataCopy).filter(
				(key) => dataCopy[key] !== undefined && this.isColumnAllowed(key)
			);
			const values = columns.map((column) => dataCopy[column]);

			// No columns to insert
			if (columns.length === 0) {
				throw new ValidationError('No valid data provided for insertion');
			}

			const placeholders = columns.map((_, index) => `$${index + 1}`).join(', ');

			const query = `
        INSERT INTO ${this.tableName} (${columns.join(', ')})
        VALUES (${placeholders})
        RETURNING *
      `;

			const result = await dbInterface.query(query, values);

			return result.rows[0];
		} catch (error) {
			console.error(`Error in ${this.tableName}.create():`, error);
			throw new DatabaseError(`Failed to create ${this.tableName.slice(0, -1)}`, error);
		}
	}

	/**
	 * Update an entity
	 * @param {number|string} id - Entity ID
	 * @param {Object} data - Updated entity data
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Updated entity
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 * @throws {ValidationError} If no valid data provided
	 */
	async update(id, data, client = null) {
		const dbInterface = client || db;
		try {
			// Filter out undefined values and validate columns
			const columns = Object.keys(data).filter(
				(key) => data[key] !== undefined && key !== this.primaryKey && this.isColumnAllowed(key)
			);

			if (columns.length === 0) {
				throw new ValidationError('No valid data provided for update');
			}

			const values = columns.map((column) => data[column]);

			const setClause = columns.map((column, index) => `${column} = $${index + 2}`).join(', ');

			const query = `
        UPDATE ${this.tableName}
        SET ${setClause}
        WHERE ${this.primaryKey} = $1
        RETURNING *
      `;

			const result = await dbInterface.query(query, [id, ...values]);

			// Throw NotFoundError if no rows were affected (entity didn't exist)
			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${id} not found for update`
				);
			}

			return result.rows[0];
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof ValidationError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.update(${id}):`, error);
			throw new DatabaseError(
				`Failed to update ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Delete an entity by ID
	 * @param {number|string} id - Entity ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>} - Resolves if successful
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 */
	async delete(id, client = null) {
		const dbInterface = client || db;
		try {
			// Ensure the primary key is allowed (it should be by default)
			if (!this.isColumnAllowed(this.primaryKey)) {
				throw new InternalServerError(
					`Primary key ${this.primaryKey} is not in the allowed columns list for ${this.tableName}`
				);
			}

			const query = `
        DELETE FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
        RETURNING ${this.primaryKey}
      `;

			const result = await dbInterface.query(query, [id]);

			// Throw NotFoundError if no rows were deleted (entity didn't exist)
			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${id} not found for deletion`
				);
			}
			return true; // Explicitly return true on success
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof InternalServerError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.delete(${id}):`, error);
			throw new DatabaseError(
				`Failed to delete ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Check if an entity with given ID exists
	 * @param {number|string} id - Entity ID
	 * @returns {Promise<boolean>} - True if exists
	 */
	async exists(id) {
		try {
			// Ensure the primary key is allowed (it should be by default)
			if (!this.isColumnAllowed(this.primaryKey)) {
				throw new Error(`Primary key ${this.primaryKey} is not in the allowed columns list`);
			}

			const query = `
        SELECT 1 
        FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
        LIMIT 1
      `;

			const result = await db.query(query, [id]);

			return result.rows.length > 0;
		} catch (error) {
			console.error(`Error in ${this.tableName}.exists(${id}):`, error);
			return false;
		}
	}

	/**
	 * Search entities by text columns
	 * @param {string} searchTerm - Search term
	 * @param {Array<string>} searchColumns - Columns to search in (DEPRECATED: use searchVectorColumn)
	 * @param {string} [searchVectorColumn='search_vector'] - The tsvector column to search against.
	 * @param {string} [searchConfig='english'] - The text search configuration.
	 * @param {Object} options - Additional options (page, limit, etc.)
	 * @param {number|null} [options.userId=null] - User ID for permission checking.
	 * @returns {Promise<Object>} - Search results with pagination
	 */
	async search(
		searchTerm,
		searchColumns,
		options = {},
		searchVectorColumn = 'search_vector',
		searchConfig = 'english'
	) {
		try {
			const {
				page = 1,
				limit = 10,
				sortBy = null,
				sortOrder = 'desc',
				columns = this.defaultColumns,
				userId = null // For permission checking
			} = options;

			// --- BEGIN DEPRECATION WARNING for searchColumns ---
			if (searchColumns && Array.isArray(searchColumns) && searchColumns.length > 0) {
				console.warn(`The 'searchColumns' parameter in BaseEntityService.search() is DEPRECATED and will be removed. 
          Configure a tsvector column ('${searchVectorColumn}') in your database and service instead.`);
				// Optional: Fallback to old LIKE search if searchVectorColumn check fails?
				// For now, we proceed assuming tsvector is preferred.
			}
			// --- END DEPRECATION WARNING ---

			// Validate tsvector column existence (basic check - assumes it exists in DB)
			// A more robust check might involve querying information_schema, but adds overhead.
			// We also need to ensure it's allowed if specific columns are enforced.
			// if (!this.isColumnAllowed(searchVectorColumn)) { // Optional: uncomment if searchVectorColumn must be in allowedColumns
			//   throw new ValidationError(`Search vector column '${searchVectorColumn}' is not allowed.`);
			// }

			// Validate columns to return
			const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

			// If no valid columns, default to primary key
			if (validColumns.length === 0) {
				validColumns.push(this.primaryKey);
			}

			const offset = (page - 1) * limit;
			// Prepare the search term for tsquery (plainto_tsquery handles basic parsing and stemming)
			const tsQueryParam = searchTerm;

			// Build search conditions
			// Use tsquery for full-text search
			const searchCondition = `${searchVectorColumn} @@ plainto_tsquery($1, $2)`;
			const initialParams = [searchConfig, tsQueryParam];
			let currentParamCount = initialParams.length;

			// Combine with permission and other filters using _buildWhereClause
			// Pass the search condition as a raw filter (needs careful handling)
			// TODO: How to best integrate raw SQL conditions with _buildWhereClause?
			// Option 1: Add a special filter key like '__raw'.
			// Option 2: Modify _buildWhereClause to accept initial conditions.
			// Option 3: Build search and filter WHERE clauses separately and combine.
			// Let's try Option 3 for now.

			const {
				whereClause: filterWhereClause,
				queryParams: filterQueryParams,
				paramCount: filterParamCount
			} = this._buildWhereClause(options.filters || {}, userId, currentParamCount);

			// Combine conditions
			const combinedConditions = [searchCondition];
			if (filterWhereClause) {
				// Extract conditions from filterWhereClause (remove 'WHERE ')
				combinedConditions.push(filterWhereClause.substring(6));
			}
			const finalWhereClause = `WHERE ${combinedConditions.join(' AND ')}`;
			const finalQueryParams = [...initialParams, ...filterQueryParams];
			currentParamCount = filterParamCount; // Update param count

			// Count total matches
			const countQuery = `
        SELECT COUNT(*)
        FROM ${this.tableName}
        ${finalWhereClause}
      `;

			const countResult = await db.query(countQuery, finalQueryParams);
			const totalItems = parseInt(countResult.rows[0].count);

			// Build ORDER BY clause with validation
			let orderBy;
			if (sortBy && this.isColumnAllowed(sortBy)) {
				const sanitizedSortOrder = this.validateSortOrder(sortOrder);
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}, ${this.primaryKey} ${sanitizedSortOrder}`;
			} else {
				// Default sort by relevance when searching
				orderBy = `ORDER BY ts_rank_cd(${searchVectorColumn}, plainto_tsquery($1, $2)) DESC, ${this.primaryKey} DESC`;
			}

			// Main search query
			const query = `
        SELECT ${validColumns.join(', ')}
        FROM ${this.tableName}
        ${finalWhereClause}
        ${orderBy}
        LIMIT $${currentParamCount + 1} OFFSET $${currentParamCount + 2}
      `;

			const result = await db.query(query, [...finalQueryParams, limit, offset]);

			return {
				items: result.rows,
				pagination: {
					page: parseInt(page),
					limit: parseInt(limit),
					totalItems,
					totalPages: Math.ceil(totalItems / limit)
				}
			};
		} catch (error) {
			// Re-throw known errors
			if (error instanceof ValidationError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.search():`, error);
			throw new DatabaseError(`Failed to search ${this.tableName}`, error);
		}
	}

	/**
	 * Execute a function within a database transaction
	 * @param {Function} callback - Async function to execute within transaction
	 * @returns {Promise<any>} - Result of the callback function
	 */
	async withTransaction(callback) {
		const client = await db.getClient();
		try {
			await client.query('BEGIN');
			const result = await callback(client);
			await client.query('COMMIT');
			return result;
		} catch (error) {
			await client.query('ROLLBACK');
			console.error(`Transaction error in ${this.tableName}:`, error);
			throw error;
		} finally {
			client.release();
		}
	}

	/**
	 * Check if a user can edit an entity
	 * Requires that the entity has created_by and is_editable_by_others columns
	 * @param {number|string} entityId - Entity ID
	 * @param {number|null} userId - User ID attempting edit
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<boolean>} - True if user can edit
	 * @throws {ForbiddenError} If user is not authorized
	 */
	async canUserEdit(entityId, userId, client = null) {
		// Use the provided client or the default db connection
		const dbInterface = client || db;

		// Check if user is admin
		if (userId) {
			const userResult = await dbInterface.query('SELECT role FROM users WHERE id = $1', [userId]);
			if (userResult.rows.length > 0 && userResult.rows[0].role === 'admin') {
				return true; // Admins can edit anything
			}
		}

		if (!this.useStandardPermissions) {
			// If permissions aren't configured, default to allowing (or throw error?)
			// console.warn(`Standard permissions not enabled for ${this.tableName} service - allowing edit by default`);
			return true;
		}

		if (!this.permissionConfig) {
			console.error(
				`Cannot check edit permission: Permission config missing for ${this.tableName}`
			);
			throw new InternalServerError(`Permission configuration error for ${this.tableName}`);
		}

		const { userIdColumn, editableByOthersColumn } = this.permissionConfig;

		try {
			// Fetch only necessary columns for permission check
			const query = `SELECT ${userIdColumn}, ${editableByOthersColumn} FROM ${this.tableName} WHERE ${this.primaryKey} = $1`;
			const result = await dbInterface.query(query, [entityId]);

			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${entityId} not found for permission check`
				);
			}
			const entity = result.rows[0];

			// Can edit if:
			// 1. User created the entity (and userId is not null)
			// 2. Entity is editable by others
			// 3. Entity has no creator (creator column is null)
			// 4. User is admin (already checked above)
			const isCreator = userId !== null && entity[userIdColumn] === userId;
			const isEditable = entity[editableByOthersColumn] === true;
			const isUnowned = entity[userIdColumn] === null;

			if (!(isCreator || isEditable || isUnowned)) {
				throw new ForbiddenError(
					`User ${userId} is not authorized to edit ${this.tableName.slice(0, -1)} ${entityId}`
				);
			}

			return true; // Return true if no ForbiddenError was thrown
		} catch (error) {
			if (
				error instanceof NotFoundError ||
				error instanceof ForbiddenError ||
				error instanceof InternalServerError
			) {
				throw error; // Re-throw specific errors
			}
			console.error(`Error checking edit permission for ${this.tableName} ${entityId}:`, error);
			throw new DatabaseError(
				`Failed to check edit permission for ${this.tableName.slice(0, -1)}`,
				error
			);
		}
	}

	/**
	 * Check if user has permission to view entity
	 * @param {Object} entity - The entity to check
	 * @param {number|null} userId - User ID requesting access
	 * @returns {boolean} - True if user can view
	 */
	canUserView(entity, userId) {
		// If permissions aren't configured, or no entity provided, default to allowing view
		if (!this.useStandardPermissions || !this.permissionConfig || !entity) {
			return true;
		}

		const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
			this.permissionConfig;
		const visibility = entity[visibilityColumn];

		// Public or Unlisted entities can be viewed by anyone (including null/undefined visibility if public/unlisted values are not set)
		const isPublic =
			publicValue !== undefined && publicValue !== null
				? visibility === publicValue
				: visibility === null || visibility === undefined;
		const isUnlisted =
			unlistedValue !== undefined && unlistedValue !== null ? visibility === unlistedValue : false;

		if (isPublic || isUnlisted) {
			return true;
		}

		// Private entities can only be viewed by the creator (if privateValue and userId are valid)
		const isPrivate =
			privateValue !== undefined && privateValue !== null ? visibility === privateValue : false;
		return isPrivate && userId !== null && entity[userIdColumn] === userId;
	}

	/**
	 * Normalize array fields in data
	 * @param {Object} data - Raw data with potential arrays
	 * @param {Array<string>} arrayFields - Fields to ensure are arrays
	 * @returns {Object} - Data with normalized arrays
	 */
	normalizeArrayFields(data, arrayFields) {
		const normalized = { ...data };

		arrayFields.forEach((field) => {
			// Skip if field is not in data
			if (!(field in normalized)) {
				return;
			}

			// Convert string to array if needed
			if (typeof normalized[field] === 'string') {
				normalized[field] = [normalized[field]];
			}

			// Ensure field is an array
			if (!Array.isArray(normalized[field])) {
				normalized[field] = normalized[field] ? [normalized[field]] : [];
			}
		});

		return normalized;
	}

	/**
	 * Add timestamp fields to entity data
	 * @param {Object} data - Entity data
	 * @param {boolean} isNew - Whether this is a new entity
	 * @returns {Object} - Data with timestamps
	 */
	addTimestamps(data, isNew = true) {
		const now = new Date();
		const result = { ...data };

		if (isNew) {
			result.created_at = now;
		}

		result.updated_at = now;
		return result;
	}

	/**
	 * Builds Kysely query conditions for Full-Text Search (FTS) with prefix matching.
	 * It attaches an '_ftsAppliedInfo' object to the queryBuilder if a search term is processed.
	 * This info is used by _executeSearch for potential fallback.
	 *
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} queryBuilder - The Kysely query builder instance.
	 * @param {string | undefined | null} searchQuery - The raw search term.
	 * @param {string} [vectorColumn='search_vector'] - The tsvector column in the table.
	 * @param {string} [textSearchConfig='english'] - The PostgreSQL text search configuration.
	 * @param {string[]} [columnsToRankForFallback=['name', 'description']] - Columns for pg_trgm fallback.
	 * @param {number} [trigramThresholdForFallback=0.3] - Similarity threshold for pg_trgm.
	 * @returns {import('kysely').SelectQueryBuilder<any, any, any>} - The modified query builder.
	 */
	_buildSearchQuery(
		queryBuilder,
		searchQuery,
		vectorColumn = 'search_vector',
		textSearchConfig = 'english',
		columnsToRankForFallback = ['name', 'description'], // Default fallback columns
		trigramThresholdForFallback = 0.3
	) {
		const cleanedSearchTerm = searchQuery?.trim();

		if (!cleanedSearchTerm) {
			return queryBuilder;
		}

		const tsQuerySearchTerm = cleanedSearchTerm
			.split(/\s+/)
			.filter(Boolean)
			.map((term) => term + ':*') // Add prefix matching to each term
			.join(' & '); // Combine with AND operator

		if (tsQuerySearchTerm) {
			const qbWithFTS = queryBuilder.where(
				sql`${sql.ref(vectorColumn)} @@ to_tsquery(${textSearchConfig}, ${tsQuerySearchTerm})`
			);
			// Attach info needed for potential fallback search
			qbWithFTS._ftsAppliedInfo = {
				originalSearchTerm: cleanedSearchTerm,
				tsQueryUsed: tsQuerySearchTerm,
				textSearchConfig,
				columnsToRankForFallback,
				trigramThresholdForFallback,
				vectorColumn
			};
			return qbWithFTS;
		}
		return queryBuilder;
	}

	/**
	 * Executes a search query, attempting FTS first, then falling back to pg_trgm similarity search
	 * if FTS yields no results and was applicable.
	 *
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} ftsQueryBuilder - Query builder with FTS conditions applied by _buildSearchQuery.
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} baseQueryBuilderForFallback - The original query builder *before* any search conditions were applied, to be used for fallback.
	 * @param {object} paginationOptions - Options for limit and offset.
	 * @param {number} paginationOptions.limit - Max items per page.
	 * @param {number} paginationOptions.offset - Offset for pagination.
	 * @returns {Promise<{items: Array<any>, usedFallback: boolean}>} - The search results and a flag indicating if fallback was used.
	 */
	async _executeSearch(ftsQueryBuilder, baseQueryBuilderForFallback, { limit, offset }) {
		const ftsAppliedInfo = ftsQueryBuilder._ftsAppliedInfo;

		let items = await ftsQueryBuilder.limit(limit).offset(offset).execute();
		let usedFallback = false;

		if (items.length === 0 && ftsAppliedInfo) {
			console.log(
				`[BaseEntityService] FTS on ${this.tableName} returned 0 results for '${ftsAppliedInfo.originalSearchTerm}', trying pg_trgm fallback...`
			);
			usedFallback = true;

			const { originalSearchTerm, columnsToRankForFallback, trigramThresholdForFallback } =
				ftsAppliedInfo;

			// Ensure columnsToRankForFallback are valid columns of the current table.
			// This is a basic check; more robust validation might involve checking schema.
			const validFallbackColumns = columnsToRankForFallback.filter((col) =>
				this.isColumnAllowed(col)
			);
			if (validFallbackColumns.length === 0) {
				console.warn(
					`[BaseEntityService] pg_trgm fallback for ${this.tableName} skipped: no valid columns to rank were provided or allowed.`
				);
				return { items, usedFallback: false }; // Return original (empty) items
			}

			let fallbackQuery = baseQueryBuilderForFallback // Start from the base query, *without* FTS conditions
				.where((eb) =>
					eb.or(
						validFallbackColumns.map((col) =>
							eb(
								sql`similarity(${sql.ref(col)}, ${originalSearchTerm})`,
								'>',
								trigramThresholdForFallback
							)
						)
					)
				)
				.select((eb) => [
					// Kysely's dynamic way to add selections
					...(this.defaultColumns.includes('*')
						? []
						: this.defaultColumns.map((col) => sql.ref(col))), // Select default columns
					eb.fn
						.greatest(
							...validFallbackColumns.map(
								(col) => sql`similarity(${sql.ref(col)}, ${originalSearchTerm})`
							)
						)
						.as('similarity_score')
				]);

			// If defaultColumns was ['*'], we need to ensure all table columns are selected
			// Kysely doesn't have a simple way to re-add `select *` after specific selections,
			// so services using this should define their default columns explicitly if not already.
			// For now, assuming defaultColumns are explicit or handled by the initial baseQueryBuilder.
			// If baseQueryBuilderForFallback already has its selects, we just add similarity_score.

			fallbackQuery = fallbackQuery.orderBy('similarity_score', 'desc');
			items = await fallbackQuery.limit(limit).offset(offset).execute();
		}

		// Clean up the temporary property from the FTS query builder if it exists
		if (ftsQueryBuilder && '_ftsAppliedInfo' in ftsQueryBuilder) {
			delete ftsQueryBuilder._ftsAppliedInfo;
		}

		return { items, usedFallback };
	}
}
</file>

<file path="src/routes/api/practice-plans/+server.js">
import { json } from '@sveltejs/kit';
import { practicePlanService } from '$lib/server/services/practicePlanService.js';
import { FILTER_STATES } from '$lib/constants'; // Import FILTER_STATES
import { z } from 'zod'; // Import zod
import { createPracticePlanSchema } from '$lib/validation/practicePlanSchema'; // Import Zod schema
import { AppError, DatabaseError, ValidationError, NotFoundError } from '$lib/server/errors'; // Import error types
import { handleApiError } from '../utils/handleApiError.js';

// Previously contained a local copy of handleApiError and a custom
// PracticePlanError class. All routes now import the shared utility
// from ../utils/handleApiError.js for consistent behavior.

export async function GET({ url, locals }) {
	const userId = locals.user?.id;

	// Extract query parameters
	const page = parseInt(url.searchParams.get('page') || '1', 10);
	const limit = parseInt(url.searchParams.get('limit') || '10', 10);
	const sortBy = url.searchParams.get('sortBy') || 'upvotes';
	const sortOrder = url.searchParams.get('sortOrder') || 'desc';
	const searchQuery = url.searchParams.get('search') || '';

	// Extract filters
	const filters = {
		searchQuery: searchQuery || undefined,
		phase_of_season: extractFilterParam(url.searchParams, 'phase'),
		practice_goals: extractFilterParam(url.searchParams, 'goal'),
		min_participants: parseIntOrNull(url.searchParams.get('minP')),
		max_participants: parseIntOrNull(url.searchParams.get('maxP')),
		drill_ids: url.searchParams
			.getAll('drillId')
			.map((id) => parseInt(id, 10))
			.filter((id) => !isNaN(id))
	};

	// Handle team_id parameter - expect UUID only (internal use)
	const teamIdParam = url.searchParams.get('team_id');
	if (teamIdParam) {
		filters.team_id = teamIdParam;
	}

	// Handle is_template filter
	const isTemplate = url.searchParams.get('is_template');
	if (isTemplate !== null) {
		filters.is_template = isTemplate === 'true';
	}

	// Remove empty drill_ids array
	if (filters.drill_ids.length === 0) {
		delete filters.drill_ids;
	}

	try {
		const result = await practicePlanService.getAll({
			userId,
			page,
			limit,
			sortBy,
			sortOrder,
			filters
		});
		// Return the whole result object including items and pagination
		return json(result);
	} catch (err) {
		// Use the centralized error handler
		return handleApiError(err);
	}
}

/**
 * Helper to parse integer or return null
 * @param {string | null} value
 * @returns {number | null}
 */
function parseIntOrNull(value) {
	if (value === null || value === undefined || value === '') return null;
	const parsed = parseInt(value, 10);
	return isNaN(parsed) ? null : parsed;
}

/**
 * Helper to extract multi-state filter parameters
 * e.g., phase_req=Offseason&phase_exc=Mid season
 * @param {URLSearchParams} searchParams
 * @param {string} baseParamName e.g., 'phase'
 * @returns {{ required: string[], excluded: string[] } | undefined}
 */
function extractFilterParam(searchParams, baseParamName) {
	const required = searchParams.getAll(`${baseParamName}_req`);
	const excluded = searchParams.getAll(`${baseParamName}_exc`);

	if (required.length === 0 && excluded.length === 0) {
		return undefined; // No filter applied for this param
	}

	return {
		required,
		excluded
	};
}

export const POST = async ({ request, locals }) => {
	try {
		const rawData = await request.json();
		const userId = locals.user?.id;

		// --- Hydrate parallel group timeline data ---
		// FIXED: Preserve parallel_timeline values from the request
		if (rawData.sections && Array.isArray(rawData.sections)) {
			rawData.sections.forEach((section) => {
				if (section.items && Array.isArray(section.items)) {
					// Group items by parallel_group_id to collect all timelines
					const parallelGroups = new Map();

					// First pass: collect all timelines for each group
					section.items.forEach((item) => {
						if (item.parallel_group_id) {
							if (!parallelGroups.has(item.parallel_group_id)) {
								parallelGroups.set(item.parallel_group_id, new Set());
							}
							// Use the parallel_timeline if provided, otherwise use group_id
							const timeline = item.parallel_timeline || item.parallel_group_id;
							parallelGroups.get(item.parallel_group_id).add(timeline);
						}
					});

					// Second pass: set groupTimelines for all items in parallel groups
					section.items.forEach((item) => {
						if (item.parallel_group_id && parallelGroups.has(item.parallel_group_id)) {
							// Convert Set to Array for groupTimelines
							item.groupTimelines = Array.from(parallelGroups.get(item.parallel_group_id));
							// Preserve the parallel_timeline if it was already set
							// Only set it to group_id if it's not provided
							if (!item.parallel_timeline) {
								item.parallel_timeline = item.parallel_group_id;
							}
						}
					});
				}
			});
		}
		// --- End hydration ---

		// Add userId before validation
		const dataWithUser = { ...rawData, created_by: userId };

		// Validate using Zod schema
		const validationResult = createPracticePlanSchema.safeParse(dataWithUser);

		if (!validationResult.success) {
			// Throw ZodError to be caught by handleApiError
			throw validationResult.error;
		}

		// Use the validated data
		const validatedData = validationResult.data;

		// --- Add order to sections before calling the service ---
		if (validatedData.sections && Array.isArray(validatedData.sections)) {
			validatedData.sections = validatedData.sections.map((section, index) => ({
				...section,
				order: index // Add order based on array index
			}));
		}
		// --- End adding order to sections ---

		// Create practice plan using the service
		// Pass validated data (now with ordered sections) to the service
		const result = await practicePlanService.createPracticePlan(validatedData, userId);

		return json({ id: result.id, message: 'Practice plan created successfully' }, { status: 201 });
	} catch (err) {
		// Use the centralized error handler
		return handleApiError(err);
	}
};
</file>

<file path="src/hooks.server.js">
import { sequence } from '@sveltejs/kit/hooks';
import * as Sentry from '@sentry/sveltekit';
import { auth } from '$lib/auth';
import { svelteKitHandler } from 'better-auth/svelte-kit';
import { kyselyDb } from '$lib/server/db.js';
// import { cleanup } from '@vercel/postgres'; // Commented out if not used
import { dev } from '$app/environment';

if (!dev && process.env.SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: 'production',
    enabled: true,
    tracesSampleRate: 1.0
  });
}

export const handleError = Sentry.handleErrorWithSentry(async function _handleError({ error }) {
	console.error('Uncaught error:', error);

	return {
		message: 'Internal error',
		code: error?.code ?? 'UNKNOWN'
	};
});

export const handle = sequence(!dev ? Sentry.sentryHandle() : (async ({ event, resolve }) => resolve(event)), async function _handle({ event, resolve }) {
	// Retrieve the current session (if any) and expose it on event.locals so that
	// downstream load functions, endpoints and `authGuard` can access it.
	try {
		const sessionResult = await auth.api.getSession({
			headers: event.request.headers
		});

		if (sessionResult && sessionResult.user) {
			// Ensure user exists in our users table (short-term fix for missing users)
			try {
				const existing = await kyselyDb
					.selectFrom('users')
					.select(['id', 'role'])
					.where('id', '=', sessionResult.user.id)
					.executeTakeFirst();

				if (!existing) {
					// User missing in our table - insert them now
					console.warn('[hooks] User missing from users table, creating:', sessionResult.user.id);
					await kyselyDb
						.insertInto('users')
						.values({
							id: sessionResult.user.id,
							email: sessionResult.user.email ?? null,
							name: sessionResult.user.name ?? null,
							image: sessionResult.user.image ?? null,
							role: 'user'
						})
						.onConflict((oc) => oc.column('id').doNothing())
						.execute();

					// Set default role for newly created user
					event.locals.session = {
						...sessionResult.session,
						user: {
							...sessionResult.user,
							role: 'user'
						}
					};
				} else {
					// User exists, use their actual role
					event.locals.session = {
						...sessionResult.session,
						user: {
							...sessionResult.user,
							role: existing.role || 'user'
						}
					};
				}
			} catch (err) {
				console.error('[hooks] Failed to ensure user exists:', err);
				// Report to Sentry in production
				if (!dev && process.env.SENTRY_DSN) {
					Sentry.captureException(err, {
						extra: {
							userId: sessionResult.user?.id,
							userEmail: sessionResult.user?.email,
							context: 'hooks.server.js - ensure user exists'
						}
					});
				}
				// Fallback: use session data as-is
				event.locals.session = {
					...sessionResult.session,
					user: {
						...sessionResult.user,
						role: sessionResult.user.role || 'user'
					}
				};
			}

			event.locals.user = event.locals.session.user;
		} else {
			// Debug logging for auth issues
			if (dev && event.url.pathname.includes('/teams')) {
				console.log('[auth] No session for teams route; Cookie header:', event.request.headers.get('cookie'));
			}
		}
	} catch (err) {
		console.warn('Error while fetching session or ensuring user exists:', err);
		// If the request does not contain a valid session cookie, ignore the error –
		// unauthenticated requests are still allowed to proceed to public routes.
	}

	return svelteKitHandler({ event, resolve, auth });
});

// Commented out or removed if cleanup is not actively used
// export async function onłądīt() {
//  await cleanup();
// }
</file>

<file path="src/lib/server/services/drillService.js">
import { BaseEntityService } from './baseEntityService.js';
import * as db from '$lib/server/db';
import { upsertSkillCounts } from './skillSql.js';
import {
	NotFoundError,
	ForbiddenError,
	ValidationError,
	DatabaseError,
	ConflictError,
	AppError
} from '$lib/server/errors.js'; // Added import
import { dev } from '$app/environment'; // Import dev environment variable
import { json } from '@sveltejs/kit';
import { kyselyDb, sql } from '$lib/server/db';

/**
 * Service for managing drills
 * Extends the BaseEntityService with drill-specific functionality
 */
export class DrillService extends BaseEntityService {
	/**
	 * Creates a new DrillService
	 */
	constructor() {
		const allowedColumns = [
			'name',
			'brief_description',
			'detailed_description',
			'skill_level',
			'complexity',
			'number_of_people_min',
			'number_of_people_max',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'created_by',
			'visibility',
			'date_created',
			'is_editable_by_others',
			'parent_drill_id',
			'video_link',
			'diagrams',
			'images',
			'upload_source',
			'search_vector',
			'suggested_length_min',
			'suggested_length_max'
		];

		const columnTypes = {
			diagrams: 'json',
			skills_focused_on: 'array',
			positions_focused_on: 'array',
			skill_level: 'array',
			drill_type: 'array',
			images: 'array'
		};

		// Configure standard permissions (using default column names/values)
		const permissionConfig = {
			// userIdColumn: 'created_by', // default
			// visibilityColumn: 'visibility', // default
			// publicValue: 'public', // default
			// unlistedValue: 'unlisted', // default
			// privateValue: 'private', // default
			// editableByOthersColumn: 'is_editable_by_others' // default
		};

		// Explicitly define default columns for DrillService
		// to ensure _executeSearch fallback selects them correctly with similarity_score
		const defaultDrillColumns = [
			'id',
			'name',
			'brief_description',
			'detailed_description',
			'skill_level',
			'complexity',
			'number_of_people_min',
			'number_of_people_max',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'created_by',
			'visibility',
			'date_created',
			'is_editable_by_others',
			'parent_drill_id',
			'video_link',
			'diagrams',
			'images',
			'upload_source',
			'suggested_length_min',
			'suggested_length_max'
			// 'search_vector' is usually not needed in direct output
		];

		super('drills', 'id', defaultDrillColumns, allowedColumns, columnTypes, permissionConfig);

		// Define array fields for normalization
		this.arrayFields = [
			'skill_level',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'images',
			'diagrams'
		];
	}

	/**
	 * Create a new drill
	 * @param {Object} drillData - Drill data
	 * @param {number|null} userId - User ID creating the drill (null if anonymous)
	 * @returns {Promise<Object>} - The created drill
	 */
	async createDrill(drillData, userId = null) {
		const dataWithMeta = {
			...drillData,
			created_by: userId,
			date_created: new Date()
		};
		const normalizedData = this.normalizeDrillData(dataWithMeta);

		return this.withTransaction(async (client) => {
			const drill = await this.create(normalizedData, client); // Pass client
			const skills = normalizedData.skills_focused_on || [];
			await this.updateSkills(skills, drill.id, client); // Pass client
			return drill;
		});
	}

	/**
	 * Update an existing drill
	 * @param {number} id - Drill ID
	 * @param {Object} drillData - Updated drill data
	 * @param {number} userId - User ID updating the drill
	 * @returns {Promise<Object>} - The updated drill
	 * @throws {NotFoundError} - If drill not found
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async updateDrill(id, drillData, userId) {
		return this.withTransaction(async (client) => {
			await this.canUserEdit(id, userId, client);
			const existingDrill = await this.getById(id, this.defaultColumns, userId, client); // Use defaultColumns, pass client
			if (!existingDrill) {
				throw new NotFoundError('Drill not found');
			}
			const existingSkills = existingDrill.skills_focused_on || [];
			const normalizedData = this.normalizeDrillData(drillData);

			if (existingDrill.created_by === null && userId) {
				normalizedData.created_by = userId;
			}

			const updatedDrill = await this.update(id, normalizedData, client); // Pass client

			const skillsToRemove = existingSkills.filter(
				(skill) => !normalizedData.skills_focused_on?.includes(skill)
			);
			const skillsToAdd =
				normalizedData.skills_focused_on?.filter((skill) => !existingSkills.includes(skill)) || [];

			await this.updateSkillCounts(skillsToAdd, skillsToRemove, id, client); // Pass client

			if (normalizedData.name && normalizedData.name !== existingDrill.name) {
				await client.query(`UPDATE votes SET item_name = $1 WHERE drill_id = $2`, [
					normalizedData.name,
					id
				]);
			}
			return updatedDrill;
		});
	}

	/**
	 * Delete a drill by ID
	 * @param {number} id - Drill ID to delete
	 * @param {number} userId - User ID attempting the deletion
	 * @param {Object} options - Additional options
	 * @param {boolean} [options.deleteRelated=false] - Whether to delete related votes and comments
	 * @returns {Promise<boolean>} - True if successful, false if not found
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async deleteDrill(id, userId, options = { deleteRelated: false }) {
		return this.withTransaction(async (client) => {
			let drill;
			if (options.deleteRelated && dev) {
				// Check for dev environment as well
				// In dev mode with deleteRelated, fetch without user ID check
				console.log(`[DEV MODE - deleteDrill] Bypassing permission checks for drill ${id}`);
				try {
					// Directly fetch the needed columns to avoid permission checks in getById
					const result = await client.query(
						`SELECT ${this.permissionConfig.userIdColumn} as created_by, skills_focused_on FROM drills WHERE id = $1`,
						[id]
					);
					if (result.rows.length === 0) {
						throw new NotFoundError(`Drill not found for deletion (dev mode): ${id}`);
					}
					drill = result.rows[0];
				} catch (error) {
					if (error instanceof NotFoundError) {
						throw error; // Re-throw as NotFoundError already handled
					}
					throw error; // Re-throw other errors
				}
			} else {
				// Ensure client is passed to getById for permission check within transaction
				drill = await this.getById(
					id,
					[this.permissionConfig.userIdColumn, 'skills_focused_on'],
					userId,
					client
				);
			}

			if (!drill) {
				throw new NotFoundError(`Drill not found to delete: ${id}`);
			}

			if (!(options.deleteRelated && dev) && drill[this.permissionConfig.userIdColumn] !== userId) {
				throw new ForbiddenError(
					`Unauthorized to delete this drill: ${id}. User ${userId} is not owner ${drill[this.permissionConfig.userIdColumn]}.`
				);
			}

			if (options.deleteRelated) {
				// Delete related votes
				await client.query('DELETE FROM votes WHERE drill_id = $1', [id]);
				// Delete related comments
				await client.query('DELETE FROM comments WHERE drill_id = $1', [id]);
				// Potentially delete from practice_plan_drills, etc. if needed
				// TODO: Add deletion from practice_plan_drills if required
			}

			// Delete the drill itself using the base service method with the client
			await this.delete(id, client);

			// Decrement skill counts (only if deletion was successful)
			const skillsToDecrement = drill.skills_focused_on || [];
			if (skillsToDecrement.length > 0) {
				// Passing an empty array for skillsToAdd
				await this.updateSkillCounts([], skillsToDecrement, id, client);
			}

			return true; // Successfully deleted
		});
	}

	/**
	 * Get a drill with its variations and creator names
	 * @param {number} id - Drill ID
	 * @returns {Promise<Object>} - Drill with variations and creator names
	 */
	async getDrillWithVariations(id) {
		const drill = await this.getById(id);
		if (!drill) {
			return null;
		}

		// Get variations of this drill
		const variationsQuery = `
      SELECT d.*, 
             (SELECT COUNT(*) FROM drills v WHERE v.parent_drill_id = d.id) as variation_count
      FROM drills d
      WHERE d.parent_drill_id = $1
      ORDER BY d.date_created DESC
    `;

		const variationsResult = await db.query(variationsQuery, [id]);
		drill.variations = variationsResult.rows;

		// Fetch creator names for variations if any exist
		if (drill.variations && drill.variations.length > 0) {
			const userIds = [...new Set(drill.variations.map((v) => v.created_by).filter(Boolean))];

			if (userIds.length > 0) {
				try {
					// Fetch user names using a separate service or direct query for now
					// TODO: Consider a dedicated UserService for this
					const usersResult = await db.query(`SELECT id, name FROM users WHERE id = ANY($1)`, [
						userIds
					]);

					const userMap = {};
					usersResult.rows.forEach((user) => {
						userMap[user.id] = user.name;
					});

					// Add creator_name to each variation
					drill.variations.forEach((variation) => {
						if (variation.created_by) {
							variation.creator_name = userMap[variation.created_by] || 'Unknown User';
						}
					});
				} catch (userError) {
					console.error(`Error fetching user names for variations of drill ${id}:`, userError);
					// Proceed without creator names if fetching fails
					drill.variations.forEach((variation) => {
						variation.creator_name = 'Error fetching name';
					});
				}
			}
		}

		return drill;
	}

	/**
	 * Create a variation of an existing drill
	 * @param {number} parentId - Parent drill ID
	 * @param {Object} variationData - Variation drill data
	 * @param {number} userId - User ID creating the variation
	 * @returns {Promise<Object>} - The created variation
	 * @throws {NotFoundError} - If parent drill not found
	 */
	async createVariation(parentId, variationData, userId) {
		const parentDrill = await this.getById(parentId);
		if (!parentDrill) {
			// Throw NotFoundError instead of generic Error
			throw new NotFoundError('Parent drill not found');
		}

		// Create a new drill as a variation
		const normalizedData = this.normalizeDrillData({
			...variationData,
			parent_drill_id: parentId,
			created_by: userId,
			date_created: new Date()
		});

		const variation = await this.create(normalizedData);

		// Update skills used in this variation
		if (normalizedData.skills_focused_on && normalizedData.skills_focused_on.length > 0) {
			await this.updateSkills(normalizedData.skills_focused_on, variation.id);
		}

		return variation;
	}

	/**
	 * Get options for drill filters (distinct values, ranges).
	 * @returns {Promise<Object>} - Object containing filter options.
	 */
	async getDrillFilterOptions() {
		try {
			// Helper function to process distinct values
			const processDistinctResults = (rows) => {
				return rows
					.map((row) => row.value)
					.filter(Boolean) // Ensure value is not null/undefined/empty string
					.sort();
			};

			// Query for distinct values (using LOWER + TRIM in SQL)
			const skillLevelsQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(skill_level))) as value FROM drills WHERE array_length(skill_level, 1) > 0 ORDER BY value;`;
			const complexitiesQuery = `SELECT DISTINCT LOWER(TRIM(complexity)) as value FROM drills WHERE complexity IS NOT NULL ORDER BY value;`;
			const skillsFocusedQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(skills_focused_on))) as value FROM drills WHERE array_length(skills_focused_on, 1) > 0 ORDER BY value;`;
			const positionsFocusedQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(positions_focused_on))) as value FROM drills WHERE array_length(positions_focused_on, 1) > 0 ORDER BY value;`;
			const drillTypesQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(drill_type))) as value FROM drills WHERE array_length(drill_type, 1) > 0 ORDER BY value;`;

			// Query for min/max number of people
			const peopleRangeQuery = `
        SELECT 
          MIN(number_of_people_min) as min_people,
          MAX(number_of_people_max) as max_people
        FROM drills
        WHERE number_of_people_min IS NOT NULL OR number_of_people_max IS NOT NULL;
      `;

			// Query for min/max suggested length
			const lengthRangeQuery = `
        SELECT 
          MIN(suggested_length_min) as min_length,
          MAX(suggested_length_max) as max_length
        FROM drills
        WHERE suggested_length_min IS NOT NULL OR suggested_length_max IS NOT NULL;
      `;

			// Execute all queries in parallel
			const [
				skillLevelsResult,
				complexitiesResult,
				skillsFocusedResult,
				positionsFocusedResult,
				drillTypesResult,
				peopleRangeResult,
				lengthRangeResult // Add lengthRangeResult
			] = await Promise.all([
				db.query(skillLevelsQuery),
				db.query(complexitiesQuery),
				db.query(skillsFocusedQuery),
				db.query(positionsFocusedQuery),
				db.query(drillTypesQuery),
				db.query(peopleRangeQuery),
				db.query(lengthRangeQuery) // Execute length query
			]);

			return {
				skillLevels: processDistinctResults(skillLevelsResult.rows),
				complexities: processDistinctResults(complexitiesResult.rows),
				skillsFocusedOn: processDistinctResults(skillsFocusedResult.rows),
				positionsFocusedOn: processDistinctResults(positionsFocusedResult.rows),
				drillTypes: processDistinctResults(drillTypesResult.rows),
				numberOfPeopleOptions: {
					min: peopleRangeResult.rows[0]?.min_people ?? 0, // Use nullish coalescing
					max: peopleRangeResult.rows[0]?.max_people ?? 100 // Use nullish coalescing
				},
				// Update suggestedLengths based on DB query
				suggestedLengths: {
					min: lengthRangeResult.rows[0]?.min_length ?? 0, // Default to 0 if null
					max: lengthRangeResult.rows[0]?.max_length ?? 120 // Default to 120 if null
				}
			};
		} catch (error) {
			console.error('Error in drillService.getDrillFilterOptions:', error);
			// Re-throw the error to be handled by the API route
			throw new DatabaseError('Failed to retrieve filter options from database.', error);
		}
	}

	/**
	 * Search drills by name, description, and other criteria
	 * @param {string} searchTerm - Search term
	 * @param {Object} options - Search options including filters
	 * @returns {Promise<Object>} - Search results with pagination
	 */
	async searchDrills(searchTerm, options = {}) {
		// Consolidate search logic into getFilteredDrills
		const filters = {
			...(options.filters || {}), // Preserve any existing filters from options
			searchQuery: searchTerm
		};
		// Remove options.filters if it exists, as it's merged into the main filters object
		const { filters: _, ...remainingOptions } = options;
		return this.getFilteredDrills(filters, remainingOptions);
	}

	/**
	 * Get drills with advanced filtering, sorting, and pagination
	 * Overrides base getAll functionality for complex drill filtering
	 * @param {Object} [filters={}] - Filters object
	 * @param {string[]} [filters.skill_level] - Skill levels to filter by (match any)
	 * @param {string} [filters.complexity] - Complexity level
	 * @param {string[]} [filters.skills_focused_on] - Skills to filter by (match any)
	 * @param {string[]} [filters.positions_focused_on] - Positions to filter by (match any)
	 * @param {string[]} [filters.drill_type] - Drill types to filter by (match any)
	 * @param {number} [filters.number_of_people_min] - Minimum number of people
	 * @param {number} [filters.number_of_people_max] - Maximum number of people
	 * @param {number} [filters.suggested_length_min] - Minimum suggested length (e.g., minutes)
	 * @param {number} [filters.suggested_length_max] - Maximum suggested length (e.g., minutes)
	 * @param {boolean} [filters.hasVideo] - Filter by presence of video
	 * @param {boolean} [filters.hasDiagrams] - Filter by presence of diagrams
	 * @param {boolean} [filters.hasImages] - Filter by presence of images
	 * @param {string} [filters.searchQuery] - Text search query (searches name, descriptions)
	 * @param {Object} [options={}] - Sorting and pagination options
	 * @param {string} [options.sortBy='date_created'] - Column to sort by (e.g., 'name', 'date_created')
	 * @param {'asc'|'desc'} [options.sortOrder='desc'] - Sort order
	 * @param {number} [options.page=1] - Page number
	 * @param {number} [options.limit=10] - Items per page
	 * @param {number|null} [options.userId] - User ID for permission filtering
	 * @param {string[]} [options.columns] - Columns to include in the result
	 * @returns {Promise<Object>} - Object containing `items` array and `pagination` info
	 */
	async getFilteredDrills(filters = {}, options = {}) {
		const {
			page = 1,
			limit = 10,
			sortBy = 'date_created',
			sortOrder = 'desc',
			columns = ['*'],
			userId = null
		} = options;

		const offset = (page - 1) * limit;

		// Helper to build the Kysely base query with specific drill table and common filters.
		const buildDrillBaseQuery = () => {
			let qb = kyselyDb.selectFrom('drills').selectAll(); // Start with selectAll, specific columns handled by _executeSearch or defaultColumns

			// Apply standard visibility/ownership filters from BaseEntityService
			// This part needs to be aligned with how _buildWhereClause works or be replicated if _buildWhereClause is not Kysely-native.
			// For now, assuming _buildWhereClause is not Kysely native and permissions are applied here directly for Kysely.
			if (this.useStandardPermissions && this.permissionConfig) {
				const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
					this.permissionConfig;
				qb = qb.where((eb) => {
					const conditions = [
						eb(visibilityColumn, '=', publicValue),
						eb(visibilityColumn, '=', unlistedValue)
					];
					if (userId) {
						conditions.push(
							eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
						);
					}
					return eb.or(conditions);
				});
			}

            // Apply specific drill filters using Kysely
            if (filters.skill_level?.length)
                qb = qb.where(sql`skill_level && ARRAY[${sql.join(filters.skill_level.map(s => sql.literal(s)), sql`, `)}]::text[]`); // Array overlap
			// Handle complexity as either array or string for backward compatibility
			if (Array.isArray(filters.complexity) && filters.complexity.length) {
				qb = qb.where('complexity', 'in', filters.complexity);
			} else if (typeof filters.complexity === 'string' && filters.complexity) {
				qb = qb.where('complexity', '=', filters.complexity);
			}
            if (filters.skills_focused_on?.length)
                qb = qb.where(sql`skills_focused_on && ARRAY[${sql.join(filters.skills_focused_on.map(s => sql.literal(s)), sql`, `)}]::text[]`);
            if (filters.positions_focused_on?.length)
                qb = qb.where(sql`positions_focused_on && ARRAY[${sql.join(filters.positions_focused_on.map(s => sql.literal(s)), sql`, `)}]::text[]`);
            if (filters.drill_type?.length) qb = qb.where(sql`drill_type && ARRAY[${sql.join(filters.drill_type.map(s => sql.literal(s)), sql`, `)}]::text[]`);
            if (filters.number_of_people_min != null)
                qb = qb.where('number_of_people_min', '>=', filters.number_of_people_min);
			if (filters.number_of_people_max != null)
				qb = qb.where('number_of_people_max', '<=', filters.number_of_people_max);
			if (filters.suggested_length_min != null)
				qb = qb.where('suggested_length_min', '>=', filters.suggested_length_min);
			if (filters.suggested_length_max != null)
				qb = qb.where('suggested_length_max', '<=', filters.suggested_length_max);
			if (filters.hasVideo === true)
				qb = qb.where('video_link', 'is not', null).where('video_link', '!=', '');
			if (filters.hasVideo === false)
				qb = qb.where((eb) => eb.or([eb('video_link', 'is', null), eb('video_link', '=', '')]));
			if (filters.hasDiagrams === true)
				qb = qb.where(sql`array_length(diagrams, 1) > 0`);
			if (filters.hasDiagrams === false)
				qb = qb.where(sql`diagrams IS NULL OR array_length(diagrams, 1) IS NULL OR array_length(diagrams, 1) = 0`);
			if (filters.hasImages === true) qb = qb.where(sql`array_length(images, 1) > 0`);
            if (filters.hasImages === false)
                qb = qb.where(sql`images IS NULL OR array_length(images, 1) IS NULL OR array_length(images, 1) = 0`);

            return qb;
        };

		const baseQuery = buildDrillBaseQuery();
		const baseQueryForFallback = buildDrillBaseQuery(); // Separate instance for fallback path

		const ftsQueryBuilder = this._buildSearchQuery(
			baseQuery,
			filters.searchQuery,
			'search_vector',
			'english',
			['name', 'brief_description', 'detailed_description'] // Columns for pg_trgm fallback
		);

		// Apply sorting - _executeSearch handles similarity sort for fallback
		let finalQuery = ftsQueryBuilder;
		if (
			!ftsQueryBuilder._ftsAppliedInfo ||
			(options.sortBy && options.sortBy !== 'similarity_score')
		) {
			const validSortColumns = ['name', 'date_created', 'complexity' /* other allowed columns */];
			const sortCol = validSortColumns.includes(sortBy) ? sortBy : 'date_created';
			const direction = sortOrder === 'asc' ? 'asc' : 'desc';
			finalQuery = finalQuery.orderBy(sortCol, direction).orderBy('id', direction); // Add secondary sort by ID
		}

		const { items, usedFallback } = await this._executeSearch(finalQuery, baseQueryForFallback, {
			limit,
			offset
		});

		await this._addVariationCounts(items); // Add variation counts to results

		// Count total items matching the successful search strategy
		let countQueryBaseForFiltersOnly = buildDrillBaseQuery(); // Rebuild for count to ensure filters are clean
		// We need a new Kysely instance for count that doesn't have prior .selectAll()
		let countQuery = kyselyDb
			.selectFrom('drills')
			.select(kyselyDb.fn.count('drills.id').as('total'));

		// Apply WHERE clauses from countQueryBaseForFiltersOnly to the new countQuery
		// This is a bit manual; Kysely doesn't have a direct way to copy just WHERE clauses.
		// We re-apply filters based on the logic in buildDrillBaseQuery and search conditions.

		// Re-apply visibility/ownership from buildDrillBaseQuery structure
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			countQuery = countQuery.where((eb) => {
				const conditions = [
					eb(visibilityColumn, '=', publicValue),
					eb(visibilityColumn, '=', unlistedValue)
				];
				if (userId) {
					conditions.push(
						eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
					);
				}
				return eb.or(conditions);
			});
		}
		// Re-apply specific drill filters
        if (filters.skill_level?.length)
            countQuery = countQuery.where(sql`skill_level && ARRAY[${sql.join(filters.skill_level.map(s => sql.literal(s)), sql`, `)}]::text[]`);
		// Handle complexity as either array or string for backward compatibility
		if (Array.isArray(filters.complexity) && filters.complexity.length) {
			countQuery = countQuery.where('complexity', 'in', filters.complexity);
		} else if (typeof filters.complexity === 'string' && filters.complexity) {
			countQuery = countQuery.where('complexity', '=', filters.complexity);
		}
        if (filters.skills_focused_on?.length)
            countQuery = countQuery.where(sql`skills_focused_on && ARRAY[${sql.join(filters.skills_focused_on.map(s => sql.literal(s)), sql`, `)}]::text[]`);
        if (filters.positions_focused_on?.length)
            countQuery = countQuery.where(sql`positions_focused_on && ARRAY[${sql.join(filters.positions_focused_on.map(s => sql.literal(s)), sql`, `)}]::text[]`);
        if (filters.drill_type?.length)
            countQuery = countQuery.where(sql`drill_type && ARRAY[${sql.join(filters.drill_type.map(s => sql.literal(s)), sql`, `)}]::text[]`);
		if (filters.number_of_people_min != null)
			countQuery = countQuery.where('number_of_people_min', '>=', filters.number_of_people_min);
		if (filters.number_of_people_max != null)
			countQuery = countQuery.where('number_of_people_max', '<=', filters.number_of_people_max);
		if (filters.suggested_length_min != null)
			countQuery = countQuery.where('suggested_length_min', '>=', filters.suggested_length_min);
		if (filters.suggested_length_max != null)
			countQuery = countQuery.where('suggested_length_max', '<=', filters.suggested_length_max);
		if (filters.hasVideo === true)
			countQuery = countQuery.where('video_link', 'is not', null).where('video_link', '!=', '');
		if (filters.hasVideo === false)
			countQuery = countQuery.where((eb) =>
				eb.or([eb('video_link', 'is', null), eb('video_link', '=', '')])
			);
		if (filters.hasDiagrams === true)
			countQuery = countQuery.where(
				sql`array_length(diagrams, 1) > 0`
			);
		if (filters.hasDiagrams === false)
			countQuery = countQuery.where(
				sql`diagrams IS NULL OR array_length(diagrams, 1) IS NULL OR array_length(diagrams, 1) = 0`
			);
		if (filters.hasImages === true) countQuery = countQuery.where(sql`array_length(images, 1) > 0`);
		if (filters.hasImages === false)
			countQuery = countQuery.where(sql`images IS NULL OR array_length(images, 1) IS NULL OR array_length(images, 1) = 0`);

		if (filters.searchQuery) {
			const cleanedSearchTerm = filters.searchQuery.trim();
			if (cleanedSearchTerm) {
				if (usedFallback) {
					countQuery = countQuery.where((eb) =>
						eb.or([
							eb(sql`similarity(name, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(brief_description, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(detailed_description, ${cleanedSearchTerm})`, '>', 0.3)
						])
					);
				} else {
					const tsQuerySearchTerm = cleanedSearchTerm
						.split(/\s+/)
						.filter(Boolean)
						.map((term) => term + ':*')
						.join(' & ');
					if (tsQuerySearchTerm) {
						countQuery = countQuery.where(
							sql`search_vector @@ to_tsquery('english', ${tsQuerySearchTerm})`
						);
					}
				}
			}
		}

		const countResult = await countQuery.executeTakeFirst();
		const totalItems = parseInt(countResult?.total ?? '0', 10);

		return {
			items: items,
			pagination: {
				page: parseInt(page),
				limit: parseInt(limit),
				totalItems,
				totalPages: Math.ceil(totalItems / limit)
			}
		};
	}

	/**
	 * Helper method to add variation counts to an array of drills
	 * @param {Array<Object>} drills - Array of drill objects
	 * @returns {Promise<void>}
	 * @private
	 */
	async _addVariationCounts(drills) {
		if (!drills || !drills.length) return;

		try {
			// Get all drill IDs
			const drillIds = drills.map((drill) => drill.id);

			// Get variation counts for all drills in a single query
			const query = `
        SELECT parent_drill_id, COUNT(*) AS count
        FROM drills
        WHERE parent_drill_id = ANY($1)
        GROUP BY parent_drill_id
      `;

			const result = await db.query(query, [drillIds]);

			// Create a map of drill ID to variation count
			const countMap = {};

			// Safely process query results
			if (result && result.rows) {
				result.rows.forEach((row) => {
					countMap[row.parent_drill_id] = parseInt(row.count);
				});
			}

			// Set variation counts on drill objects
			drills.forEach((drill) => {
				drill.variation_count = countMap[drill.id] || 0;
			});
		} catch (error) {
			console.error('Error while adding variation counts:', error);
			// Don't let variation count errors disrupt the main functionality
			// Just ensure all drills have a variation_count property
			drills.forEach((drill) => {
				if (!drill.hasOwnProperty('variation_count')) {
					drill.variation_count = 0;
				}
			});
		}
	}

	/**
	 * Fetches all drill names and their IDs.
	 * Used for mapping generated names to existing drills or providing context.
	 * @returns {Promise<Array<{id: number, name: string}>>}
	 */
	async getAllDrillNames() {
		try {
			const drills = await kyselyDb
				.selectFrom('drills')
				.select(['id', 'name'])
				.orderBy('name', 'asc')
				.execute();

			return drills;
		} catch (error) {
			console.error('Error fetching drill names:', error);
			// Consider throwing a specific error type
			throw new DatabaseError('Failed to fetch drill names', error);
		}
	}

	/**
	 * Fetches detailed information for drills, suitable for AI context.
	 * Excludes large fields like diagrams.
	 * @param {number|null} [userId=null] - The ID of the user requesting the drills.
	 * @returns {Promise<Array<Object>>} - Array of drill detail objects.
	 */
	async getAllDrillDetailsForAI(userId = null) {
		try {
			// Define columns to select, excluding diagrams and non-existent ones
			const columnsToSelect = [
				'id',
				'name',
				'brief_description',
				'detailed_description',
				'skill_level',
				'complexity',
				'suggested_length_min',
				'suggested_length_max',
				'number_of_people_min',
				'number_of_people_max',
				'skills_focused_on',
				'positions_focused_on',
				'drill_type',
				'visibility',
				'is_editable_by_others'
				// Removed created_by, date_created, parent_id, upload_source, search_vector for brevity
			];

			const drills = await kyselyDb
				.selectFrom('drills')
				.select(columnsToSelect)
				.orderBy('name', 'asc') // Keep ordering consistent
				// Add WHERE clause for visibility/ownership
				.$if(userId !== null, (qb) =>
					qb
						// If userId is provided, get public drills OR drills created by this user
						.where((eb) => eb.or([eb('visibility', '=', 'public'), eb('created_by', '=', userId)]))
				)
				.$if(userId === null, (qb) =>
					qb
						// If no userId (anonymous), only get public drills
						.where('visibility', '=', 'public')
				)
				.execute();

			// No need for JS filtering anymore, SQL handles it.
			return drills;
		} catch (error) {
			console.error('Error fetching detailed drill data for AI:', error);
			throw new DatabaseError('Failed to fetch detailed drill data', error);
		}
	}

	/**
	 * Set a drill as the primary variant
	 * @param {number} drillId - Drill ID to make primary
	 * @param {number} userId - User attempting the action
	 * @returns {Promise<Object>} - Updated drill
	 * @throws {NotFoundError} - If drill not found
	 * @throws {ValidationError} - If the drill is not a variation
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async setAsPrimaryVariant(drillId, userId) {
		return this.withTransaction(async (client) => {
			const drill = await this.getById(drillId, ['*', 'parent_drill_id'], userId, client);
			if (!drill) {
				// Throw NotFoundError instead of generic Error
				throw new NotFoundError('Drill not found');
			}

			if (!drill.parent_drill_id) {
				// Throw ValidationError instead of generic Error
				throw new ValidationError('This drill is not a variation');
			}

			const parentDrill = await this.getById(drill.parent_drill_id, ['*'], userId, client);
			// Add check for parentDrill existence (though getById should handle it)
			if (!parentDrill) {
				throw new NotFoundError('Parent drill not found');
			}

			// Safer approach: keep IDs stable and swap content/roles only
			// 1) Copy content fields from variant (drill) to primary (parentDrill)
			const fields = [
				'name',
				'brief_description',
				'detailed_description',
				'skill_level',
				'complexity',
				'number_of_people_min',
				'number_of_people_max',
				'skills_focused_on',
				'positions_focused_on',
				'drill_type',
				'video_link',
				'diagrams',
				'images'
			];

			// Compute skill count diffs before update
			const oldSkills = parentDrill.skills_focused_on || [];
			const newSkills = drill.skills_focused_on || [];

			const setSql = fields.map((f, i) => `${f} = $${i + 3}`).join(', ');
			await client.query(`UPDATE drills SET ${setSql} WHERE id = $1`, [
				parentDrill.id,
				null,
				...fields.map((f) => drill[f])
			]);

			// Update votes.item_name if name changed on primary
			if (drill.name && drill.name !== parentDrill.name) {
				await client.query(`UPDATE votes SET item_name = $1 WHERE drill_id = $2`, [
					drill.name,
					parentDrill.id
				]);
			}

			// 2) Rewire children of the variant to the primary
			await client.query('UPDATE drills SET parent_drill_id = $1 WHERE parent_drill_id = $2', [
				parentDrill.id,
				drill.id
			]);

			// 3) Ensure the variant remains a child of primary
			await client.query('UPDATE drills SET parent_drill_id = $1 WHERE id = $2', [
				parentDrill.id,
				drill.id
			]);

			// 4) Adjust skill usage counts based on diff
			const skillsToRemove = oldSkills.filter((s) => !newSkills.includes(s));
			const skillsToAdd = newSkills.filter((s) => !oldSkills.includes(s));
			await this.updateSkillCounts(skillsToAdd, skillsToRemove, parentDrill.id, client);

			// Return the updated primary drill with new content
			return this.getById(parentDrill.id, ['*'], userId, client);
		});
	}

	/**
	 * Update skills usage counts
	 * @param {Array<string>} skillsToAdd - Skills to increment
	 * @param {Array<string>} skillsToRemove - Skills to decrement
	 * @param {number} drillId - Drill ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>}
	 */
	async updateSkillCounts(skillsToAdd, skillsToRemove, drillId, client = null) {
		const dbInterface = client || db;
		// Add new skills
		if (skillsToAdd && skillsToAdd.length > 0) {
			// Pass client to updateSkills
			await this.updateSkills(skillsToAdd, drillId, client);
		}

		// Remove skills no longer used
		if (skillsToRemove && skillsToRemove.length > 0) {
			for (const skill of skillsToRemove) {
				await dbInterface.query(
					// Use dbInterface (client or db)
					`UPDATE skills SET drills_used_in = drills_used_in - 1 WHERE skill = $1`,
					[skill]
				);
			}
		}
	}

	/**
	 * Update skills for a drill
	 * @param {Array<string>} skills - Skills to update
	 * @param {number} drillId - Drill ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>}
	 */
	async updateSkills(skills, drillId, client = null) {
		// Use the provided client or the default db module
		const dbInterface = client || db;

		for (const skill of skills) {
			await upsertSkillCounts(dbInterface, skill, drillId);
		}
	}

	/**
	 * Toggle upvote for a drill
	 * @param {number} drillId - Drill ID
	 * @param {number} userId - User ID performing the upvote
	 * @returns {Promise<Object>} - Updated vote count
	 * @throws {ValidationError} - If IDs are missing
	 * @throws {NotFoundError} - If drill not found
	 */
	async toggleUpvote(drillId, userId) {
		if (!drillId || !userId) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('Both drill ID and user ID are required');
		}

		return this.withTransaction(async (client) => {
			// First verify the drill exists using the base method (which might throw NotFoundError itself)
			try {
				// Pass undefined for columns to use default, null for userId, then the client
				await this.getById(drillId, undefined, null, client);
			} catch (err) {
				if (err instanceof NotFoundError) {
					throw new NotFoundError('Drill not found for upvoting');
				}
				throw err; // Re-throw other unexpected errors
			}

			// Check if user has already voted
			const voteCheckQuery = `
        SELECT * FROM votes 
        WHERE user_id = $1 AND drill_id = $2
      `;
			const voteCheck = await client.query(voteCheckQuery, [userId, drillId]);

			if (voteCheck.rows.length > 0) {
				// User has already voted, remove their vote
				await client.query('DELETE FROM votes WHERE user_id = $1 AND drill_id = $2', [
					userId,
					drillId
				]);
			} else {
				// Add new vote
				await client.query('INSERT INTO votes (user_id, drill_id, vote) VALUES ($1, $2, $3)', [
					userId,
					drillId,
					1
				]);
			}

			// Get updated vote count
			const voteCountQuery = `
        SELECT COUNT(CASE WHEN vote = 1 THEN 1 END) as upvotes
        FROM votes 
        WHERE drill_id = $1
      `;
			const result = await client.query(voteCountQuery, [drillId]);

			return {
				upvotes: parseInt(result.rows[0].upvotes),
				hasVoted: voteCheck.rows.length === 0 // True if we just added a vote
			};
		});
	}

	/**
	 * Set variant relationship for a drill
	 * @param {number} drillId - Drill ID to update
	 * @param {number|null} parentDrillId - Parent drill ID or null to remove the relationship
	 * @returns {Promise<Object>} - Updated drill with variant relationship
	 * @throws {ValidationError} - If drill ID is missing
	 * @throws {NotFoundError} - If drill or parent drill not found
	 * @throws {ConflictError} - If trying to make a parent a variant, or a variant a parent, or self-parenting
	 */
	async setVariant(drillId, parentDrillId) {
		if (!drillId) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('Drill ID is required');
		}

		return this.withTransaction(async (client) => {
			// Check if the current drill exists and get its details
			const drillQuery = `
        SELECT d.*, 
               (SELECT COUNT(*) FROM drills WHERE parent_drill_id = d.id) as child_count
        FROM drills d 
        WHERE d.id = $1
      `;
			const drillResult = await client.query(drillQuery, [drillId]);

			if (drillResult.rows.length === 0) {
				// Throw NotFoundError instead of generic Error
				throw new NotFoundError('Drill not found');
			}

			const currentDrill = drillResult.rows[0];

			if (parentDrillId) {
				// Check if the parent drill exists and is valid
				const parentQuery = `
          SELECT d.*, 
                 (SELECT COUNT(*) FROM drills WHERE parent_drill_id = d.id) as child_count
          FROM drills d 
          WHERE d.id = $1
        `;
				const parentResult = await client.query(parentQuery, [parentDrillId]);

				if (parentResult.rows.length === 0) {
					// Throw NotFoundError instead of generic Error
					throw new NotFoundError('Parent drill not found');
				}

				const parentDrill = parentResult.rows[0];

				// Validate constraints
				if (currentDrill.child_count > 0) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Cannot make a parent drill into a variant');
				}

				if (parentDrill.parent_drill_id) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Cannot set a variant as a parent');
				}

				// Prevent drill from being its own parent
				if (parentDrillId === drillId) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Drill cannot be its own parent');
				}
			}

			// Update the parent_drill_id
			const updateQuery = `
        UPDATE drills 
        SET parent_drill_id = $1 
        WHERE id = $2 
        RETURNING *, 
          (SELECT name FROM drills WHERE id = $1) as parent_drill_name
      `;
			const result = await client.query(updateQuery, [parentDrillId, drillId]);

			return result.rows[0];
		});
	}

	/**
	 * Normalize drill data for consistent database storage
	 * @param {Object} data - Raw drill data
	 * @returns {Object} - Normalized data
	 */
	normalizeDrillData(data) {
		let normalizedData = { ...data };

		// Remove id field if it's null or undefined
		if (normalizedData.id === null || normalizedData.id === undefined) {
			delete normalizedData.id;
		}

		// Use base helper to normalize array fields to ensure they are arrays
		normalizedData = this.normalizeArrayFields(normalizedData, this.arrayFields);

		// Convert diagrams to JSON strings (only if not already strings)
		if (normalizedData.diagrams && Array.isArray(normalizedData.diagrams)) {
			normalizedData.diagrams = normalizedData.diagrams.map((diagram) =>
				typeof diagram === 'object' && diagram !== null ? JSON.stringify(diagram) : diagram
			);
		} else if (normalizedData.diagrams === null || normalizedData.diagrams === undefined) {
			// Ensure it's an empty array if null/undefined before DB insert
			normalizedData.diagrams = [];
		}

		// For enum-like array fields, ensure items are trimmed. Lowercasing is re-added.
		['skill_level', 'skills_focused_on', 'positions_focused_on', 'drill_type'].forEach((field) => {
			if (normalizedData[field] && Array.isArray(normalizedData[field])) {
				normalizedData[field] = normalizedData[field]
					.map(
						(item) => (typeof item === 'string' ? item.trim().toLowerCase() : item) // RE-ADDED .toLowerCase()
					)
					.filter(Boolean); // Remove empty strings after trimming
			} else if (normalizedData[field] === null || normalizedData[field] === undefined) {
				normalizedData[field] = [];
			}
		});

		// Ensure images is an array
		if (normalizedData.images === null || normalizedData.images === undefined) {
			normalizedData.images = [];
		}

		// Handle special number fields
		if (
			normalizedData.number_of_people_max === '' ||
			normalizedData.number_of_people_max === undefined
		) {
			normalizedData.number_of_people_max = null;
		} else {
			const parsedMax = parseInt(normalizedData.number_of_people_max);
			normalizedData.number_of_people_max = !isNaN(parsedMax) ? parsedMax : null;
		}

		if (
			normalizedData.number_of_people_min === '' ||
			normalizedData.number_of_people_min === undefined
		) {
			normalizedData.number_of_people_min = null;
		} else {
			const parsedMin = parseInt(normalizedData.number_of_people_min);
			normalizedData.number_of_people_min = !isNaN(parsedMin) ? parsedMin : null;
		}

		// --- Map suggested_length object to min/max columns ---
		if (normalizedData.suggested_length && typeof normalizedData.suggested_length === 'object') {
			const { min, max } = normalizedData.suggested_length;

			const parsedMin = parseInt(min);
			const parsedMax = parseInt(max);

			normalizedData.suggested_length_min = !isNaN(parsedMin) ? parsedMin : null;
			normalizedData.suggested_length_max = !isNaN(parsedMax) ? parsedMax : null;

			// Remove the original object
			delete normalizedData.suggested_length;
		} else {
			// Ensure columns exist even if input object is missing/invalid
			if (!normalizedData.hasOwnProperty('suggested_length_min')) {
				normalizedData.suggested_length_min = null;
			}
			if (!normalizedData.hasOwnProperty('suggested_length_max')) {
				normalizedData.suggested_length_max = null;
			}
			// Still remove the original field if it existed but wasn't an object
			if (normalizedData.hasOwnProperty('suggested_length')) {
				delete normalizedData.suggested_length;
			}
		}

		return normalizedData;
	}

	/**
	 * Associate an anonymously created drill with a user
	 * @param {number} id - Drill ID
	 * @param {number} userId - User ID to associate with
	 * @returns {Promise<Object>} - The updated drill
	 * @throws {NotFoundError} - If drill not found
	 */
	async associateDrill(id, userId) {
		const drill = await this.getById(id);

		if (!drill) {
			// getById should throw NotFoundError, but double-check
			throw new NotFoundError('Drill not found for association');
		}

		// Check if already owned
		if (drill.created_by !== null) {
			// Return existing drill if already owned
			return drill;
		}

		// Update the created_by field
		return await this.update(id, { created_by: userId });
	}

	/**
	 * Import multiple drills from an array.
	 * @param {Array<Object>} drillsData - Array of drill objects to import.
	 * @param {string} fileName - Original name of the file being imported.
	 * @param {number|null} userId - ID of the user performing the import.
	 * @param {string} visibility - Default visibility for imported drills.
	 * @returns {Promise<Object>} - Object containing importedCount and uploadSource.
	 * @throws {ValidationError} - If input data is invalid or missing required fields
	 * @throws {DatabaseError} - If database insertion fails
	 */
	async importDrills(drillsData, fileName, userId, visibility = 'public') {
		if (!Array.isArray(drillsData) || drillsData.length === 0) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('No drills provided for import');
		}

		// Generate a unique upload_source ID (using timestamp + partial UUID for uniqueness)
		const uploadSource = `${fileName}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;

		return this.withTransaction(async (client) => {
			try {
				const insertPromises = drillsData.map(async (drillInput) => {
					// Mark inner function as async
					// Destructure and prepare data for insertion
					const {
						name,
						brief_description,
						detailed_description,
						skill_level,
						complexity,
						suggested_length, // Keep the object here initially
						number_of_people,
						skills_focused_on,
						positions_focused_on,
						video_link,
						images,
						diagrams,
						drill_type // Add drill_type
					} = drillInput;

					// Basic validation for required fields within the service
					if (!name || !brief_description) {
						// Throw ValidationError instead of generic Error
						throw new ValidationError(
							`Drill missing required field (name or brief_description): ${JSON.stringify(drillInput)}`
						);
					}

					// Prepare data object for normalization
					let drillToNormalize = {
						name,
						brief_description,
						detailed_description: detailed_description || null,
						skill_level,
						complexity: complexity || null,
						suggested_length: suggested_length, // Pass the object for normalization
						number_of_people_min: number_of_people?.min, // Extract min/max before normalization handles defaults
						number_of_people_max: number_of_people?.max,
						skills_focused_on,
						positions_focused_on,
						drill_type, // Include drill_type
						video_link: video_link || null,
						images: images || [],
						diagrams: diagrams || [], // Ensure diagrams is an array
						upload_source: uploadSource,
						created_by: userId,
						visibility,
						is_editable_by_others: false, // Default for imported drills
						date_created: new Date() // Add creation timestamp
					};

					// Normalize the individual drill data
					let drillToInsert = this.normalizeDrillData(drillToNormalize);

					// Use base create method logic for consistency
					// Assuming base `create` can work within the transaction using the passed client.
					// Ensure base `create` accepts a client argument.
					return this.create(drillToInsert, client);
				});

				// Wait for all insertions to complete
				const results = await Promise.all(insertPromises);
				// The base `create` method now returns the created object directly (not wrapped in rows)
				const insertedDrills = results;

				// Optionally, update skill counts for all imported drills
				for (const drill of insertedDrills) {
					if (drill.skills_focused_on && drill.skills_focused_on.length > 0) {
						// Use the existing updateSkills method, passing the client for transaction safety
						await this.updateSkills(drill.skills_focused_on, drill.id, client);
					}
				}

				return { importedCount: drillsData.length, uploadSource };
			} catch (error) {
				// Add specific error wrapping for import failures
				if (
					error instanceof ValidationError ||
					error instanceof DatabaseError ||
					error instanceof AppError
				) {
					throw error; // Re-throw known app errors
				}
				console.error('Error during bulk drill import:', error);
				throw new DatabaseError('Failed during bulk drill import.', error);
			}
		});
	}
}

// Export a singleton instance of the service
export const drillService = new DrillService();
</file>

<file path="src/lib/auth.js">
// src/lib/auth.js - Moved from server directory
import { betterAuth } from 'better-auth';
// Adjust import path to be Node.js friendly for the CLI
import { kyselyDb } from './server/db.js'; // Use relative path
import { building } from '$app/environment';

// Create auth configuration
// During prerendering, we use placeholder values to avoid accessing env variables
const createAuthConfig = () => {
	if (building) {
		// During build/prerender, use a minimal config
		return {
			secret: 'prerender-placeholder-secret',
			url: 'http://localhost:3000',
			database: {
				db: kyselyDb,
				type: 'postgres'
			},
			debug: false
		};
	}

	// During runtime, use process.env which is safe to access
	// These are set by Vercel at runtime
	const AUTH_SECRET = process.env.AUTH_SECRET || process.env.BETTER_AUTH_SECRET;
	const AUTH_URL = process.env.AUTH_URL;
	const NODE_ENV = process.env.NODE_ENV;
	const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
	const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
	
	return {
		secret: AUTH_SECRET,
		url: NODE_ENV === 'production' ? AUTH_URL : 'http://localhost:3000',
		// Uncommented after successful migration
		socialProviders: {
			google: {
				clientId: GOOGLE_CLIENT_ID,
				clientSecret: GOOGLE_CLIENT_SECRET,
				scope: ['openid', 'email', 'profile']
			}
		},

		// Pass the Kysely instance directly
		database: {
			db: kyselyDb, // Use the imported Kysely instance
			type: 'postgres' // Add type hint for the CLI
		},
    // Ensure user exists on sign-in, attach role once, and avoid per-request DB work
    callbacks: {
      // Runs on social or credential sign-in
      async signIn({ user }) {
        if (!user?.id) return true;
        // Upsert minimal user row in our own users table (separate from auth internals)
        try {
          const existing = await kyselyDb
            .selectFrom('users')
            .select(['id'])
            .where('id', '=', user.id)
            .executeTakeFirst();
          if (!existing) {
            await kyselyDb
              .insertInto('users')
              .values({
                id: user.id,
                email: user.email ?? null,
                name: user.name ?? null,
                image: user.image ?? null,
                role: 'user'
              })
              .onConflict((oc) => oc.column('id').doNothing())
              .execute();
            console.log('[auth callbacks.signIn] Successfully created user record for:', user.id);
          }
        } catch (err) {
          console.error('[auth callbacks.signIn] CRITICAL: Failed to ensure user exists in users table:', err);
          console.error('[auth callbacks.signIn] User details:', {
            id: user.id,
            email: user.email,
            name: user.name
          });
          // LONG-TERM FIX: Fail sign-in if we can't create the user record
          // This prevents foreign key violations later
          return false;
        }
        return true;
      },
      // Include role in the session without extra DB queries
      async session({ session, user }) {
        if (session.user) {
          session.user.id = user.id;
          if (!session.user.role) {
            // Try to fetch once during session creation; fallback to 'user'
            try {
              const roleRes = await kyselyDb
                .selectFrom('users')
                .select('role')
                .where('id', '=', user.id)
                .executeTakeFirst();
              session.user.role = roleRes?.role ?? 'user';
            } catch (err) {
              session.user.role = 'user';
            }
          }
        }
        return session;
      }
    },

		debug: NODE_ENV !== 'production'
	};
};

export const auth = betterAuth(createAuthConfig());
</file>

<file path="src/routes/practice-plans/+page.svelte">
<script>
	import FilterPanel from '$lib/components/FilterPanel.svelte';
	import { onDestroy, onMount, afterUpdate } from 'svelte';
	import { tick } from 'svelte';
	import { goto } from '$app/navigation';
        import { page, navigating } from '$app/stores';
	import debounce from 'lodash/debounce';
	import { selectedSortOption, selectedSortOrder } from '$lib/stores/sortStore';
	import UpvoteDownvote from '$lib/components/UpvoteDownvote.svelte';
	import { FILTER_STATES } from '$lib/constants';
	import {
		selectedPhaseOfSeason,
		selectedPracticeGoals,
		selectedEstimatedParticipantsMin,
		selectedEstimatedParticipantsMax
	} from '$lib/stores/practicePlanFilterStore';
	import DeletePracticePlan from '$lib/components/DeletePracticePlan.svelte';
	import Pagination from '$lib/components/Pagination.svelte';
	import { cart } from '$lib/stores/cartStore';
	import AiPlanGeneratorModal from '$lib/components/practice-plan/AiPlanGeneratorModal.svelte';
	import SkeletonLoader from '$lib/components/SkeletonLoader.svelte';

	export let data;

	// Data from load function (now contains paginated items and metadata)
	$: practicePlans = data.practicePlans || [];
	$: pagination = data.pagination;
	$: filterOptions = data.filterOptions || {};
	$: initialSelectedDrills = data.initialSelectedDrills || [];
	$: error = data.error; // Handle potential loading errors

	// --- Component State reflecting URL/Load Data ---
	let searchQuery = data.currentSearch || ''; // Initialize from load data
	let selectedDrills = initialSelectedDrills; // Initialize from load data
	let currentSortBy = data.currentSortBy || 'upvotes';
	let currentSortOrder = data.currentSortOrder || 'desc';

	let showAiModal = false; // NEW modal state

	// --- Initialize filter stores based on URL on mount/update ---
	function initializeFiltersFromUrl() {
		const searchParams = $page.url.searchParams;

		// Helper to parse filter params (req/exc)
		const parseFilterParam = (baseName) => {
			const state = {};
			searchParams.getAll(`${baseName}_req`).forEach((val) => {
				state[val] = FILTER_STATES.REQUIRED;
			});
			searchParams.getAll(`${baseName}_exc`).forEach((val) => {
				state[val] = FILTER_STATES.EXCLUDED;
			});
			return state;
		};

		selectedPhaseOfSeason.set(parseFilterParam('phase'));
		selectedPracticeGoals.set(parseFilterParam('goal'));

		selectedEstimatedParticipantsMin.set(
			parseInt(searchParams.get('minP') || filterOptions.estimatedParticipants?.min || '1', 10)
		);
		selectedEstimatedParticipantsMax.set(
			parseInt(searchParams.get('maxP') || filterOptions.estimatedParticipants?.max || '100', 10)
		);

		// Update local sort state if different from URL
		const urlSortBy = searchParams.get('sortBy') || 'upvotes';
		const urlSortOrder = searchParams.get('sortOrder') || 'desc';
		if (urlSortBy !== currentSortBy) {
			currentSortBy = urlSortBy;
			selectedSortOption.set(urlSortBy);
		}
		if (urlSortOrder !== currentSortOrder) {
			currentSortOrder = urlSortOrder;
			selectedSortOrder.set(urlSortOrder);
		}
	}

	onMount(() => {
		initializeFiltersFromUrl();
	});

	// Re-initialize filters if URL changes (e.g., back/forward buttons)
	afterUpdate(() => {
		if ($page.url.searchParams.toString() !== previousSearchParams) {
			initializeFiltersFromUrl();
			searchQuery = $page.url.searchParams.get('search') || '';
			selectedDrills = initialSelectedDrills; // Re-sync selectedDrills if needed, handled by load
			previousSearchParams = $page.url.searchParams.toString();
		}
	});
	let previousSearchParams = ''; // Track search params for afterUpdate
	onMount(() => {
		previousSearchParams = $page.url.searchParams.toString();

		// Subscribe to sort changes after mount
		let initialMount = true;
		const unsubscribeSortOption = selectedSortOption.subscribe((value) => {
			if (!initialMount) {
				currentSortBy = value;
				updateUrlParams();
			}
		});
		const unsubscribeSortOrder = selectedSortOrder.subscribe((value) => {
			if (!initialMount) {
				currentSortOrder = value;
				updateUrlParams();
			}
		});

		// Set initialMount to false after initial setup
		tick().then(() => {
			initialMount = false;
		});

		// Unsubscribe on component destroy
		return () => {
			unsubscribeSortOption();
			unsubscribeSortOrder();
		};
	});

	// --- URL Update Logic ---
	const updateUrlParams = debounce(() => {
		const params = new URLSearchParams($page.url.searchParams);

		// Update search
		if (searchQuery) {
			params.set('search', searchQuery);
		} else {
			params.delete('search');
		}

		// Update sort
		params.set('sortBy', $selectedSortOption);
		params.set('sortOrder', $selectedSortOrder);

		// Update filters from stores
		updateFilterUrlParams(params, 'phase', $selectedPhaseOfSeason);
		updateFilterUrlParams(params, 'goal', $selectedPracticeGoals);

		// Update range filters
		if ($selectedEstimatedParticipantsMin !== (filterOptions.estimatedParticipants?.min ?? 1)) {
			params.set('minP', $selectedEstimatedParticipantsMin.toString());
		} else {
			params.delete('minP');
		}
		if ($selectedEstimatedParticipantsMax !== (filterOptions.estimatedParticipants?.max ?? 100)) {
			params.set('maxP', $selectedEstimatedParticipantsMax.toString());
		} else {
			params.delete('maxP');
		}

		// Update selected drills
		params.delete('drillId'); // Clear existing
		selectedDrills.forEach((drill) => {
			params.append('drillId', drill.id.toString());
		});

		// Reset page to 1 when filters/search/sort change
		params.set('page', '1');

		goto(`?${params.toString()}`, { keepFocus: true, noScroll: true });
	}, 300); // Debounce time

	// Helper to update URL for multi-state filters
	function updateFilterUrlParams(params, baseName, filterState) {
		params.delete(`${baseName}_req`);
		params.delete(`${baseName}_exc`);
		for (const [value, state] of Object.entries(filterState)) {
			if (state === FILTER_STATES.REQUIRED) {
				params.append(`${baseName}_req`, value);
			} else if (state === FILTER_STATES.EXCLUDED) {
				params.append(`${baseName}_exc`, value);
			}
		}
	}

	function handlePageChange(event) {
		const newPage = event.detail.page;
		const params = new URLSearchParams($page.url.searchParams);
		params.set('page', newPage.toString());
		goto(`?${params.toString()}`, { keepFocus: true });
	}

	// --- Event Handlers ---
	function handleDrillSelect(event) {
		const drill = event.detail; // Assuming FilterPanel dispatches drill object
		if (!selectedDrills.find((d) => d.id === drill.id)) {
			selectedDrills = [...selectedDrills, drill];
			updateUrlParams(); // Trigger URL update
		}
	}

	function handleDrillRemove(event) {
		const drillId = event.detail; // Assuming FilterPanel dispatches drillId
		selectedDrills = selectedDrills.filter((d) => d.id !== drillId);
		updateUrlParams(); // Trigger URL update
	}

	// Called when FilterPanel signals a change in its filters
	function handleFilterChange() {
		updateUrlParams();
	}

	// --- Sort Options ---
	const sortOptions = [
		{ value: 'upvotes', label: 'Upvotes' },
		{ value: 'name', label: 'Name' },
		{ value: 'created_at', label: 'Date Created' },
		{ value: 'updated_at', label: 'Date Updated' },
		{ value: 'estimated_number_of_participants', label: 'Estimated Participants' }
	];

	// Helper for DeletePracticePlan callback
	function onPlanDeleted(deletedPlanId) {
		practicePlans = practicePlans.filter((p) => p.id !== deletedPlanId);
		// Optionally, could trigger a full reload if pagination counts change significantly
		// goto(window.location.href, { invalidateAll: true });
	}
</script>

<svelte:head>
	<title>Practice Plans - QDrill</title>
</svelte:head>

<div class="max-w-7xl mx-auto p-4">
	<div class="flex justify-between items-center mb-6">
		<h1 class="text-2xl font-bold">Practice Plans</h1>
		<div class="flex gap-2 relative">
			{#if $page.data.session}
				{#if $cart.length > 0}
					<a
						href="/practice-plans/create"
						class="inline-block px-6 py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-colors duration-300"
					>
						Create Plan from Cart ({$cart.length} Drill{$cart.length !== 1 ? 's' : ''})
					</a>
					<button
						type="button"
						on:click={() => (showAiModal = true)}
						class="relative inline-block px-6 py-3 bg-gray-100 text-gray-800 border border-gray-300 rounded-lg font-semibold hover:bg-gray-200 transition-colors duration-300"
					>
						Create Plan with AI
						<span
							class="absolute -top-2 -right-2 px-1.5 py-0.5 text-xs bg-red-500 text-white rounded-full"
							>Beta</span
						>
					</button>
				{:else}
					<a
						href="/drills"
						class="inline-block px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors duration-300"
					>
						Go to Drills
					</a>
					<button
						type="button"
						on:click={() => (showAiModal = true)}
						class="relative inline-block px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors duration-300"
					>
						Create Plan with AI
						<span
							class="absolute -top-2 -right-2 px-1.5 py-0.5 text-xs bg-red-500 text-white rounded-full"
							>Beta</span
						>
					</button>
				{/if}
			{:else}
				<a
					href="/login"
					class="inline-block px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors duration-300"
				>
					Sign in to Create Plans
				</a>
			{/if}
		</div>
	</div>

	<!-- Filter Panel -->
	<FilterPanel
		filterType="practice-plans"
		phaseOfSeasonOptions={filterOptions.phaseOfSeason}
		practiceGoalsOptions={filterOptions.practiceGoals}
		bind:selectedDrills
		on:drillSelect={handleDrillSelect}
		on:drillRemove={handleDrillRemove}
		on:filterChange={handleFilterChange}
		{sortOptions}
	/>

	<!-- Search input -->
	<input
		type="text"
		placeholder="Search practice plans..."
		class="mb-6 w-full p-3 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
		bind:value={searchQuery}
		on:input={updateUrlParams}
	/>

	<!-- Display Error Message -->
	{#if error}
		<div
			class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4"
			role="alert"
		>
			<strong class="font-bold">Error:</strong>
			<span class="block sm:inline"> {error}</span>
		</div>
	{/if}

	<!-- Practice Plans Grid -->
	{#if $navigating && !practicePlans.length}
		<!-- Loading skeletons -->
		<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
			{#each Array(6) as _, i}
				<SkeletonLoader 
					lines={3} 
					showCard={true}
					showButton={true}
					className="h-56"
				/>
			{/each}
		</div>
	{:else if practicePlans.length > 0}
		<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
			<!-- Use practicePlans directly (already paginated and sorted by server) -->
			{#each practicePlans as plan (plan.id)}
				<div
					class="border border-gray-200 p-6 bg-white rounded-lg shadow-md transition-transform transform hover:-translate-y-1 overflow-hidden"
				>
					<!-- Header section with title and voting -->
					<div class="relative flex justify-between items-start mb-4">
						<div class="flex-1 pr-12 min-w-0">
							<h2 class="text-xl font-bold">
								<a
									href="/practice-plans/{plan.id}"
									class="text-blue-600 hover:text-blue-800 block truncate"
									title={plan.name}
								>
									{plan.name}
								</a>
							</h2>
						</div>
						<div class="absolute right-0 top-0">
							<!-- UpvoteDownvote component usage remains the same -->
							<UpvoteDownvote practicePlanId={plan.id} />
						</div>
					</div>

					<!-- Rest of the card content remains the same -->
					{#if plan.phase_of_season}
						<p class="text-sm text-gray-500 mb-1">
							<strong>Phase of Season:</strong>
							{plan.phase_of_season}
						</p>
					{/if}
					{#if plan.estimated_number_of_participants}
						<p class="text-sm text-gray-500 mb-1">
							<strong>Estimated Participants:</strong>
							{plan.estimated_number_of_participants}
						</p>
					{/if}
					{#if plan.practice_goals && plan.practice_goals.length > 0}
						<p class="text-sm text-gray-500 mb-1 overflow-hidden">
							<strong>Practice Goals:</strong>
							<span class="inline-block truncate align-bottom max-w-full">
								{plan.practice_goals.join(', ')}
							</span>
						</p>
					{/if}

					<div class="flex justify-between items-center mt-4">
						<a
							href="/practice-plans/{plan.id}"
							class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded"
						>
							View Practice Plan
						</a>
						<!-- Pass callback to handle deletion in the current list -->
						<DeletePracticePlan
							planId={plan.id}
							createdBy={plan.created_by}
							on:delete={() => onPlanDeleted(plan.id)}
						/>
					</div>
				</div>
			{/each}
		</div>

		<!-- Pagination Controls -->
		{#if pagination && pagination.totalPages > 1}
			<Pagination
				currentPage={pagination.page}
				totalPages={pagination.totalPages}
				on:pageChange={handlePageChange}
			/>
		{/if}
	{:else if !error}
		<p class="text-center text-gray-500 mt-8">No practice plans found matching your criteria.</p>
	{/if}

	<!-- Mount the modal -->
	<AiPlanGeneratorModal
		bind:isOpen={showAiModal}
		skillOptions={data.skillOptions ?? []}
		focusAreaOptions={data.focusAreaOptions ?? []}
	/>
</div>
</file>

<file path="src/routes/+page.svelte">
<!-- Home Page -->

<script>
	import { goto } from '$app/navigation';
	import Spinner from '$lib/components/Spinner.svelte';
	let isNavigating = false;

	async function navigateToWizard() {
		isNavigating = true;
		try {
			await goto('/practice-plans');
		} finally {
			isNavigating = false;
		}
	}
</script>

<svelte:head>
	<title>QDrill - Practice Planning Made Easy</title>
	<meta name="description" content="Create and manage quadball drills and practice plans." />
</svelte:head>

<section class="container mx-auto px-4 sm:px-6 lg:px-8 py-12">
	<!-- Main Title Section -->
	<div class="flex flex-col lg:flex-row items-center">
		<!-- Left Side: Title and Blurb -->
		<div class="lg:w-1/2 text-center lg:text-left mb-8 lg:mb-0">
			<img
				src="/images/qdrill-pill.png"
				alt="QDrill Logo"
				class="mb-4 max-w-[150px] lg:max-w-[300px]"
				loading="eager"
				decoding="async"
			/>
			<p class="text-lg mb-6 dark:text-gray-300">
				Easily find, create, and share drills and practice plans. Focus on coaching, QDrill makes
				planning easy.
			</p>
			<div class="flex flex-col sm:flex-row sm:flex-wrap gap-4">
				<button
					on:click={navigateToWizard}
					disabled={isNavigating}
					class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg w-full sm:w-auto text-center relative"
				>
					{#if isNavigating}
						<div class="absolute inset-0 flex items-center justify-center">
							<Spinner size="sm" color="white" />
						</div>
						<span class="opacity-0">Create Practice Plan</span>
					{:else}
						Create Practice Plan
					{/if}
				</button>
				<div class="flex flex-row gap-4 w-full sm:w-auto">
					<a
						href="/drills"
						class="flex-1 sm:flex-none bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg text-center"
					>
						Browse Drills
					</a>
					<a
						href="/practice-plans"
						class="flex-1 sm:flex-none bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg text-center"
					>
						Browse Plans
					</a>
				</div>
			</div>
		</div>
		<!-- Right Side: Image -->
		<div class="lg:w-1/2 flex justify-center">
			<img
				src="/images/homepage-hero.jpg"
				width="1200"
				height="900"
				loading="eager"
				decoding="async"
				alt="Emma Sherwood asking a question at a Team Canada practice."
				class="w-full max-w-md h-auto object-contain"
			/>
		</div>
	</div>

	<!-- Features Section -->
	<div class="mt-16">
		<div class="grid grid-cols-1 md:grid-cols-2 gap-8">
			<!-- Wizard Feature (now AI Feature) -->
			<div
				class="bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 text-center flex flex-col h-full border-t-4 border-blue-500"
			>
				<div class="flex-grow">
					<div
						class="w-12 h-12 bg-blue-100 dark:bg-blue-900 rounded-lg flex items-center justify-center mx-auto mb-4"
					>
						<svg
							class="w-6 h-6 text-blue-600 dark:text-blue-400"
							fill="none"
							stroke="currentColor"
							viewBox="0 0 24 24"
						>
							<!-- Consider a more AI-themed icon later if desired -->
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								stroke-width="2"
								d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
							/>
						</svg>
					</div>
					<h3 class="text-xl font-semibold mb-2 dark:text-white">AI Plan Generator</h3>
					<p class="text-gray-600 dark:text-gray-300 mb-4">Have AI generate you a personalized practice plan.</p>
				</div>
				<div class="mt-auto">
					<a
						href="/practice-plans"
						class="inline-block bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg"
					>
						Generate with AI
					</a>
				</div>
			</div>

			<!-- Drills Library -->
			<div
				class="bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 text-center flex flex-col h-full border-t-4 border-green-500"
			>
				<div class="flex-grow">
					<div
						class="w-12 h-12 bg-green-100 dark:bg-green-900 rounded-lg flex items-center justify-center mx-auto mb-4"
					>
						<svg
							class="w-6 h-6 text-green-600 dark:text-green-400"
							fill="none"
							stroke="currentColor"
							viewBox="0 0 24 24"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								stroke-width="2"
								d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
							/>
						</svg>
					</div>
					<h3 class="text-xl font-semibold mb-2 dark:text-white">Drills Library</h3>
					<p class="text-gray-600 dark:text-gray-300 mb-4">
						Browse and search our growing collection of quadball drills.
					</p>
				</div>
				<div class="mt-auto">
					<a
						href="/drills"
						class="inline-block bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg"
					>
						Browse Drills
					</a>
				</div>
			</div>

			<!-- Community -->
			<div
				class="bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 text-center flex flex-col h-full border-t-4 border-purple-500"
			>
				<div class="flex-grow">
					<div
						class="w-12 h-12 bg-purple-100 dark:bg-purple-900 rounded-lg flex items-center justify-center mx-auto mb-4"
					>
						<svg
							class="w-6 h-6 text-purple-600 dark:text-purple-400"
							fill="none"
							stroke="currentColor"
							viewBox="0 0 24 24"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								stroke-width="2"
								d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
							/>
						</svg>
					</div>
					<h3 class="text-xl font-semibold mb-2 dark:text-white">Community</h3>
					<p class="text-gray-600 dark:text-gray-300 mb-4">
						Share drills and practice plans with the quadball community.
					</p>
				</div>
				<div class="mt-auto">
					<a
						href="https://discord.gg/yuXBkACYE3"
						target="_blank"
						rel="noopener noreferrer"
						class="inline-block bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg"
					>
						Join Discord
					</a>
				</div>
			</div>
		</div>
	</div>
</section>
</file>

<file path="package.json">
{
	"name": "sveltekit-2",
	"version": "0.0.1",
	"packageManager": "pnpm@10.11.0+sha512.6540583f41cc5f628eb3d9773ecee802f4f9ef9923cc45b69890fb47991d4b092964694ec3a4f738a420c918a333062c8b925d312f42e4f0c263eb603551f977",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./jsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./jsconfig.json --watch",
		"test": "(vitest run || true)",
		"test:unit": "vitest",
		"test:unit:run": "vitest run",
		"test:unit:coverage": "vitest run --coverage",
		"lint": "(prettier --check . || true) && (eslint . || true)",
		"format": "prettier --write .",
		"deploy": "vercel --prod",
		"tailwind:build": "tailwindcss build src/routes/styles.css -o public/build/tailwind.css",
		"tailwind:watch": "tailwindcss build src/routes/styles.css -o public/build/tailwind.css --watch",
		"migrate:create": "npx node-pg-migrate create",
		"migrate:up": "dotenv -e .env.local -- npx node-pg-migrate up",
		"migrate:auth:up": "dotenv -e .env.local -- npx @better-auth/cli migrate --config src/lib/auth.js",
		"migrate:down": "dotenv -e .env.local -- npx node-pg-migrate down"
	},
	"devDependencies": {
		"@eslint/eslintrc": "^1.4.0",
		"@eslint/js": "^8.44.0",
		"@fontsource/fira-mono": "^5.1.0",
		"@neoconfetti/svelte": "^2.2.1",
		"@playwright/test": "^1.54.2",
		"@sveltejs/adapter-vercel": "^5.4.8",
		"@sveltejs/kit": "^2.8.4",
		"@tailwindcss/typography": "^0.5.16",
		"@typescript-eslint/parser": "^5.62.0",
		"@vitest/coverage-v8": "2.0.0",
		"autoprefixer": "^10.4.20",
		"bits-ui": "^1.4.6",
		"c8": "^10.1.3",
		"clsx": "^2.1.1",
		"cypress": "^13.16.0",
		"dotenv": "^16.5.0",
		"dotenv-cli": "^8.0.0",
		"eslint": "^8.57.0",
		"eslint-config-prettier": "^8.10.0",
		"eslint-plugin-cypress": "^2.15.1",
		"eslint-plugin-svelte": "^2.34.0",
		"eslint-plugin-vitest-globals": "^1.5.0",
		"node-pg-migrate": "8.0.0-rc.2",
		"pnpm": "^9.14.2",
		"postcss": "^8.4.49",
		"postcss-nesting": "^13.0.1",
		"prettier": "^3.5.3",
		"prettier-plugin-svelte": "^3.3.2",
		"svelte": "^5.2.9",
		"svelte-check": "^4.1.0",
		"tailwind-merge": "^3.2.0",
		"tailwind-variants": "^1.0.0",
		"tailwindcss": "^3.4.15",
		"ts-node": "^10.9.2",
		"typescript": "^5.7.2",
		"vite": "^6.0.0",
		"vitest": "2.0.0",
		"web-vitals": "^4.2.4"
	},
	"dependencies": {
		"@ai-sdk/anthropic": "^1.2.11",
		"@ai-sdk/google-vertex": "^2.2.21",
		"@ai-sdk/openai": "^1.3.22",
		"@anthropic-ai/sdk": "^0.40.1",
		"@dnd-kit/core": "^6.2.0",
		"@excalidraw/excalidraw": "^0.17.6",
		"@mapbox/node-pre-gyp": "^1.0.11",
		"@radix-ui/colors": "^3.0.0",
		"@sentry/sveltekit": "^9",
		"@sveltejs/vite-plugin-svelte": "^5.0.1",
		"@sveltejs/vite-plugin-svelte-inspector": "^4.0.1",
		"@tinymce/tinymce-svelte": "^3.0.0",
		"@types/node": "^22.10.0",
		"@vercel/analytics": "^1.4.1",
		"@vercel/edge-config": "^1.4.0",
		"@vercel/postgres": "^0.10.0",
		"@vercel/speed-insights": "^1.1.0",
		"@zerodevx/svelte-toast": "^0.9.6",
		"ai": "^4.3.15",
		"aws-sdk": "^2.1692.0",
		"better-auth": "^1.2.7",
		"cmdk-sv": "^0.0.19",
		"csv-parse": "^5.6.0",
		"dompurify": "^3.2.5",
		"fabric": "^6.5.1",
		"isomorphic-dompurify": "^2.26.0",
		"jsdom": "^26.1.0",
		"knex": "^3.1.0",
		"kysely": "^0.28.0",
		"lodash": "^4.17.21",
		"lodash-es": "^4.17.21",
		"lucide-svelte": "^0.507.0",
		"mock-aws-s3": "^4.0.2",
		"mode-watcher": "^1.1.0",
		"nock": "^13.5.6",
		"papaparse": "^5.5.2",
		"pg": "^8.13.1",
		"react": "^18.3.1",
		"react-dom": "^18.3.1",
		"svelte-dnd-action": "^0.9.52",
		"svelte-forms-lib": "^2.0.1",
		"svelte-range-slider-pips": "^3.1.4",
		"svelte-routing": "^2.13.0",
		"sveltekit-superforms": "^2.27.1",
		"tabbable": "^6.2.0",
		"uuid": "^11.0.3",
		"yup": "^1.4.0",
		"zod": "^3.24.3"
	},
	"type": "module"
}
</file>

<file path="src/routes/drills/+page.svelte">
<!-- src/routes/drills/+page.svelte -->
<script>
	import FilterPanel from '$lib/components/FilterPanel.svelte';
	import { cart } from '$lib/stores/cartStore';
	import { onMount } from 'svelte';
	import { SvelteToast, toast } from '@zerodevx/svelte-toast';
	import { selectedSortOption, selectedSortOrder } from '$lib/stores/sortStore.js';
	import UpvoteDownvote from '$lib/components/UpvoteDownvote.svelte';
	import { dev } from '$app/environment';
	import { page } from '$app/stores';
	import { goto, invalidate } from '$app/navigation';
import { navigating } from '$app/stores';
import { onDestroy } from 'svelte';
	import { FILTER_STATES } from '$lib/constants';
    import { apiFetch } from '$lib/utils/apiFetch.js';
    import { sanitizeHtml } from '$lib/utils/sanitize.js';
	import SkeletonLoader from '$lib/components/SkeletonLoader.svelte';

	// Import only necessary stores (filter/sort state)
	import {
		currentPage,
		totalPages,
		drillsPerPage,
		searchQuery,
		selectedSkillLevels,
		selectedComplexities,
		selectedSkillsFocusedOn,
		selectedPositionsFocusedOn,
		selectedNumberOfPeopleMin,
		selectedNumberOfPeopleMax,
		selectedSuggestedLengthsMin,
		selectedSuggestedLengthsMax,
		selectedHasVideo,
		selectedHasDiagrams,
		selectedHasImages,
		selectedDrillTypes
	} from '$lib/stores/drillsStore';

	import Pagination from '$lib/components/Pagination.svelte';

export let data;

let isNavigating = false;
const unsubNavigating = navigating.subscribe((v) => (isNavigating = !!v));
onDestroy(unsubNavigating);

	// Filter options from load
	$: filterOptions = data.filterOptions || {};
	
	// Check if user is admin
	$: isAdmin = $page.data.session?.user?.role === 'admin';

	// Object to hold temporary button states ('added', 'removed', or null)
	let buttonStates = {};

	// Reactive set of drill IDs currently in the cart
	$: drillsInCart = new Set(($cart || []).map((d) => d.id));

	// Initialize buttonStates based on data.items
	$: {
		if (data && data.items) {
			// Create a new buttonStates object without reading from the existing one
			const newButtonStates = {};
			data.items.forEach(drill => {
				// Check if we already have a temporary state (added/removed)
				const existingState = buttonStates[drill.id];
				if (existingState === 'added' || existingState === 'removed') {
					// Keep temporary states
					newButtonStates[drill.id] = existingState;
				} else {
					// Set state based on cart contents
					newButtonStates[drill.id] = drillsInCart.has(drill.id) ? 'in-cart' : null;
				}
			});
			buttonStates = newButtonStates;
		}
	}

	// Initialize filter stores from URL search params on mount or when URL changes
	$: {
		if ($page.url.searchParams) {
			const params = $page.url.searchParams;

			// Helper to parse comma-separated params into store object
			const parseCommaSeparatedToStore = (paramName, store) => {
				const values =
					params
						.get(paramName)
						?.split(',')
						.map((t) => t.trim())
						.filter((t) => t) || [];
				const newState = {};
				values.forEach((v) => {
					newState[v] = FILTER_STATES.REQUIRED;
				}); // Assume URL values mean REQUIRED
				store.set(newState);
			};

			// Helper to parse simple param into store
			const parseSimpleParamToStore = (
				paramName,
				store,
				defaultValue = null,
				parser = (v) => v
			) => {
				store.set(params.has(paramName) ? parser(params.get(paramName)) : defaultValue);
			};

			const parseBooleanParamToStore = (paramName, store) => {
				const value = params.get(paramName)?.toLowerCase();
				store.set(value === 'true' ? true : value === 'false' ? false : null);
			};

			parseCommaSeparatedToStore('skillLevel', selectedSkillLevels);
			parseCommaSeparatedToStore('complexity', selectedComplexities);
			parseCommaSeparatedToStore('skills', selectedSkillsFocusedOn);
			parseCommaSeparatedToStore('positions', selectedPositionsFocusedOn);
			parseCommaSeparatedToStore('types', selectedDrillTypes);

			parseSimpleParamToStore('minPeople', selectedNumberOfPeopleMin, null, parseInt);
			parseSimpleParamToStore('maxPeople', selectedNumberOfPeopleMax, null, parseInt);
			parseSimpleParamToStore('minLength', selectedSuggestedLengthsMin, null, parseInt);
			parseSimpleParamToStore('maxLength', selectedSuggestedLengthsMax, null, parseInt);
			parseSimpleParamToStore('q', searchQuery, '');

			parseBooleanParamToStore('hasVideo', selectedHasVideo);
			parseBooleanParamToStore('hasDiagrams', selectedHasDiagrams);
			parseBooleanParamToStore('hasImages', selectedHasImages);

			// Initialize sort stores
			selectedSortOption.set(params.get('sort') || 'date_created');
			selectedSortOrder.set(params.get('order') || 'desc');

			// Update pagination stores from data (might be slightly delayed vs URL, but reflects loaded data)
			currentPage.set(data.pagination?.page || 1);
			totalPages.set(data.pagination?.totalPages || 1);
			drillsPerPage.set(parseInt(params.get('limit') || '10'));
		}
	}

	// Functions to navigate pages
	let debounceTimer;
	function debounce(func, delay = 300) {
		clearTimeout(debounceTimer);
		debounceTimer = setTimeout(func, delay);
	}

	function applyFiltersAndNavigate({ resetPage = false } = {}) {
		const params = new URLSearchParams(); // Start fresh

		// Pagination
		const pageToNavigate = resetPage ? 1 : $page.url.searchParams.get('page') || 1;
		params.set('page', pageToNavigate.toString());
		params.set('limit', $drillsPerPage.toString());

		// Sorting
		if ($selectedSortOption && $selectedSortOption !== 'date_created') {
			// Only add if not default
			params.set('sort', $selectedSortOption);
		}
		if ($selectedSortOrder && $selectedSortOrder !== 'desc') {
			// Only add if not default
			params.set('order', $selectedSortOrder);
		}

		// Filters
		// Helper to set params for comma-separated values from filter store objects
		const updateCommaSeparatedParam = (paramName, storeValue) => {
			const values = Object.entries(storeValue || {})
				.filter(([, state]) => state === FILTER_STATES.REQUIRED) // Only add REQUIRED filters to URL
				.map(([key]) => key);
			if (values.length > 0) {
				params.set(paramName, values.join(','));
			}
		};

		// Helper to set params for simple values (considering default)
		const updateSimpleParam = (paramName, value, defaultValue = undefined) => {
			if (value !== null && value !== undefined && value !== defaultValue) {
				params.set(paramName, value.toString());
			}
		};

		const updateBooleanParam = (paramName, value) => {
			if (value !== null) {
				// Add if true or false, ignore null
				params.set(paramName, value.toString());
			}
		};

		updateCommaSeparatedParam('skillLevel', $selectedSkillLevels);
		updateCommaSeparatedParam('complexity', $selectedComplexities);
		updateCommaSeparatedParam('skills', $selectedSkillsFocusedOn);
		updateCommaSeparatedParam('positions', $selectedPositionsFocusedOn);
		updateCommaSeparatedParam('types', $selectedDrillTypes);

		// Range params – only include if they differ from the defaults
		const defaultMinPeople = filterOptions.numberOfPeopleOptions?.min ?? 0;
		const defaultMaxPeople = filterOptions.numberOfPeopleOptions?.max ?? 100;
		const defaultMinLength = filterOptions.suggestedLengths?.min ?? 0;
		const defaultMaxLength = filterOptions.suggestedLengths?.max ?? 120;

		updateSimpleParam('minPeople', $selectedNumberOfPeopleMin, defaultMinPeople);
		updateSimpleParam('maxPeople', $selectedNumberOfPeopleMax, defaultMaxPeople);
		updateSimpleParam('minLength', $selectedSuggestedLengthsMin, defaultMinLength);
		updateSimpleParam('maxLength', $selectedSuggestedLengthsMax, defaultMaxLength);

		updateBooleanParam('hasVideo', $selectedHasVideo);
		updateBooleanParam('hasDiagrams', $selectedHasDiagrams);
		updateBooleanParam('hasImages', $selectedHasImages);

		// Pass null for searchQuery if it's empty to avoid adding '?q='
		updateSimpleParam('q', $searchQuery === '' ? null : $searchQuery);

		goto(`/drills?${params.toString()}`, { keepFocus: true, noScroll: true });
	}

	function handlePageChange(event) {
		const newPage = event.detail.page;
		if (newPage >= 1 && newPage <= (data.pagination?.totalPages || 1)) {
			const params = new URLSearchParams($page.url.searchParams);
			params.set('page', newPage.toString());
			goto(`/drills?${params.toString()}`, { keepFocus: true, noScroll: true });
		}
	}

	function handleSearchInput() {
		debounce(() => applyFiltersAndNavigate({ resetPage: true }));
	}

	function handleSortChange(event) {
		selectedSortOption.set(event.target.value);
		applyFiltersAndNavigate({ resetPage: true });
	}

	function toggleSortOrder() {
		selectedSortOrder.update((order) => (order === 'asc' ? 'desc' : 'asc'));
		applyFiltersAndNavigate({ resetPage: true });
	}

	// Function to handle adding/removing drills from the cart
	async function toggleDrillInCart(drill) {
		const isInCart = drillsInCart.has(drill.id);
		if (isInCart) {
			cart.removeDrill(drill.id);
			buttonStates = { ...buttonStates, [drill.id]: 'removed' };
		} else {
			cart.addDrill(drill);
			buttonStates = { ...buttonStates, [drill.id]: 'added' };
		}
		// No need for second buttonStates = { ...buttonStates };
		setTimeout(() => {
			// Update state based on actual cart status after timeout
			buttonStates = {
				...buttonStates,
				[drill.id]: ($cart || []).some((d) => d.id === drill.id) ? 'in-cart' : null
			};
		}, 500);
	}

	import { slide } from 'svelte/transition';

	let showSortOptions = false;
	let sortOptionsRef;

	onMount(() => {
		const handleClickOutside = (event) => {
			if (sortOptionsRef && !sortOptionsRef.contains(event.target)) {
				showSortOptions = false;
			}
		};
		document.addEventListener('click', handleClickOutside);
		return () => {
			document.removeEventListener('click', handleClickOutside);
		};
	});

	function toggleSortOptions(event) {
		event.stopPropagation();
		showSortOptions = !showSortOptions;
	}

	async function deleteDrill(drillId, event) {
		event.stopPropagation();

		if (!confirm('Are you sure you want to delete this drill? This action cannot be undone.')) {
			return;
		}

		try {
			// Use apiFetch for the DELETE request
			await apiFetch(`/api/drills/${drillId}`, {
				method: 'DELETE'
			});

			// apiFetch throws on error, so if we get here, it was successful
			toast.push('Drill deleted successfully', {
				theme: { '--toastBackground': '#48bb78', '--toastColor': '#fff' }
			});

			// Invalidate the data to refresh the list
			invalidate('app:drills'); // Assuming you have a layout load function that depends on this
			// Alternatively, force a page reload or manually remove the item from the UI
			// data.items = data.items.filter(d => d.id !== drillId);
		} catch (error) {
			console.error('Error deleting drill:', error);
			toast.push(`Failed to delete drill: ${error.message}`, {
				theme: { '--toastBackground': '#f56565', '--toastColor': '#fff' }
			});
		}
	}

	// Define sort options for drills
	const sortOptions = [
		{ value: 'date_created', label: 'Date Created' },
		{ value: 'name', label: 'Name' },
		{ value: 'complexity', label: 'Complexity' },
		{ value: 'suggested_length', label: 'Suggested Length' }
	];
</script>

<svelte:head>
	<title>Drills - QDrill</title>
	<meta name="description" content="Browse and manage drills for your practice plans." />
</svelte:head>

<div class="max-w-7xl mx-auto p-4">
	<div class="flex justify-between items-center mb-4">
		<h1 class="text-3xl font-bold">Drills</h1>
		<div class="flex space-x-4">
			<a
				href="/drills/create"
				class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition-colors duration-300"
			>
				Create Drill
			</a>
			<a
				href="/practice-plans/create"
				class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors duration-300"
			>
				Create Practice Plan with {($cart || []).length} Drill{($cart || []).length !== 1 ? 's' : ''}
			</a>
		</div>
	</div>

	<!-- Filter Panel -->
	<FilterPanel
		customClass="mb-6"
		filterType="drills"
		skillLevels={filterOptions.skillLevels || []}
		complexities={filterOptions.complexities || []}
		skillsFocusedOn={filterOptions.skillsFocusedOn || []}
		positionsFocusedOn={filterOptions.positionsFocusedOn || []}
		numberOfPeopleOptions={filterOptions.numberOfPeopleOptions || { min: 0, max: 100 }}
		suggestedLengths={filterOptions.suggestedLengths || { min: 0, max: 120 }}
		drillTypes={filterOptions.drillTypes || []}
		on:filterChange={() => applyFiltersAndNavigate({ resetPage: true })}
	/>

	<!-- Sorting Section and Search Input -->
	<div class="mb-6 flex items-center space-x-4">
		<div class="relative">
			<button
				class="px-4 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg shadow-sm hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-300 flex items-center"
				on:click={toggleSortOptions}
			>
				<span class="font-semibold mr-2">Sort</span>
				<span class="transform transition-transform duration-300" class:rotate-180={showSortOptions}
					>▼</span
				>
			</button>
			{#if showSortOptions}
				<div
					bind:this={sortOptionsRef}
					transition:slide={{ duration: 300 }}
					class="absolute left-0 mt-2 p-4 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-sm z-10"
				>
					<div class="flex flex-col space-y-2">
						<select
							class="p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 dark:text-gray-200"
							on:change={handleSortChange}
							value={$selectedSortOption}
							data-testid="sort-select"
						>
							{#each sortOptions as option}
								<option value={option.value}>{option.label}</option>
							{/each}
						</select>
						<button
							class="px-4 py-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors duration-300 dark:text-gray-200"
							on:click={toggleSortOrder}
							data-testid="sort-order-toggle"
						>
							{$selectedSortOrder === 'asc' ? '↑ Ascending' : '↓ Descending'}
						</button>
					</div>
				</div>
			{/if}
		</div>

		<input
			type="text"
			placeholder="Search drills..."
			class="flex-grow p-3 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 dark:text-gray-200"
			bind:value={$searchQuery}
			on:input={handleSearchInput}
			aria-label="Search drills"
			data-testid="search-input"
		/>
	</div>

	<!-- Loading and Empty States -->
       {#if isNavigating && !data.items}
		<!-- Skeleton loaders for drills -->
		<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
			{#each Array(6) as _, i}
				<SkeletonLoader 
					lines={4} 
					showCard={true}
					showButton={true}
					className="h-64"
				/>
			{/each}
		</div>
	{:else if !data.items || data.items.length === 0}
		<p class="text-center text-gray-500 dark:text-gray-400 py-10">No drills match your criteria.</p>
	{:else}
		<!-- Drills Grid -->
		<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
			{#each data.items as drill (drill.id)}
				<div
					class="border border-gray-200 bg-white dark:bg-gray-800 rounded-lg shadow-md transition-transform transform hover:-translate-y-1 hover:shadow-lg flex flex-col"
					data-testid="drill-card"
				>
					<div class="p-6 flex flex-col h-full relative">
						<!-- Top-right actions: Vote and Delete -->
						<div class="absolute top-2 right-2 flex items-start space-x-2">
							<!-- Vote component -->
							<UpvoteDownvote drillId={drill.id} />

							<!-- Conditional Delete Button -->
							{#if dev || isAdmin || drill.created_by === $page.data.session?.user?.id}
								<button
									on:click={(e) => deleteDrill(drill.id, e)}
									class="text-gray-500 dark:text-gray-400 hover:text-red-500 transition-colors duration-300 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700"
									title="Delete drill"
									aria-label="Delete drill"
								>
									<svg
										xmlns="http://www.w3.org/2000/svg"
										class="h-5 w-5"
										fill="none"
										viewBox="0 0 24 24"
										stroke="currentColor"
									>
										<path
											stroke-linecap="round"
											stroke-linejoin="round"
											stroke-width="2"
											d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
										/>
									</svg>
								</button>
							{/if}
						</div>

						<!-- Variation badges (moved slightly to avoid overlap if actions are wide) -->
						{#if drill.variation_count > 0}
							<div class="absolute top-2 left-2">
								<span class="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded">
									{drill.variation_count} variation{drill.variation_count !== 1 ? 's' : ''}
								</span>
							</div>
						{:else if drill.parent_drill_id}
							<div class="absolute top-2 left-2">
								<span class="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded">
									Variant
								</span>
							</div>
						{/if}

						<!-- Main content area -->
						<div class="flex-grow mb-4">
							<!-- Title and description -->
							<div class="flex justify-between items-start mb-4">
								<div class="flex-grow mr-16 min-w-0">
									<!-- Added mr-16 to give space for top-right actions -->
									<h2
										class="text-xl font-bold text-gray-800 dark:text-gray-200 overflow-hidden"
										data-testid="drill-card-name"
									>
										<a
											href="/drills/{drill.id}"
											class="hover:text-blue-600 block overflow-hidden truncate"
											title={drill.name}
										>
											{drill.name}
										</a>
									</h2>
									<div class="prose prose-sm dark:prose-invert mt-2 text-gray-600 dark:text-gray-300 max-h-24 overflow-hidden">
                    {@html sanitizeHtml(drill.brief_description)}
									</div>
								</div>
							</div>

							<!-- Drill details -->
							{#if drill.skill_level && drill.skill_level.length > 0}
								<p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
									<span class="font-medium">Skill:</span>
									{drill.skill_level.join(', ')}
								</p>
							{/if}
							{#if drill.complexity}
								<p class="text-sm text-gray-500 dark:text-gray-400 mt-1">
									<span class="font-medium">Complexity:</span>
									{drill.complexity}
								</p>
							{/if}
							{#if drill.suggested_length_min !== null && drill.suggested_length_min !== undefined}
								<p class="text-sm text-gray-500 dark:text-gray-400 mt-1" data-testid="drill-card-duration">
									<span class="font-medium">Duration:</span>
									{#if drill.suggested_length_max !== null && drill.suggested_length_max !== undefined && drill.suggested_length_max > drill.suggested_length_min}
										{drill.suggested_length_min} - {drill.suggested_length_max} mins
									{:else}
										{drill.suggested_length_min} mins
									{/if}
								</p>
							{/if}
							{#if drill.number_of_people_min !== undefined && drill.number_of_people_min !== null}
								<p class="text-sm text-gray-500 dark:text-gray-400 mt-1">
									<span class="font-medium">People:</span>
									{drill.number_of_people_min}
									{#if drill.number_of_people_max && drill.number_of_people_max !== drill.number_of_people_min}
										- {drill.number_of_people_max}
									{:else if !drill.number_of_people_max}
										+
									{/if}
								</p>
							{/if}
						</div>

						<!-- Add to Practice Plan button -->
						<div class="mt-auto">
							<button
								class="w-full py-2 px-4 rounded-md font-semibold text-white transition-colors duration-300"
								class:bg-green-500={buttonStates[drill.id] === 'added'}
								class:hover:bg-green-600={buttonStates[drill.id] === 'added'}
								class:bg-red-500={buttonStates[drill.id] === 'removed' ||
									buttonStates[drill.id] === 'in-cart'}
								class:hover:bg-red-600={buttonStates[drill.id] === 'removed' ||
									buttonStates[drill.id] === 'in-cart'}
								class:bg-blue-500={!drillsInCart.has(drill.id) &&
									buttonStates[drill.id] !== 'added' &&
									buttonStates[drill.id] !== 'removed' &&
									buttonStates[drill.id] !== 'in-cart'}
								class:hover:bg-blue-600={!drillsInCart.has(drill.id) &&
									buttonStates[drill.id] !== 'added' &&
									buttonStates[drill.id] !== 'removed' &&
									buttonStates[drill.id] !== 'in-cart'}
								on:click|stopPropagation={() => toggleDrillInCart(drill)}
							>
								{#if buttonStates[drill.id] === 'added'}
									Added
								{:else if buttonStates[drill.id] === 'removed'}
									Removed
								{:else if buttonStates[drill.id] === 'in-cart'}
									Remove from Plan
								{:else}
									Add to Plan
								{/if}
							</button>
						</div>
					</div>
				</div>
			{/each}
		</div>

		<!-- Pagination Controls -->
		{#if data.pagination && data.pagination.totalPages > 1}
			<Pagination
				currentPage={data.pagination.page}
				totalPages={data.pagination.totalPages}
				on:pageChange={handlePageChange}
			/>
		{/if}
	{/if}
</div>
<!-- Toast Notifications -->
<SvelteToast />
</file>

</files>
