This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/lib/server/db.js, src/lib/server/errors.js, src/lib/server/services/baseEntityService.js, src/lib/server/services/drillService.js, src/lib/server/services/practicePlanService.js, src/lib/server/services/formationService.js, src/lib/server/services/userService.js, src/routes/api/drills/+server.js, src/routes/api/drills/[id]/+server.js, src/routes/api/practice-plans/+server.js, src/routes/api/practice-plans/[id]/+server.js, docs/implementation/service-layer.md
- Files matching these patterns are excluded: **/*.test.js, **/*.spec.js, **/__tests__/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
QDrill BaseEntityService ↔ Kysely Unification Context (~55k tokens)

This package is focused on the service/data-access architecture decision:
- BaseEntityService raw-SQL CRUD + Kysely search helpers
- Representative entity services that extend BaseEntityService
- Kysely-heavy list/search services (Drills, Practice Plans)
- DB layer exports (pool + Kysely)
- Representative API routes showing current usage patterns
- Service-layer documentation relevant to migration

</user_provided_header>

<directory_structure>
docs/
  implementation/
    service-layer.md
src/
  lib/
    server/
      services/
        baseEntityService.js
        drillService.js
        formationService.js
        practicePlanService.js
        userService.js
      db.js
      errors.js
  routes/
    api/
      drills/
        [id]/
          +server.js
        +server.js
      practice-plans/
        [id]/
          +server.js
        +server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/implementation/service-layer.md">
# Service Layer Architecture

This document describes the service layer architecture implemented for QDrill. The service layer provides a clean separation between API endpoints and database operations, improving code organization, reusability, and maintainability.

_(Note: A [recent code review](../code-review/holistic-summary.md) evaluated the service layer implementation. Key findings include limitations in the `BaseEntityService`'s filtering capabilities and permission model rigidity, leading to inheriting services often bypassing it with direct DB calls or complex overrides. Some services contain highly complex logic (`DrillService`, `PracticePlanService`), potential normalization inconsistencies (e.g., JSON handling), and performance concerns (`UserService.getUserProfile`). The hardcoded admin check in `UserService` and its redundant permission logic were also noted. While the pattern provides benefits, addressing these limitations and ensuring consistent usage across all entities is recommended.)_

## Overview

The service layer pattern centralizes business logic and data access in specialized service classes, separating these concerns from the API routes. This architecture was first implemented with the Formations feature and provides a blueprint for future development.

## Key Components

### BaseEntityService

The `BaseEntityService` class provides a foundation for entity-specific services with common CRUD operations:

```javascript
export class BaseEntityService {
	constructor(tableName, primaryKey = 'id', defaultColumns = ['*']) {
		this.tableName = tableName;
		this.primaryKey = primaryKey;
		this.defaultColumns = defaultColumns;
	}

	// Common operations like getAll, getById, create, update, delete
	async getAll(options = {}) {
		/* ... */
	}
	async getById(id, columns = this.defaultColumns) {
		/* ... */
	}
	async create(data) {
		/* ... */
	}
	async update(id, data) {
		/* ... */
	}
	async delete(id) {
		/* ... */
	}
	async exists(id) {
		/* ... */
	}
	async search(searchTerm, searchColumns, options = {}) {
		/* ... */
	}
}
```

### Entity-Specific Services

Entity-specific services extend the BaseEntityService and implement domain-specific functionality:

```javascript
export class FormationService extends BaseEntityService {
	constructor() {
		super('formations', 'id', ['*']);
	}

	// Formation-specific methods
	async createFormation(formationData, userId = null) {
		/* ... */
	}
	async updateFormation(id, formationData) {
		/* ... */
	}
	async searchFormations(searchTerm, options = {}) {
		/* ... */
	}

	// Helper methods
	normalizeFormationData(data) {
		/* ... */
	}
}
```

## Benefits

1. **Code Reusability**: Common operations are defined once in the base service
2. **Consistent Error Handling**: Standardized approach across all entities
3. **Simplified API Endpoints**: Routes focus on request/response handling, not data logic
4. **Improved Testability**: Service methods can be tested in isolation
5. **Cleaner Abstractions**: Clear separation of concerns
6. **Future Extensibility**: Easy to add new entity types following the same pattern

## Implementation Details

### Database Connection

All services use a shared database connection layer (`db.js`) for consistent handling:

```javascript
// Database connection from db.js
export async function query(text, params) {
	const client = await getPool().connect();
	try {
		const res = await client.query(text, params);
		return res;
	} catch (err) {
		console.error('Database query error:', err);
		throw err;
	} finally {
		client.release();
	}
}
```

### Full-Text Search (FTS)

To provide efficient text searching, the application utilizes PostgreSQL's full-text search capabilities. This involves:

1.  **`tsvector` Column**: Tables containing searchable text content (e.g., `drills`, `practice_plans`, `formations`) include a `search_vector` column of type `tsvector`.
2.  **Update Function & Trigger**: A PostgreSQL function (e.g., `update_drill_search_vector`) and a corresponding trigger (e.g., `drill_search_vector_update`) are created for each searchable table. These automatically update the `search_vector` column whenever relevant text fields (like `name`, `description`) are inserted or updated. The function uses `to_tsvector` and `setweight` to combine and rank different text fields.
3.  **GIN Index**: A GIN (Generalized Inverted Index) is created on the `search_vector` column (e.g., `idx_gin_drill_search_vector`) to significantly speed up full-text queries.
4.  **Service Layer Integration**: The `BaseEntityService.search` method (and custom queries like in `PracticePlanService.getAll`) uses the `@@` operator with `plainto_tsquery` (or `to_tsquery`) against the `search_vector` column, replacing inefficient `LIKE` queries. Relevance sorting is often applied using `ts_rank_cd`.

**Update (Ticket #20):** The core FTS logic (querying the `search_vector` column with `plainto_tsquery` and ranking with `ts_rank_cd`) has been centralized within the enhanced `BaseEntityService.search` method. Services like `DrillService`, `PracticePlanService`, and `FormationService` now leverage this base method, passing the search term and relying on the base implementation. They still require the underlying database setup (tsvector column, function, trigger, index).

**Note:** When adding new searchable entities or fields, ensure the corresponding table has the `search_vector` column, update function, trigger, and GIN index configured. Migration scripts should handle the initial population of the `search_vector` for existing rows.

### API Integration

API endpoints use service instances to handle business logic:

```javascript
// Example API endpoint using service layer
export async function GET({ url }) {
	const searchTerm = url.searchParams.get('q') || '';
	const page = parseInt(url.searchParams.get('page')) || 1;
	const limit = parseInt(url.searchParams.get('limit')) || 10;

	try {
		const result = await formationService.searchFormations(searchTerm, {
			page,
			limit
		});

		return json(result);
	} catch (error) {
		console.error('Error searching formations:', error);
		return json({ error: 'An error occurred', details: error.message }, { status: 500 });
	}
}
```

## Implementation Plan

### Priority Ranking (Impact vs. Difficulty)

1. **DrillService** - ⭐⭐⭐⭐⭐

   - Impact: High (core functionality, many endpoints, complex logic)
   - Effort: 4-5 days
   - Key benefits: Centralizes complex filtering, standardizes drill operations, addresses most duplicated code

2. **PracticePlanService** - ⭐⭐⭐⭐

   - Impact: High (complex entity relationships, timeline management)
   - Effort: 5-6 days
   - Key benefits: Separates timeline logic from API, improves transaction handling

3. **UserService** - ⭐⭐⭐

   - Impact: Medium-High (auth integration, permission management)
   - Effort: 2-3 days
   - Key benefits: Consistent permission checks, simplified API endpoints

4. **SkillService** - ⭐⭐

   - Impact: Medium (simpler model but frequent usage)
   - Effort: 1-2 days
   - Key benefits: Quick win with low complexity

5. **CommentService** - ⭐⭐

   - Impact: Medium (improves consistency in comment handling)
   - Effort: 1-2 days
   - Key benefits: Standardized CRUD operations, better validation

6. **VoteService** - ⭐
   - Impact: Medium-Low (limited functionality)
   - Effort: 1-2 days
   - Key benefits: Handles race conditions, standardizes voting operations

### Implementation Status

#### DrillService

**Implementation Status: Completed**

1. ✅ Created DrillService class extending BaseEntityService
2. ✅ Implemented drill-specific methods:
   ```javascript
   async createDrill(drillData, userId)
   async updateDrill(id, drillData, userId)
   async deleteDrill(id, userId)
   async getDrillWithVariations(id)
   async createVariation(parentId, variationData, userId)
   async searchDrills(searchTerm, options)
   async getFilteredDrills(filters, options)
   async getDrillNames()
   async setAsPrimaryVariant(drillId, userId)
   async canUserEditDrill(drillId, userId)
   async updateSkillCounts(skillsToAdd, skillsToRemove, drillId)
   async updateSkills(skills, drillId)
   ```
3. ✅ Implemented normalizeDrillData() with comprehensive validation
4. ✅ Added transaction support for variant operations
5. ✅ Added permission checks for edit/delete actions
6. ✅ Exported singleton instance for use across API endpoints
7. ✅ Added comprehensive unit tests with Vitest

**Next Steps:**

- Refactor remaining API endpoints to use the service:
  - `/api/drills/[id]/upvote/+server.js`
  - `/api/drills/[id]/set-variant/+server.js`
  - `/api/drills/associate/+server.js`
  - `/api/drills/filter-options/+server.js`
  - `/api/drills/bulk-upload/+server.js`
  - `/api/drills/import/+server.js`

**Dependencies:**

- BaseEntityService
- SkillService (for skill updates)

#### PracticePlanService

**Implementation Status: Completed**

1. ✅ Created PracticePlanService class extending BaseEntityService
2. ✅ Implemented integrated section management rather than separate services
3. ✅ Implemented practice plan-specific methods:
   ```javascript
   async getAll(options)
   async createPracticePlan(planData, userId)
   async getPracticePlanById(id, userId)
   async updatePracticePlan(id, planData, userId)
   async deletePracticePlan(id, userId)
   async duplicatePracticePlan(id, userId)
   async validatePracticePlan(plan)
   ```
4. ✅ Implemented helper methods for data formatting and calculations:
   ```javascript
   formatDrillItem(item);
   calculateSectionDuration(items);
   ```
5. ✅ Added transaction support for section and drill management
6. ✅ Added proper permission checks for view/edit/delete operations
7. ✅ Exported singleton instance for use across API endpoints
8. ✅ Refactored API endpoints to use the service
9. ✅ Added comprehensive unit tests with Vitest

**Next Steps:**

- Further refine timeline management logic

**Dependencies:**

- BaseEntityService
- DrillService (for drill references)

#### FormationService

**Implementation Status: Completed**

1. ✅ Created FormationService class extending BaseEntityService
2. ✅ Implemented formation-specific methods:
   ```javascript
   async createFormation(formationData, userId)
   async updateFormation(id, formationData)
   async searchFormations(searchTerm, options)
   async getFormationsByUser(userId, options)
   ```
3. ✅ Implemented normalizeFormationData() with validation
4. ✅ Exported singleton instance for use across API endpoints
5. ✅ Refactored API endpoints to use the service
6. ✅ Added unit tests for formation operations

**Dependencies:**

- BaseEntityService

#### UserService

**Implementation Status: Planned**

1. Create UserService class extending BaseEntityService
2. Implement user-specific methods:
   ```javascript
   async getUserByEmail(email)
   async getUserProfile(userId)
   async isAdmin(userId)
   async canUserPerformAction(userId, actionType, entityType, entityId)
   ```
3. Create integration with Auth.js
4. Refactor user-related API endpoints to use service

**Implementation Details:**

- Use Auth.js users table structure
- Build methods for retrieving user-created content
- Add admin role checking
- Create centralized permission management

**Dependencies:**

- BaseEntityService
- Auth.js integration

#### SkillService

**Implementation Status: Planned**

1. Create SkillService class extending BaseEntityService
2. Implement skill-specific methods:
   ```javascript
   async getAllSkills(options)
   async updateSkillCounts(skillsToAdd, skillsToRemove, drillId)
   async getSkillsForDrill(drillId)
   async getMostUsedSkills(limit)
   ```
3. Refactor drill-related skill operations to use this service

**Implementation Details:**

- Centralize skill management across drill operations
- Create methods for tracking usage statistics
- Add skill filtering and recommendation functionality

**Dependencies:**

- BaseEntityService

### Testing Benefits

- **Isolation**: Testing business logic separate from API endpoints
- **Mocking**: Database operations can be mocked more easily
- **Edge Cases**: Better testing of validation and error handling
- **Unit Tests**: Focused tests for service functions without API overhead
- **Integration Tests**: Simpler setup with standardized service interfaces

### Unit Testing Implementation

Unit tests have been implemented for all service layer classes using Vitest:

1. **BaseEntityService Tests**:

   - Constructor and initialization tests
   - Column validation and sort order tests
   - Array field normalization tests
   - Timestamp handling tests
   - Error handling and transaction management tests

2. **DrillService Tests**:

   - Data normalization tests
   - CRUD operations tests
   - Permission checking tests
   - Drill variation management tests
   - Skill association tests
   - Search and filtering tests
   - User authorization tests

3. **PracticePlanService Tests**:

   - Duration calculation tests with parallel timelines
   - Data formatting tests
   - Plan validation tests
   - Section management tests
   - Duplication logic tests
   - Timeline organization tests

4. **FormationService Tests**:
   - Data normalization tests
   - CRUD operations tests
   - Diagram data validation tests

Additionally, API endpoint tests have been implemented to test the integration between API routes and the service layer:

1. **Drill API Tests**:

   - GET/POST/PUT/DELETE endpoint tests
   - Search functionality tests
   - Variation management tests
   - Error handling tests

2. **Practice Plan API Tests**:
   - Plan creation and retrieval tests
   - Plan update and deletion tests
   - Plan duplication tests
   - Permission and authorization tests

All tests can be run using:

- `pnpm run test:unit:run` - Run all unit tests
- `pnpm run test:unit` - Run tests in watch mode
- `pnpm run test:unit:coverage` - Run tests with coverage reporting

### Implementation Approach

1. **Incremental Migration**:

   - Implement one service at a time
   - Keep dual implementation during transition
   - Test thoroughly before removing old code

2. **Common Patterns**:

   - Use consistent method naming across services
   - Follow the same error handling pattern
   - Return standardized response objects

3. **Transaction Management**:
   - Add transaction support for multi-entity operations
   - Ensure proper rollback on errors
   - Consider adding transaction management to BaseEntityService

## Immediate Next Steps

### 1. Complete DrillService API Integration

**Priority: High**
**Effort: 1-2 days**

- Refactor remaining drill API endpoints to use DrillService
- Focus on endpoints in `/api/drills/` that still use direct DB access
- Prioritize high-traffic endpoints (upvote, search, filter)
- Ensure consistent error handling across all endpoints

### 2. Implement UserService

**Priority: High**
**Effort: 2-3 days**

- Create UserService based on Auth.js integration
- Implement profile management functionality
- Create centralized permission checking methods
- Refactor user-related API endpoints

### 3. Implement SkillService

**Priority: Medium**
**Effort: 1-2 days**

- Create SkillService with skill management methods
- Refactor DrillService to use SkillService
- Implement skill statistics and recommendations

### 4. Enhance BaseEntityService

**Priority: Medium**
**Effort: 1-2 days**

- Add caching support for frequently accessed data
- Implement advanced filtering capabilities
- Add event emitters for entity lifecycle events
- Improve transaction management

## Future Improvements

1. **Caching Layer**: Implement caching for frequently accessed data
2. **Advanced Filtering**: Enhance query building for complex filter conditions
3. **Event System**: Add event emitters for entity lifecycle events (create, update, delete)
4. **API Documentation**: Generate OpenAPI documentation from service definitions
5. **Performance Optimization**: Add database indexing strategy and query optimization

## Best Practices

When using the service layer:

1. **Keep Services Focused**: Each service should represent a single entity type
2. **Use Dependency Injection**: Pass dependencies to services rather than creating them internally
3. **Maintain Singleton Instances**: Create a single instance of each service for better resource management
4. **Normalize Data**: Use service methods to normalize data before storing/returning
5. **Comprehensive Error Handling**: Handle and transform database errors into appropriate API responses
6. **Consistent Response Format**: Return standardized objects with pagination, metadata, and data
7. **Testable Units**: Design services to be easily testable with mock dependencies
</file>

<file path="src/lib/server/db.js">
// import pkg from 'pg';
// const { Pool } = pkg;
import { createPool } from '@vercel/postgres'; // Import Vercel's createPool
import { Kysely, PostgresDialect, sql } from 'kysely'; // Import Kysely, PostgresDialect, and sql

// Create a Vercel-managed pool instance
let pool;

function getPool() {
	if (!pool) {
		const connectionString = process.env.POSTGRES_URL || process.env.DATABASE_URL;

		if (connectionString) {
			// Create a real pool when a connection string is available (dev/production runtime)
			pool = createPool({ connectionString });
		} else {
			// Fail fast in production; allow a stub only for local/dev/test/build tooling
			if (process.env.NODE_ENV === 'production') {
				throw new Error(
					'Database connection string missing. Set POSTGRES_URL or DATABASE_URL.'
				);
			}
			console.warn(
				'[db] No connection string found; using stub pool. DB queries will return empty results.'
			);
			// Fallback stub during build or when running without DB access (e.g. CI, static analysis)
			pool = {
				async query() {
					return { rows: [], rowCount: 0 };
				},
				async connect() {
					return {
						query: async () => ({ rows: [], rowCount: 0 }),
						release: () => {}
					};
				},
				async end() {}
			};
		}
	}
	return pool;
}

// Export the pool instance directly for use in other modules
export const vercelPool = getPool();

// Create and export a Kysely instance configured with the Vercel pool
export const kyselyDb = new Kysely({
	dialect: new PostgresDialect({
		pool: vercelPool
	})
});

// Re-export sql from Kysely so other modules can import it from here
export { sql };

export async function query(text, params) {
	// Use the Vercel pool directly
	try {
		const res = await vercelPool.query(text, params); // Use exported pool
		return res;
	} catch (err) {
		console.error('Database query error:', err);
		throw err;
	}
	// No manual client connect/release needed for simple queries with pool.query()
}

// Update getClient to use Vercel pool's connect method
export async function getClient() {
	return vercelPool.connect(); // Use exported pool
}

// Update end function
export async function end() {
	// Check the original variable, not the export
	if (pool) {
		await pool.end(); // Use the internal pool variable to end
		pool = null;
	}
}

// Alias for compatibility with hooks.server.js
export const cleanup = end;
</file>

<file path="src/lib/server/errors.js">
/**
 * @typedef {'NOT_FOUND' | 'UNAUTHORIZED' | 'FORBIDDEN' | 'VALIDATION_ERROR' | 'DATABASE_ERROR' | 'INTERNAL_SERVER_ERROR' | 'CONFLICT'} ErrorCode
 */

/**
 * Base class for custom application errors.
 * Includes an HTTP status code and a machine-readable error code.
 */
export class AppError extends Error {
	/** @type {number} */
	status;
	/** @type {ErrorCode} */
	code;

	/**
	 * @param {string} message - The human-readable error message.
	 * @param {number} status - The HTTP status code associated with the error.
	 * @param {ErrorCode} code - The machine-readable error code.
	 */
	constructor(message, status, code) {
		super(message);
		this.name = this.constructor.name;
		this.status = status;
		this.code = code;
	}
}

/**
 * Error for when a requested resource is not found.
 */
export class NotFoundError extends AppError {
	/**
	 * @param {string} [message='Resource not found'] - The error message.
	 */
	constructor(message = 'Resource not found') {
		super(message, 404, 'NOT_FOUND');
	}
}

/**
 * Error for when an action requires authentication, but the user is not logged in.
 */
export class UnauthorizedError extends AppError {
	/**
	 * @param {string} [message='Authentication required'] - The error message.
	 */
	constructor(message = 'Authentication required') {
		super(message, 401, 'UNAUTHORIZED');
	}
}

/**
 * Error for when a user is authenticated but does not have permission to perform an action.
 */
export class ForbiddenError extends AppError {
	/**
	 * @param {string} [message='You do not have permission to perform this action'] - The error message.
	 */
	constructor(message = 'You do not have permission to perform this action') {
		super(message, 403, 'FORBIDDEN');
	}
}

/**
 * Error for when user input fails validation.
 */
export class ValidationError extends AppError {
	/**
	 * @param {string} [message='Input validation failed'] - The error message.
	 * @param {Record<string, string> | null} [details=null] - Optional details about validation errors per field.
	 */
	constructor(message = 'Input validation failed', details = null) {
		super(message, 400, 'VALIDATION_ERROR');
		/** @type {Record<string, string> | null} */
		this.details = details; // Optional: Add specific field errors if needed
	}
}

/**
 * Error for general database operation failures.
 */
export class DatabaseError extends AppError {
	/**
	 * @param {string} [message='A database error occurred'] - The error message.
	 * @param {Error | null} [cause=null] - The original error that caused this one.
	 */
	constructor(message = 'A database error occurred', cause = null) {
		super(message, 500, 'DATABASE_ERROR');
		if (cause) {
			this.cause = cause;
		}
	}
}

/**
 * Error for conflicts, e.g., trying to create a resource that already exists.
 */
export class ConflictError extends AppError {
	/**
	 * @param {string} [message='Conflict detected'] - The error message.
	 */
	constructor(message = 'Conflict detected') {
		super(message, 409, 'CONFLICT');
	}
}

/**
 * Generic fallback error.
 */
export class InternalServerError extends AppError {
	/**
	 * @param {string} [message='An unexpected internal server error occurred'] - The error message.
	 * @param {Error | null} [cause=null] - The original error that caused this one.
	 */
	constructor(message = 'An unexpected internal server error occurred', cause = null) {
		super(message, 500, 'INTERNAL_SERVER_ERROR');
		if (cause) {
			this.cause = cause;
		}
	}
}
</file>

<file path="src/routes/api/drills/[id]/+server.js">
import { json, error as svelteKitError } from '@sveltejs/kit';
import { drillService } from '$lib/server/services/drillService';
import { dev } from '$app/environment';
import * as db from '$lib/server/db';
import { authGuard } from '$lib/server/authGuard';
import {
	NotFoundError,
	ForbiddenError,
	ValidationError,
	DatabaseError
} from '$lib/server/errors';
import { handleApiError } from '../../utils/handleApiError.js';

export async function GET({ params, locals, url }) {
	const { id } = params;
	const includeVariants = url.searchParams.get('includeVariants') === 'true';
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		let drill;
		if (includeVariants) {
			drill = await drillService.getDrillWithVariations(drillId, userId);
		} else {
			drill = await drillService.getById(drillId, drillService.defaultColumns, userId);
		}

		// Check visibility and ownership
		if (drill.visibility === 'private') {
			if (!userId || drill.created_by !== userId) {
				throw new ForbiddenError('Unauthorized to view this private drill');
			}
		}

		// If this is a variation, get the parent name
		if (drill.parent_drill_id && !drill.variations) {
			try {
				const parentDrill = await drillService.getById(
					drill.parent_drill_id,
					drillService.defaultColumns,
					userId
				);
				if (parentDrill) {
					drill.parent_drill_name = parentDrill.name;
				}
			} catch (parentErr) {
				if (parentErr instanceof NotFoundError) {
					console.warn(
						`Parent drill ID ${drill.parent_drill_id} not found for variation ${drill.id}`
					);
					drill.parent_drill_name = '[Parent Deleted]'; // Indicate parent is gone
				} else {
					throw parentErr; // Re-throw unexpected errors getting parent
				}
			}
		}

		return json(drill);
	} catch (err) {
		return handleApiError(err);
	}
}

// Wrap PUT handler with authGuard
export const PUT = authGuard(async ({ params, request, locals }) => {
	const { id } = params;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		const drillData = await request.json();

		// Basic validation
		if (!drillData.name || !drillData.brief_description) {
			throw new ValidationError('Required fields missing: name, brief_description');
		}

		// Use DrillService to update the drill (now also updates votes)
		const updatedDrill = await drillService.updateDrill(drillId, drillData, userId);

		return json(updatedDrill);
	} catch (err) {
		return handleApiError(err);
	}
});

// Define core delete logic (used by guarded handler)
const handleDelete = async ({ params, locals }) => {
	const { id } = params;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		// Pass userId for authorization check within the service
		const success = await drillService.deleteDrill(drillId, userId);

		if (!success) {
			// Service returns false if not found, true if deleted
			throw new NotFoundError(`Drill with ID ${drillId} not found for deletion.`);
		}

		return json({ message: 'Drill deleted successfully' }, { status: 200 });
	} catch (err) {
		// Catch FK constraint errors specifically if service doesn't handle them gracefully
		if (err?.code === '23503') {
			throw new DatabaseError('Cannot delete: drill is referenced by other items', err); // Wrap it
		}
		// Re-throw other errors to be handled by the main handler/helper
		throw err;
	}
};

// Export DELETE handler, applying authGuard only when not in dev mode
export const DELETE = async (event) => {
	try {
		const { id } = event.params;
		const session = event.locals.session;
		const userId = session?.user?.id || null; // Used for dev check

		const drillId = parseInt(id);
		if (!id || isNaN(drillId)) {
			throw new ValidationError('Invalid Drill ID format');
		}

		const allowDevBypass =
			dev &&
			process.env.ALLOW_DEV_DELETE_BYPASS === 'true' &&
			userId &&
			session?.user?.role === 'admin';

		if (allowDevBypass) {
			console.log(
				`[DEV MODE BYPASS] Attempting deletion for drill ${drillId} with related data.`
			);
			// Call the service method with deleteRelated: true
			// Pass userId (can be null) - service checks if drill.created_by === userId OR (drill.created_by === null AND deleteRelated)
			const result = await drillService.deleteDrill(drillId, userId, { deleteRelated: true });

			if (!result) {
				// Service handles not found case by returning false
				throw new NotFoundError(`Drill with ID ${drillId} not found for deletion (dev mode).`);
			}

			return json(
				{ success: true, message: 'Drill and related data deleted (dev mode)' },
				{ status: 200 }
			);
		} else {
			if (dev && process.env.ALLOW_DEV_DELETE_BYPASS === 'true' && session?.user?.role !== 'admin') {
				console.warn(
					`[DEV MODE BYPASS BLOCKED] ALLOW_DEV_DELETE_BYPASS enabled but user is not admin.`
				);
			}
			// In production, use the authGuard with the original handleDelete logic
			const guardedDelete = authGuard(handleDelete);
			return await guardedDelete(event); // Ensure guarded function is awaited
		}
	} catch (err) {
		return handleApiError(err);
	}
};
</file>

<file path="src/routes/api/drills/+server.js">
import { json, error as svelteKitError } from '@sveltejs/kit';
import { authGuard } from '$lib/server/authGuard';
import { drillService } from '$lib/server/services/drillService';
import { AppError, DatabaseError, ValidationError, NotFoundError } from '$lib/server/errors'; // Import NotFoundError
import { createDrillSchema, updateDrillSchema } from '$lib/validation/drillSchema'; // Import Zod schemas
import { handleApiError } from '../utils/handleApiError.js';
import { generateClaimToken } from '$lib/server/utils/claimTokens.js';

// Centralized error handler imported from ../utils/handleApiError.js

export const GET = async ({ url, locals }) => {
	// Get session info to pass userId for filtering
	const session = locals.session;
	const userId = session?.user?.id;

	// Pagination
	const page = parseInt(url.searchParams.get('page') || '1');
	const limit = parseInt(url.searchParams.get('limit') || '10');

	// Sorting
	const sortBy = url.searchParams.get('sort'); // e.g., 'name', 'date_created'
	const sortOrder = url.searchParams.get('order') || 'desc'; // 'asc' or 'desc'

	// Filters - Parse all specified filters from performance.md
	const filters = {};
	const parseCommaSeparated = (param) =>
		url.searchParams.has(param)
			? url.searchParams
					.get(param)
					.split(',')
					.map((t) => t.trim().toLowerCase())
					.filter((t) => t)
			: undefined;
	const toTitleCase = (value) =>
		typeof value === 'string' && value.length
			? value.charAt(0).toUpperCase() + value.slice(1)
			: value;

	filters.skill_level = parseCommaSeparated('skillLevel');
	const complexities = parseCommaSeparated('complexity');
	filters.complexity = complexities ? complexities.map(toTitleCase) : undefined;
	filters.skills_focused_on = parseCommaSeparated('skills');
	filters.positions_focused_on = parseCommaSeparated('positions');
	filters.drill_type = parseCommaSeparated('types');

	const minPeople = url.searchParams.get('minPeople');
	const maxPeople = url.searchParams.get('maxPeople');
	if (minPeople) filters.number_of_people_min = parseInt(minPeople);
	if (maxPeople) filters.number_of_people_max = parseInt(maxPeople);

	const minLength = url.searchParams.get('minLength');
	const maxLength = url.searchParams.get('maxLength');
	// Assuming suggested_length is stored in minutes (or some numeric unit)
	if (minLength) filters.suggested_length_min = parseInt(minLength);
	if (maxLength) filters.suggested_length_max = parseInt(maxLength);

	const parseBooleanFilter = (param) => {
		const value = url.searchParams.get(param)?.toLowerCase();
		return value === 'true' ? true : value === 'false' ? false : undefined;
	};
	filters.hasVideo = parseBooleanFilter('hasVideo');
	filters.hasDiagrams = parseBooleanFilter('hasDiagrams');
	filters.hasImages = parseBooleanFilter('hasImages');

	filters.searchQuery = url.searchParams.get('q');

	// Remove undefined filters
	Object.keys(filters).forEach((key) => filters[key] === undefined && delete filters[key]);

	// Build options objects for the service
	const options = {
		page,
		limit,
		sortBy,
		sortOrder,
		userId
	};

	try {
		// Call the enhanced getFilteredDrills method
		const result = await drillService.getFilteredDrills(filters, options);

		// Return structure matches the frontend expectation from Phase 2 plan
		return json(result);
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
};

export const POST = async (event) => {
	try {
		const rawData = await event.request.json();
		const session = event.locals.session;
		let userId = session?.user?.id || null;

		// Ensure userId is a number if it exists and is a string representation of a number
		if (userId && typeof userId === 'string') {
			const parsedUserId = parseInt(userId, 10);
			if (!isNaN(parsedUserId)) {
				userId = parsedUserId;
			} else {
				// Handle case where userId is a string but not a valid number - perhaps error or set to null
				console.warn(`Invalid string user ID found: ${userId}. Treating as null.`);
				userId = null;
			}
		}

		// Add userId to the data before validation if not present
		const dataWithUser = { ...rawData, created_by: userId };

		// Validate data using Zod schema
		// Use safeParse to handle validation errors explicitly
		const validationResult = createDrillSchema.safeParse(dataWithUser);

		if (!validationResult.success) {
			// Throw ZodError to be caught by handleApiError
			throw validationResult.error;
		}

		// Use the validated data
		const validatedData = validationResult.data;

		// Use the DrillService to create the drill
		const drill = await drillService.createDrill(validatedData, userId); // Pass validatedData

		// If created anonymously, issue a claim token so the creator can later associate ownership
		if (!userId && drill?.id) {
			drill.claimToken = generateClaimToken('drill', drill.id);
		}

		return json(drill, { status: 201 }); // Return 201 Created
	} catch (err) {
		// Renamed variable to err
		// Use the helper function
		return handleApiError(err);
	}
};

// PUT and DELETE are handled in src/routes/api/drills/[id]/+server.js
</file>

<file path="src/routes/api/practice-plans/[id]/+server.js">
import { json } from '@sveltejs/kit';
import { authGuard } from '$lib/server/authGuard';
import { dev } from '$app/environment';
import { practicePlanService } from '$lib/server/services/practicePlanService.js';
import { handleApiError } from '../../utils/handleApiError.js';

export async function GET({ params, locals }) {
	const id = params.id;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const practicePlan = await practicePlanService.getPracticePlanById(id, userId);
		return json(practicePlan);
	} catch (err) {
		return handleApiError(err);
	}
}

// Wrap PUT handler with authGuard
export const PUT = authGuard(async ({ params, request, locals }) => {
	const { id } = params;
	const plan = await request.json();
	const session = locals.session;
	const userId = session?.user?.id; // authGuard ensures session and user exist

	try {
		const updatedPlan = await practicePlanService.updatePracticePlan(id, plan, userId);
		return json(updatedPlan);
	} catch (err) {
		return handleApiError(err);
	}
});

// Define the core deletion logic as a separate async function
const handleDelete = async ({ params, locals }) => {
	const { id } = params;
	const session = locals.session;
	const userId = session?.user?.id;

	try {
		const result = await practicePlanService.deletePracticePlan(id, userId);
		return json({ success: true, message: 'Practice plan deleted successfully' });
	} catch (err) {
		return handleApiError(err);
	}
};

// Export the DELETE handler
// Wrap DELETE handler with authGuard for consistent authentication
export const DELETE = authGuard(async ({ params, locals }) => {
	const { id } = params;
	// Get session and userId from locals, populated by authGuard
	const session = locals.session;
	// Assuming authGuard ensures session and session.user exist, similar to PUT handler
	const userId = session?.user?.id;

	try {
		// Validate ID
		const planId = parseInt(id);
		if (isNaN(planId)) {
			return json({ error: 'Invalid practice plan ID' }, { status: 400 });
		}

		// Authentication check is now handled by authGuard, so the explicit 'if (!userId)' is removed.
		// authGuard is expected to ensure userId is valid or deny access.

		// Perform deletion
		await practicePlanService.deletePracticePlan(planId, userId);
		// Return 204 No Content on successful deletion
		return new Response(null, { status: 204 });
	} catch (err) {
		// Log the error in dev mode for debugging
		if (dev) {
			console.error('[API Delete Error]', err);
		}
		// Use the centralized error handler for all errors
		return handleApiError(err);
	}
});

// Dev-only delete handler (remove or secure properly)
// Note: This was likely for testing and should not exist in production.
// Keeping it commented out for now, but should be removed.
/*
const deleteHandlerDevOnly = async ({ params }) => {
  if (dev) {
    try {
      const id = parseInt(params.id);
      if (isNaN(id)) {
        return json({ error: 'Invalid practice plan ID (dev bypass)' }, { status: 400 });
      }
      // Bypass user check in dev
      await practicePlanService.deletePracticePlan(id, null); // DANGEROUS: using null user ID
      return new Response(null, { status: 204 }); // Consistent 204
    } catch (err) {
      console.error('[DEV MODE] Error deleting practice plan:', err);
      return handleApiError(err); // Use error handler here too
    }
  } else {
    // In production, this endpoint should not exist or return 404/403
    return json({ error: 'Not Found' }, { status: 404 });
  }
};
*/
</file>

<file path="src/lib/server/services/formationService.js">
import { BaseEntityService } from './baseEntityService.js';
import * as db from '$lib/server/db';
import {
	NotFoundError,
	DatabaseError,
	ConflictError,
	ValidationError,
	ForbiddenError
} from '$lib/server/errors';
import { kyselyDb, sql } from '$lib/server/db'; // Ensure sql is imported
import { dev } from '$app/environment';

/**
 * Service for managing formations
 * Extends the BaseEntityService with formation-specific functionality
 */
export class FormationService extends BaseEntityService {
	/**
	 * Creates a new FormationService
	 */
	constructor() {
		// Define allowed columns for the formations table
		const allowedFormationColumns = [
			'id', // Ensure primary key is always allowed
			'name',
			'brief_description',
			'detailed_description',
			'diagrams',
			'tags',
			'is_editable_by_others',
			'visibility',
			'formation_type',
			'created_by',
			'created_at',
			'updated_at',
			'search_vector' // Allow search vector column
		];

		// Standard permission configuration
		const permissionConfig = {
			userIdColumn: 'created_by',
			visibilityColumn: 'visibility',
			publicValue: 'public',
			unlistedValue: 'unlisted',
			privateValue: 'private',
			editableByOthersColumn: 'is_editable_by_others' // For canUserEdit check
		};

		// Explicitly define default columns for FormationService
		const defaultFormationColumns = [
			'id',
			'name',
			'brief_description',
			'detailed_description',
			'diagrams',
			'tags',
			'is_editable_by_others',
			'visibility',
			'formation_type',
			'created_by',
			'created_at',
			'updated_at'
		];

		super(
			'formations',
			'id',
			defaultFormationColumns, // Use explicit default columns
			allowedFormationColumns,
			{
				diagrams: 'json',
				tags: 'array'
			},
			permissionConfig // Pass permission config
		);
	}

	/**
	 * Get formations with optional filtering/pagination/searching.
	 * This now uses the base service search helpers.
	 */
	async getAllFormations(options = {}) {
		const {
			page = 1,
			limit = 10,
			sortBy = 'created_at',
			sortOrder = 'desc',
			userId = null,
			filters = {} // Contains specific formation filters AND filters.searchQuery
		} = options;

		const offset = (page - 1) * limit;

		const buildFormationBaseQuery = () => {
			let qb = kyselyDb.selectFrom('formations').selectAll(); // Select all initially

			if (this.useStandardPermissions && this.permissionConfig) {
				const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
					this.permissionConfig;
				qb = qb.where((eb) => {
					const conditions = [
						eb(visibilityColumn, '=', publicValue),
						eb(visibilityColumn, '=', unlistedValue)
					];
					if (userId) {
						conditions.push(
							eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
						);
					}
					return eb.or(conditions);
				});
			}
			// Apply other formation-specific filters from options.filters if any
			if (filters.formation_type) {
				qb = qb.where('formation_type', '=', filters.formation_type);
			}
			if (filters.tags && filters.tags.length > 0) {
				qb = qb.where(sql`tags && ${sql.array(filters.tags, 'text')}`); // Array overlap for tags
			}
			// Add more specific filters here as needed

			return qb;
		};

		const baseQuery = buildFormationBaseQuery();
		const baseQueryForFallback = buildFormationBaseQuery(); // Clone for fallback

		const ftsQueryBuilder = this._buildSearchQuery(
			baseQuery,
			filters.searchQuery, // Pass searchQuery from the filters object
			'search_vector',
			'english',
			['name', 'brief_description', 'detailed_description', 'tags'] // Include 'tags' in fallback ranking
		);

		let finalQuery = ftsQueryBuilder;
		if (
			!ftsQueryBuilder._ftsAppliedInfo ||
			(options.sortBy && options.sortBy !== 'similarity_score')
		) {
			const validSortColumns = ['name', 'created_at', 'formation_type'];
			const sortCol = validSortColumns.includes(sortBy) ? sortBy : 'created_at';
			const direction = sortOrder === 'asc' ? 'asc' : 'desc';
			finalQuery = finalQuery.orderBy(sortCol, direction).orderBy('id', direction);
		}

		const { items, usedFallback } = await this._executeSearch(finalQuery, baseQueryForFallback, {
			limit,
			offset
		});

		// Count logic - Create a fresh count query instead of reusing the base query
		let countQuery = kyselyDb
			.selectFrom('formations')
			.select(kyselyDb.fn.count('formations.id').as('total'));

		// Apply the same non-search filters as the base query
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			countQuery = countQuery.where((eb) => {
				const conditions = [
					eb(visibilityColumn, '=', publicValue),
					eb(visibilityColumn, '=', unlistedValue)
				];
				if (userId) {
					conditions.push(
						eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
					);
				}
				return eb.or(conditions);
			});
		}
		if (filters.formation_type) {
			countQuery = countQuery.where('formation_type', '=', filters.formation_type);
		}
		if (filters.tags && filters.tags.length > 0) {
			countQuery = countQuery.where(sql`tags && ${sql.array(filters.tags, 'text')}`);
		}

		// Apply search conditions based on what was used for the main query
		if (filters.searchQuery) {
			const cleanedSearchTerm = filters.searchQuery.trim();
			if (cleanedSearchTerm) {
				if (usedFallback) {
					countQuery = countQuery.where((eb) =>
						eb.or([
							eb(sql`similarity(name, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(brief_description, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(detailed_description, ${cleanedSearchTerm})`, '>', 0.3)
						])
					);
				} else {
					const tsQuerySearchTerm = cleanedSearchTerm
						.split(/\s+/)
						.filter(Boolean)
						.map((term) => term + ':*')
						.join(' & ');
					if (tsQuerySearchTerm) {
						countQuery = countQuery.where(
							sql`search_vector @@ to_tsquery('english', ${tsQuerySearchTerm})`
						);
					}
				}
			}
		}

		const countResult = await countQuery.executeTakeFirst();
		const totalItems = parseInt(countResult?.total ?? '0', 10);

		return {
			items,
			pagination: {
				page: parseInt(page),
				limit: parseInt(limit),
				totalItems,
				totalPages: Math.ceil(totalItems / limit)
			}
		};
	}

	/**
	 * getAll method now forwards to getAllFormations with all options.
	 * This keeps compatibility if something was calling `super.getAll()` before,
	 * but new calls should prefer `getAllFormations` for clarity.
	 */
	async getAll(options = {}) {
		return this.getAllFormations(options);
	}

	/**
	 * Create a new formation
	 * @param {Object} formationData - Formation data
	 * @param {number|null} userId - User ID creating the formation (null if anonymous)
	 * @returns {Promise<Object>} - The created formation
	 */
	async createFormation(formationData, userId = null) {
		// Make a copy of the data and remove the id field if it exists
		const { id, ...dataWithoutId } = formationData;

		// Normalize formation data
		const normalizedData = this.normalizeFormationData({
			...dataWithoutId,
			created_by: userId,
			created_at: new Date(),
			updated_at: new Date()
		});

		return await this.create(normalizedData);
	}

	/**
	 * Update an existing formation
	 * @param {number} id - Formation ID
	 * @param {Object} formationData - Updated formation data
	 * @param {number|null} userId - User ID updating the formation
	 * @returns {Promise<Object>} - The updated formation
	 * @throws {NotFoundError} If formation not found
	 * @throws {ForbiddenError} If user lacks permission to edit
	 * @throws {DatabaseError} On database error
	 */
	async updateFormation(id, formationData, userId = null) {
		// In dev mode, bypass permission checks
		if (!dev) {
			// Use base canUserEdit which throws errors for permission violations
			try {
				await this.canUserEdit(id, userId);
			} catch (error) {
				// Re-throw known errors (NotFoundError, ForbiddenError)
				if (error instanceof NotFoundError || error instanceof ForbiddenError) {
					throw error;
				}
				// Wrap other errors as DatabaseError
				console.error(`Error checking edit permission for formation ${id}:`, error);
				throw new DatabaseError('Failed to check edit permission', error);
			}
		} else {
			console.log(
				`[DEV MODE] Bypassing permission check for editing formation ${id} by user ${userId}`
			);
		}

		// Normalize formation data
		const normalizedData = this.normalizeFormationData({
			...formationData,
			updated_at: new Date()
		});

		return await this.update(id, normalizedData);
	}

	/**
	 * Search formations by name or description
	 * @param {string} searchTerm - Search term
	 * @param {Object} options - Optional search options (pagination, etc.)
	 * @returns {Promise<Object>} - Search results with pagination
	 * @throws {DatabaseError} On database error
	 * @throws {ValidationError} If search term is invalid
	 */
	async searchFormations(searchTerm, options = {}) {
		if (!searchTerm || typeof searchTerm !== 'string' || searchTerm.trim().length === 0) {
			// Allow empty search term to effectively list all items via getAllFormations
			// throw new ValidationError('Invalid search term provided.');
		}
		// Consolidate into getAllFormations by passing searchTerm in filters
		const combinedFilters = {
			...(options.filters || {}),
			searchQuery: searchTerm || null // Pass null if empty to avoid triggering search logic unnecessarily
		};
		const { filters, ...remainingOptions } = options; // remove original filters from options
		return this.getAllFormations({ ...remainingOptions, filters: combinedFilters });
	}

	/**
	 * Get formations by created user
	 * @param {number} userId - User ID
	 * @param {Object} options - Optional search options (pagination, etc.)
	 * @returns {Promise<Object>} - Formations created by this user
	 */
	async getFormationsByUser(userId, options = {}) {
		const filters = { ...options.filters, created_by__eq: userId }; // Use __eq operator
		// Directly use the base getAll method with the filter
		return await this.getAll({ ...options, filters });
	}

	/**
	 * Normalize formation data for consistent database storage
	 * @param {Object} data - Raw formation data
	 * @returns {Object} - Normalized data
	 */
	normalizeFormationData(data) {
		if (!data || typeof data !== 'object') {
			return data;
		}

		const normalized = { ...data };

		// Remove id if it is null or undefined so that callers don't accidentally overwrite.
		if (normalized.id === null || normalized.id === undefined) {
			delete normalized.id;
		}

		// Ensure diagrams is always an array (of objects or strings)
		if (normalized.diagrams === null || normalized.diagrams === undefined) {
			normalized.diagrams = [];
		} else if (!Array.isArray(normalized.diagrams)) {
			normalized.diagrams = [normalized.diagrams];
		}

		// Ensure tags is always an array of strings
		if (normalized.tags === null || normalized.tags === undefined) {
			normalized.tags = [];
		} else if (typeof normalized.tags === 'string') {
			normalized.tags = [normalized.tags];
		} else if (!Array.isArray(normalized.tags)) {
			normalized.tags = [normalized.tags];
		}

		// Ensure all tags are strings
		normalized.tags = normalized.tags.map((tag) => String(tag));

		return normalized;
	}

	/**
	 * Associate an anonymously created formation with a user
	 * @param {number|string} id - Formation ID
	 * @param {number} userId - User ID to associate with
	 * @returns {Promise<Object>} - The updated formation
	 * @throws {NotFoundError} - If formation not found
	 * @throws {ConflictError} - If formation already owned by another user
	 * @throws {DatabaseError} - On database error
	 */
	async associateFormation(id, userId) {
		// getById will throw NotFoundError if formation doesn't exist
		const formation = await this.getById(id);

		// Check if already owned by a *different* user
		if (formation.created_by !== null && formation.created_by !== userId) {
			// Use ConflictError
			throw new ConflictError('Formation is already associated with another user.');
		}

		// If already owned by the *same* user, return (idempotent)
		if (formation.created_by === userId) {
			return formation;
		}

		// Update the created_by field using base update method
		// This will also throw NotFoundError if the formation disappears
		try {
			return await this.update(id, { created_by: userId });
		} catch (error) {
			// Re-throw known errors (NotFoundError)
			if (error instanceof NotFoundError) {
				throw error;
			}
			// Wrap others as DatabaseError
			console.error(`Error associating formation ${id} with user ${userId}:`, error);
			throw new DatabaseError('Failed to associate formation', error);
		}
	}

	/**
	 * Duplicate a formation
	 * @param {number} id - Formation ID to duplicate
	 * @param {number|null} userId - User ID creating the duplicate
	 * @returns {Promise<Object>} - New formation with ID
	 * @throws {NotFoundError} If original formation not found
	 * @throws {ForbiddenError} If user cannot view original formation
	 * @throws {DatabaseError} On database error
	 */
	async duplicateFormation(id, userId = null) {
		// First fetch the original formation, including checking view permissions
		// getById handles NotFoundError and ForbiddenError through canUserView
		let originalFormation;
		try {
			originalFormation = await this.getById(id, ['*'], userId);
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof ForbiddenError) {
				throw error;
			}
			console.error(`Error fetching original formation ${id} for duplication:`, error);
			throw new DatabaseError('Failed to fetch original formation for duplication', error);
		}

		// If formation doesn't exist or user can't view it, getById would have thrown an error
		if (!originalFormation) {
			throw new NotFoundError('Formation not found');
		}

		try {
			// Create data for new formation
			const newFormationData = this.normalizeFormationData({
				name: `${originalFormation.name} (Copy)`,
				brief_description: originalFormation.brief_description,
				detailed_description: originalFormation.detailed_description,
				diagrams: originalFormation.diagrams
					? JSON.parse(JSON.stringify(originalFormation.diagrams))
					: [],
				tags: [...(originalFormation.tags || [])],
				formation_type: originalFormation.formation_type,
				created_by: userId,
				// New formation visibility/editability depends on user creating it
				// Default to private for logged-in users, public for anonymous
				visibility: userId ? 'private' : 'public',
				is_editable_by_others: !userId, // Editable if anonymous, not otherwise by default
				created_at: new Date(),
				updated_at: new Date()
			});

			// Create new formation using the base create method
			const newFormation = await this.create(newFormationData);

			return newFormation;
		} catch (error) {
			console.error(`Error duplicating formation ${id}:`, error);
			// Wrap errors during the duplication process
			throw new DatabaseError('Failed to duplicate formation', error);
		}
	}
}

// Export a singleton instance of the service
export const formationService = new FormationService();
</file>

<file path="src/lib/server/services/userService.js">
import { BaseEntityService } from './baseEntityService.js';
import * as db from '$lib/server/db';
import {
	NotFoundError,
	DatabaseError,
	ForbiddenError,
	InternalServerError,
	ValidationError
} from '$lib/server/errors';

/**
 * Service for managing users
 * Extends the BaseEntityService with user-specific functionality
 */
export class UserService extends BaseEntityService {
	/**
	 * Creates a new UserService
	 */
	constructor() {
		super('users', 'id', ['*'], ['id', 'name', 'email', 'image', 'email_verified', 'role']);
	}

	/**
	 * Get user by email address
	 * @param {string} email - User email
	 * @returns {Promise<Object>} - User object
	 * @throws {NotFoundError} If user not found
	 * @throws {DatabaseError} On database error
	 */
	async getUserByEmail(email) {
		try {
			const query = `
        SELECT * FROM users
        WHERE email = $1
      `;

			const result = await db.query(query, [email]);
			// Throw NotFoundError if no user found
			if (result.rows.length === 0) {
				throw new NotFoundError(`User with email ${email} not found`);
			}
			return result.rows[0];
		} catch (error) {
			// Re-throw NotFoundError
			if (error instanceof NotFoundError) {
				throw error;
			}
			console.error('Error in getUserByEmail:', error);
			// Wrap others as DatabaseError
			throw new DatabaseError('Failed to retrieve user by email', error);
		}
	}

	/**
	 * Get user's profile with related content
	 * @param {string} userId - User ID
	 * @returns {Promise<Object>} - User profile with drills, plans, votes, comments
	 * @throws {NotFoundError} If user not found
	 * @throws {DatabaseError} On database error
	 */
        async getUserProfile(userId, { limit = 10, offset = 0 } = {}) {
		try {
			// Get user basic data using base method
			// getById will throw NotFoundError if user doesn't exist.
			const user = await this.getById(userId, ['id', 'name', 'email', 'image', 'email_verified']);
			// Map email_verified to camelCase if needed, though getById might not return it in this format
			// The direct query previously used aliasing: email_verified AS "emailVerified"
			// Base getById doesn't handle aliasing, so we adjust the result or modify getById.
			// Let's adjust here for now:
			const profileUser = {
				...user,
				emailVerified: user.email_verified // Manually map if necessary
			};
			delete profileUser.email_verified; // Remove snake_case version

			// Now start transaction for related data
			return this.withTransaction(async (client) => {
				// Get drills created by user
                                const drillsQuery = `
          SELECT id, name, brief_description, date_created,
                 visibility, is_editable_by_others,
                 (SELECT COUNT(*) FROM drills v WHERE v.parent_drill_id = d.id) as variation_count
          FROM drills d
          WHERE created_by = $1
          ORDER BY date_created DESC
          LIMIT $2 OFFSET $3
        `;
                                const drillsResult = await client.query(drillsQuery, [userId, limit, offset]);

				// Get practice plans created by user
                                const plansQuery = `
          SELECT id, name, description, created_at,
                 visibility, is_editable_by_others
          FROM practice_plans
          WHERE created_by = $1
          ORDER BY created_at DESC
          LIMIT $2 OFFSET $3
        `;
                                const plansResult = await client.query(plansQuery, [userId, limit, offset]);

				// Get formations created by user
                                const formationsQuery = `
          SELECT id, name, brief_description, created_at,
                 visibility, is_editable_by_others
          FROM formations
          WHERE created_by = $1
          ORDER BY created_at DESC
          LIMIT $2 OFFSET $3
        `;
                                const formationsResult = await client.query(formationsQuery, [userId, limit, offset]);

				// Get votes by user
                                const votesQuery = `
          SELECT
            v.id,
            v.drill_id,
            v.practice_plan_id,
            v.vote,
            v.created_at,
            CASE
              WHEN v.drill_id IS NOT NULL THEN 'drill'
              WHEN v.practice_plan_id IS NOT NULL THEN 'practice_plan'
            END AS type,
            COALESCE(d.name, pp.name) AS item_name
          FROM votes v
          LEFT JOIN drills d ON v.drill_id = d.id
          LEFT JOIN practice_plans pp ON v.practice_plan_id = pp.id
          WHERE v.user_id = $1
          ORDER BY v.created_at DESC
          LIMIT $2 OFFSET $3
        `;
                                const votesResult = await client.query(votesQuery, [userId, limit, offset]);

				// Get comments by user
                                const commentsQuery = `
          SELECT c.*,
            CASE
              WHEN c.drill_id IS NOT NULL THEN 'drill'
              WHEN c.practice_plan_id IS NOT NULL THEN 'practice_plan'
            END AS type,
            d.name AS drill_name,
            pp.name AS practice_plan_name
          FROM comments c
          LEFT JOIN drills d ON c.drill_id = d.id
          LEFT JOIN practice_plans pp ON c.practice_plan_id = pp.id
          WHERE c.user_id = $1
          ORDER BY c.created_at DESC
          LIMIT $2 OFFSET $3
        `;
                                const commentsResult = await client.query(commentsQuery, [userId, limit, offset]);

				return {
					user: profileUser, // Use the adjusted user object
					drills: drillsResult.rows,
					practicePlans: plansResult.rows,
					formations: formationsResult.rows,
					votes: votesResult.rows,
					comments: commentsResult.rows
				};
			});
		} catch (error) {
			// Re-throw NotFoundError from getById
			if (error instanceof NotFoundError) {
				throw error;
			}
			console.error(`Error fetching user profile for ID ${userId}:`, error);
			// Wrap other errors (DB errors during related data fetch) as DatabaseError
			throw new DatabaseError('Failed to retrieve user profile', error);
		}
	}

	/**
	 * Check if user has admin role
	 * @param {string} userId - User ID to check
	 * @returns {Promise<boolean>} - True if user is admin
	 */
	async isAdmin(userId) {
		try {
			const user = await this.getById(userId, ['role']);
			return user.role === 'admin';
		} catch (error) {
			// If user not found or error, they're not admin
			return false;
		}
	}

	/**
	 * Set user role
	 * @param {string} userId - User ID
	 * @param {string} role - New role (user or admin)
	 * @returns {Promise<Object>} - Updated user object
	 * @throws {ValidationError} If role is invalid
	 * @throws {NotFoundError} If user not found
	 * @throws {DatabaseError} On database error
	 */
	async setUserRole(userId, role) {
		// Validate role
		const validRoles = ['user', 'admin'];
		if (!validRoles.includes(role)) {
			throw new ValidationError(`Invalid role. Must be one of: ${validRoles.join(', ')}`);
		}

		try {
			const query = `
				UPDATE users 
				SET role = $1 
				WHERE id = $2 
				RETURNING id, name, email, role
			`;
			const result = await db.query(query, [role, userId]);

			if (result.rows.length === 0) {
				throw new NotFoundError(`User with ID ${userId} not found`);
			}

			console.info(`User ${userId} role updated to ${role}`);
			return result.rows[0];
		} catch (error) {
			if (error instanceof NotFoundError) {
				throw error;
			}
			console.error('Error setting user role:', error);
			throw new DatabaseError('Failed to update user role', error);
		}
	}

	/**
	 * Ensure a user row exists in the users table. If it doesn't, insert it using data
	 * from Better‑Auth's session.
	 * @param {{id:string,name?:string,email?:string,image?:string,emailVerified?:boolean}} userObj
	 */
	async ensureUserExists(userObj) {
		if (!userObj?.id) return;

                const { id, name, email, image, emailVerified, role = 'user' } = userObj;

		// Quick existence check
		const exists = await this.exists(id);
		if (exists) return;

		// Insert minimal row
		const insertQuery = `
      INSERT INTO users (id, name, email, image, email_verified, role)
      VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT (id) DO NOTHING
    `;

		try {
			await db.query(insertQuery, [
				id,
				name ?? null,
				email ?? null,
				image ?? null,
                                emailVerified ? new Date() : null,
                                role
                        ]);
			console.info('Inserted new user row for Better‑Auth id', id);
		} catch (err) {
			console.error('Failed to insert user row for', id, err);
			// Should this throw? If called during sign-in, maybe not critical,
			// but could cause issues later if user data is expected.
			// Let's wrap and throw DatabaseError for clarity.
			throw new DatabaseError('Failed to ensure user exists in database', err);
		}
	}
}

// Export a singleton instance of the service
export const userService = new UserService();
</file>

<file path="src/lib/server/services/baseEntityService.js">
import * as db from '$lib/server/db.js';
import {
	NotFoundError,
	ValidationError,
	DatabaseError,
	InternalServerError,
	ForbiddenError
} from '$lib/server/errors.js';
import { sql } from 'kysely'; // Ensure sql is imported from Kysely

/**
 * Base service class for entity operations
 * Provides common CRUD functionality that can be extended by specific entity services
 */
export class BaseEntityService {
	/**
	 * @param {string} tableName - Database table name for this entity
	 * @param {string} primaryKey - Primary key column name (default: 'id')
	 * @param {Array<string>} defaultColumns - Columns to return by default (default: ['*'])
	 * @param {Array<string>} allowedColumns - Columns that can be used for filtering and sorting
	 * @param {Object} columnTypes - Map of column names to their types (e.g., { tags: 'array' })
	 * @param {Object} [permissionConfig=null] - Configuration for standard permissions
	 * @param {string} [permissionConfig.userIdColumn='created_by'] - Column for user ID
	 * @param {string} [permissionConfig.visibilityColumn='visibility'] - Column for visibility status
	 * @param {any} [permissionConfig.publicValue='public'] - Value for public visibility
	 * @param {any} [permissionConfig.unlistedValue='unlisted'] - Value for unlisted visibility
	 * @param {any} [permissionConfig.privateValue='private'] - Value for private visibility
	 */
	constructor(
		tableName,
		primaryKey = 'id',
		defaultColumns = ['*'],
		allowedColumns = [],
		columnTypes = {},
		permissionConfig = null
	) {
		this.tableName = tableName;
		this.primaryKey = primaryKey;
		this.defaultColumns = defaultColumns;
		this.allowedColumns = [...allowedColumns, primaryKey];
		this.columnTypes = columnTypes;

		// Track if this entity uses common permissions model
		this.permissionConfig = permissionConfig;
		this.useStandardPermissions = !!permissionConfig;

		// Default permission settings if enabled but not fully configured
		if (this.useStandardPermissions) {
			this.permissionConfig = {
				userIdColumn: permissionConfig?.userIdColumn || 'created_by',
				visibilityColumn: permissionConfig?.visibilityColumn || 'visibility',
				publicValue: permissionConfig?.publicValue ?? 'public', // Use ?? to allow null/false
				unlistedValue: permissionConfig?.unlistedValue ?? 'unlisted',
				privateValue: permissionConfig?.privateValue ?? 'private',
				editableByOthersColumn: permissionConfig?.editableByOthersColumn || 'is_editable_by_others' // Added for canUserEdit
			};
		}
	}

	/**
	 * Enable standard permissions model
	 * This assumes the entity has created_by and is_editable_by_others columns
	 * DEPRECATED: Pass permissionConfig to constructor instead.
	 */
	enableStandardPermissions() {
		this.useStandardPermissions = true;
		// Apply default config if enabled this way (for backward compatibility, though discouraged)
		if (!this.permissionConfig) {
			this.permissionConfig = {
				userIdColumn: 'created_by',
				visibilityColumn: 'visibility',
				publicValue: 'public',
				unlistedValue: 'unlisted',
				privateValue: 'private',
				editableByOthersColumn: 'is_editable_by_others'
			};
		}
		console.warn(
			'enableStandardPermissions() is deprecated. Pass permission configuration to the BaseEntityService constructor instead.'
		);
	}

	/**
	 * Validates if a column name is allowed for filtering and sorting
	 * @param {string} columnName - Column name to validate
	 * @returns {boolean} - True if column is allowed
	 */
	isColumnAllowed(columnName) {
		// If no allowed columns are specified, only allow the primary key
		if (this.allowedColumns.length === 0) {
			return columnName === this.primaryKey;
		}
		return this.allowedColumns.includes(columnName);
	}

	/**
	 * Validates and sanitizes sort order
	 * @param {string} sortOrder - Sort order to validate
	 * @returns {string} - Sanitized sort order
	 */
	validateSortOrder(sortOrder) {
		const order = sortOrder.toLowerCase();
		return order === 'asc' ? 'ASC' : 'DESC';
	}

	/**
	 * Builds the WHERE clause and parameters for a query based on filters and permissions.
	 * @param {Object} filters - Filter conditions (e.g., { name__like: '%test%', age__gt: 18 })
	 * @param {number|null} [userId=null] - ID of the user making the request (for permission checks)
	 * @param {number} [initialParamCount=0] - Starting index for query parameters.
	 * @returns {{ whereClause: string, queryParams: Array<any>, paramCount: number }}
	 */
	_buildWhereClause(filters = {}, userId = null, initialParamCount = 0) {
		const conditions = [];
		const queryParams = [];
		let paramCount = initialParamCount;

		// Define supported operators and their SQL generation logic
		const operators = {
			exact: (col, val) => ({ clause: `${col} = $${paramCount + 1}`, params: [val] }),
			eq: (col, val) => ({ clause: `${col} = $${paramCount + 1}`, params: [val] }),
			neq: (col, val) => ({ clause: `${col} != $${paramCount + 1}`, params: [val] }),
			gt: (col, val) => ({ clause: `${col} > $${paramCount + 1}`, params: [val] }),
			gte: (col, val) => ({ clause: `${col} >= $${paramCount + 1}`, params: [val] }),
			lt: (col, val) => ({ clause: `${col} < $${paramCount + 1}`, params: [val] }),
			lte: (col, val) => ({ clause: `${col} <= $${paramCount + 1}`, params: [val] }),
			like: (col, val) => ({ clause: `${col} LIKE $${paramCount + 1}`, params: [val] }),
			ilike: (col, val) => ({ clause: `${col} ILIKE $${paramCount + 1}`, params: [val] }),
			isnull: (col, val) => ({ clause: `${col} IS ${val ? 'NULL' : 'NOT NULL'}`, params: [] }), // Value is boolean true/false
			in: (col, val) => {
				// Expects value to be an array
				if (!Array.isArray(val) || val.length === 0) return null; // Or throw error?
				const placeholders = val.map((_, i) => `$${paramCount + 1 + i}`).join(', ');
				return { clause: `${col} IN (${placeholders})`, params: val };
			},
			any: (col, val) => {
				// Specific to PostgreSQL ANY operator for array membership
				if (!Array.isArray(val) && this.columnTypes[col] === 'array') {
					// If filter value is single for an array col, check membership
					return { clause: `$${paramCount + 1} = ANY(${col})`, params: [val] };
				} else if (Array.isArray(val) && this.columnTypes[col] === 'array') {
					// If filter value is array for array col, check overlap (&&)
					return { clause: `${col} && $${paramCount + 1}`, params: [val] };
				}
				// Fallback or error for non-array columns/values?
				console.warn(`Unsupported 'any' filter for column '${col}' with value:`, val);
				return null;
			}
			// TODO: Add support for other operators like 'between', 'not in', etc.
		};

		// Process filters
		Object.entries(filters).forEach(([key, value]) => {
			// Skip undefined values (allow null for isnull)
			if (value === undefined) {
				return;
			}

			let columnName = key;
			let operator = 'exact'; // Default operator

			// Check for operator suffix (e.g., "name__like")
			const parts = key.split('__');
			if (parts.length === 2 && operators[parts[1]]) {
				columnName = parts[0];
				operator = parts[1];
			}

			// Validate column
			if (!this.isColumnAllowed(columnName)) {
				console.warn(`Filter key '${key}' uses disallowed column '${columnName}'. Skipping.`);
				return;
			}

			// Skip null values unless using isnull operator
			if (value === null && operator !== 'isnull') {
				return;
			}

			// Get the clause and params from the operator function
			const opFunc = operators[operator];
			const result = opFunc(columnName, value);

			if (result && result.clause) {
				conditions.push(result.clause);
				queryParams.push(...result.params);
				paramCount += result.params.length; // Increment count by number of params added
			}
		});

		// Add standard permission filtering if enabled
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			const visibilityConditions = [];

			// Always allow public (if defined)
			if (publicValue !== undefined && publicValue !== null) {
				visibilityConditions.push(`${visibilityColumn} = $${paramCount + 1}`);
				queryParams.push(publicValue);
				paramCount++;
			} else {
				// If public not defined, maybe allow NULL? Or require explicit public value?
				// For now, let's assume NULL is implicitly public if publicValue isn't set.
				visibilityConditions.push(`${visibilityColumn} IS NULL`);
			}

			// Always allow unlisted (if defined)
			if (unlistedValue !== undefined && unlistedValue !== null) {
				visibilityConditions.push(`${visibilityColumn} = $${paramCount + 1}`);
				queryParams.push(unlistedValue);
				paramCount++;
			}

			// Allow private if userId matches and privateValue is defined
			if (userId !== null && privateValue !== undefined && privateValue !== null) {
				visibilityConditions.push(
					`(${visibilityColumn} = $${paramCount + 1} AND ${userIdColumn} = $${paramCount + 2})`
				);
				queryParams.push(privateValue, userId);
				paramCount += 2;
			}

			if (visibilityConditions.length > 0) {
				conditions.push(`(${visibilityConditions.join(' OR ')})`);
			} else if (userId === null && privateValue !== undefined) {
				// If user is not logged in and private items exist, explicitly exclude them
				conditions.push(`${visibilityColumn} != $${paramCount + 1}`);
				queryParams.push(privateValue);
				paramCount++;
			}
		}

		const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
		return { whereClause, queryParams, paramCount };
	}

	/**
	 * Get all entities with optional filtering and pagination
	 * @param {Object} options - Query options
	 * @param {number} options.page - Page number starting from 1 (default: 1)
	 * @param {number} options.limit - Items per page (default: 10)
	 * @param {boolean} options.all - Whether to return all records (default: false)
	 * @param {Object} options.filters - Filter conditions
	 * @param {string} options.sortBy - Column to sort by
	 * @param {string} options.sortOrder - Sort order ('asc' or 'desc', default: 'desc')
	 * @param {Array<string>} options.columns - Columns to return (default: this.defaultColumns)
	 * @param {number|null} options.userId - User ID for permission checking (if applicable)
	 * @returns {Promise<Object>} - Results with pagination info
	 */
	async getAll(options = {}) {
		const {
			page = 1,
			limit = 10,
			all = false,
			filters = {},
			sortBy = null,
			sortOrder = 'desc',
			columns = this.defaultColumns,
			userId = null // For permission filtering
		} = options;

		// Calculate offset for pagination
		const offset = (page - 1) * limit;

		const { whereClause, queryParams, paramCount } = this._buildWhereClause(filters, userId, 0);

		// Build ORDER BY clause with validation
		let orderBy;
		if (sortBy && this.isColumnAllowed(sortBy)) {
			const sanitizedSortOrder = this.validateSortOrder(sortOrder);
			if (this.primaryKey) {
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}, ${this.primaryKey} ${sanitizedSortOrder}`;
			} else {
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}`;
			}
		} else if (this.primaryKey) {
			orderBy = `ORDER BY ${this.primaryKey} DESC`;
		} else {
			orderBy = ''; // No ordering if no primary key
		}

		// Validate columns to return
		const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

		// If no valid columns, default to primary key (if it exists) or all allowed columns
		if (validColumns.length === 0) {
			if (this.primaryKey) {
				validColumns.push(this.primaryKey);
			} else {
				validColumns.push('*');
			}
		}

			try {
				let results;
				let pagination = {};

				if (!all) {
					const countQuery = `
            SELECT COUNT(*)
            FROM ${this.tableName}
            ${whereClause}
          `;

					const countResult = await db.query(countQuery, queryParams);
					const totalItems = parseInt(countResult.rows[0].count);

					pagination = {
						page: parseInt(page),
						limit: parseInt(limit),
						totalItems,
						totalPages: Math.ceil(totalItems / limit)
					};

					const query = `
            SELECT ${validColumns.join(', ')}
            FROM ${this.tableName}
            ${whereClause}
            ${orderBy}
            LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
          `;

					const allParams = [...queryParams, limit, offset];
					const result = await db.query(query, allParams);
					results = result.rows;
				} else {
					const query = `
            SELECT ${validColumns.join(', ')}
            FROM ${this.tableName}
            ${whereClause}
            ${orderBy}
          `;

					const result = await db.query(query, queryParams);
					results = result.rows;
				}

				return {
					items: results,
					pagination: all ? null : pagination
				};
			} catch (error) {
				console.error(`Error in ${this.tableName}.getAll():`, error);
				throw new DatabaseError(`Failed to retrieve ${this.tableName}`, error);
			}
	}

	/**
	 * Get a single entity by ID
	 * @param {number|string} id - Entity ID
	 * @param {Array<string>} columns - Columns to return (default: this.defaultColumns)
	 * @param {number|null} [userId=null] - User ID for permission checking (if applicable)
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Entity object
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 */
	async getById(id, columns = this.defaultColumns, userId = null, client = null) {
		try {
			// Validate columns to return
			const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

			// If no valid columns, default to primary key
			if (validColumns.length === 0) {
				validColumns.push(this.primaryKey);
			}

			// Use the provided client or the default db connection
			const dbInterface = client || db;

			const query = `
        SELECT ${validColumns.join(', ')}
        FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
      `;

			const result = await dbInterface.query(query, [id]);

			// Throw NotFoundError if no rows are returned
			if (result.rows.length === 0) {
				throw new NotFoundError(`${this.tableName.slice(0, -1)} with ID ${id} not found`);
			}

			const entity = result.rows[0];

			// Check view permission if standard permissions are enabled
			if (this.useStandardPermissions && !this.canUserView(entity, userId)) {
				throw new ForbiddenError(
					`User not authorized to view ${this.tableName.slice(0, -1)} with ID ${id}`
				);
			}

			return result.rows[0];
		} catch (error) {
			// Re-throw NotFoundError directly
			if (error instanceof NotFoundError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.getById(${id}):`, error);
			// Wrap other errors as DatabaseError
			throw new DatabaseError(
				`Failed to retrieve ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Create a new entity
	 * @param {Object} data - Entity data
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Created entity
	 */
	async create(data, client = null) {
		const dbInterface = client || db;
		try {
			// Create a copy of the data
			const dataCopy = { ...data };

			// Remove id field if it exists - let the database generate it
			if (this.primaryKey in dataCopy) {
				delete dataCopy[this.primaryKey];
			}

			// Filter out undefined values and validate columns
			const columns = Object.keys(dataCopy).filter(
				(key) => dataCopy[key] !== undefined && this.isColumnAllowed(key)
			);
			const values = columns.map((column) => dataCopy[column]);

			// No columns to insert
			if (columns.length === 0) {
				throw new ValidationError('No valid data provided for insertion');
			}

			const placeholders = columns.map((_, index) => `$${index + 1}`).join(', ');

			const query = `
        INSERT INTO ${this.tableName} (${columns.join(', ')})
        VALUES (${placeholders})
        RETURNING *
      `;

			const result = await dbInterface.query(query, values);

			return result.rows[0];
		} catch (error) {
			console.error(`Error in ${this.tableName}.create():`, error);
			throw new DatabaseError(`Failed to create ${this.tableName.slice(0, -1)}`, error);
		}
	}

	/**
	 * Update an entity
	 * @param {number|string} id - Entity ID
	 * @param {Object} data - Updated entity data
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<Object>} - Updated entity
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 * @throws {ValidationError} If no valid data provided
	 */
	async update(id, data, client = null) {
		const dbInterface = client || db;
		try {
			// Filter out undefined values and validate columns
			const columns = Object.keys(data).filter(
				(key) => data[key] !== undefined && key !== this.primaryKey && this.isColumnAllowed(key)
			);

			if (columns.length === 0) {
				throw new ValidationError('No valid data provided for update');
			}

			const values = columns.map((column) => data[column]);

			const setClause = columns.map((column, index) => `${column} = $${index + 2}`).join(', ');

			const query = `
        UPDATE ${this.tableName}
        SET ${setClause}
        WHERE ${this.primaryKey} = $1
        RETURNING *
      `;

			const result = await dbInterface.query(query, [id, ...values]);

			// Throw NotFoundError if no rows were affected (entity didn't exist)
			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${id} not found for update`
				);
			}

			return result.rows[0];
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof ValidationError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.update(${id}):`, error);
			throw new DatabaseError(
				`Failed to update ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Delete an entity by ID
	 * @param {number|string} id - Entity ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>} - Resolves if successful
	 * @throws {NotFoundError} If entity not found
	 * @throws {DatabaseError} On database error
	 */
	async delete(id, client = null) {
		const dbInterface = client || db;
		try {
			// Ensure the primary key is allowed (it should be by default)
			if (!this.isColumnAllowed(this.primaryKey)) {
				throw new InternalServerError(
					`Primary key ${this.primaryKey} is not in the allowed columns list for ${this.tableName}`
				);
			}

			const query = `
        DELETE FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
        RETURNING ${this.primaryKey}
      `;

			const result = await dbInterface.query(query, [id]);

			// Throw NotFoundError if no rows were deleted (entity didn't exist)
			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${id} not found for deletion`
				);
			}
			return true; // Explicitly return true on success
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof InternalServerError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.delete(${id}):`, error);
			throw new DatabaseError(
				`Failed to delete ${this.tableName.slice(0, -1)} with ID ${id}`,
				error
			);
		}
	}

	/**
	 * Check if an entity with given ID exists
	 * @param {number|string} id - Entity ID
	 * @returns {Promise<boolean>} - True if exists
	 */
	async exists(id) {
		try {
			// Ensure the primary key is allowed (it should be by default)
			if (!this.isColumnAllowed(this.primaryKey)) {
				throw new Error(`Primary key ${this.primaryKey} is not in the allowed columns list`);
			}

			const query = `
        SELECT 1 
        FROM ${this.tableName}
        WHERE ${this.primaryKey} = $1
        LIMIT 1
      `;

			const result = await db.query(query, [id]);

			return result.rows.length > 0;
		} catch (error) {
			console.error(`Error in ${this.tableName}.exists(${id}):`, error);
			return false;
		}
	}

	/**
	 * Search entities by text columns
	 * @param {string} searchTerm - Search term
	 * @param {Array<string>} searchColumns - Columns to search in (DEPRECATED: use searchVectorColumn)
	 * @param {string} [searchVectorColumn='search_vector'] - The tsvector column to search against.
	 * @param {string} [searchConfig='english'] - The text search configuration.
	 * @param {Object} options - Additional options (page, limit, etc.)
	 * @param {number|null} [options.userId=null] - User ID for permission checking.
	 * @returns {Promise<Object>} - Search results with pagination
	 */
	async search(
		searchTerm,
		searchColumns,
		options = {},
		searchVectorColumn = 'search_vector',
		searchConfig = 'english'
	) {
		try {
			const {
				page = 1,
				limit = 10,
				sortBy = null,
				sortOrder = 'desc',
				columns = this.defaultColumns,
				userId = null // For permission checking
			} = options;

			// --- BEGIN DEPRECATION WARNING for searchColumns ---
			if (searchColumns && Array.isArray(searchColumns) && searchColumns.length > 0) {
				console.warn(`The 'searchColumns' parameter in BaseEntityService.search() is DEPRECATED and will be removed. 
          Configure a tsvector column ('${searchVectorColumn}') in your database and service instead.`);
				// Optional: Fallback to old LIKE search if searchVectorColumn check fails?
				// For now, we proceed assuming tsvector is preferred.
			}
			// --- END DEPRECATION WARNING ---

			// Validate tsvector column existence (basic check - assumes it exists in DB)
			// A more robust check might involve querying information_schema, but adds overhead.
			// We also need to ensure it's allowed if specific columns are enforced.
			// if (!this.isColumnAllowed(searchVectorColumn)) { // Optional: uncomment if searchVectorColumn must be in allowedColumns
			//   throw new ValidationError(`Search vector column '${searchVectorColumn}' is not allowed.`);
			// }

			// Validate columns to return
			const validColumns = columns.filter((col) => col === '*' || this.isColumnAllowed(col));

			// If no valid columns, default to primary key
			if (validColumns.length === 0) {
				validColumns.push(this.primaryKey);
			}

			const offset = (page - 1) * limit;
			// Prepare the search term for tsquery (plainto_tsquery handles basic parsing and stemming)
			const tsQueryParam = searchTerm;

			// Build search conditions
			// Use tsquery for full-text search
			const searchCondition = `${searchVectorColumn} @@ plainto_tsquery($1, $2)`;
			const initialParams = [searchConfig, tsQueryParam];
			let currentParamCount = initialParams.length;

			// Combine with permission and other filters using _buildWhereClause
			// Pass the search condition as a raw filter (needs careful handling)
			// TODO: How to best integrate raw SQL conditions with _buildWhereClause?
			// Option 1: Add a special filter key like '__raw'.
			// Option 2: Modify _buildWhereClause to accept initial conditions.
			// Option 3: Build search and filter WHERE clauses separately and combine.
			// Let's try Option 3 for now.

			const {
				whereClause: filterWhereClause,
				queryParams: filterQueryParams,
				paramCount: filterParamCount
			} = this._buildWhereClause(options.filters || {}, userId, currentParamCount);

			// Combine conditions
			const combinedConditions = [searchCondition];
			if (filterWhereClause) {
				// Extract conditions from filterWhereClause (remove 'WHERE ')
				combinedConditions.push(filterWhereClause.substring(6));
			}
			const finalWhereClause = `WHERE ${combinedConditions.join(' AND ')}`;
			const finalQueryParams = [...initialParams, ...filterQueryParams];
			currentParamCount = filterParamCount; // Update param count

			// Count total matches
			const countQuery = `
        SELECT COUNT(*)
        FROM ${this.tableName}
        ${finalWhereClause}
      `;

			const countResult = await db.query(countQuery, finalQueryParams);
			const totalItems = parseInt(countResult.rows[0].count);

			// Build ORDER BY clause with validation
			let orderBy;
			if (sortBy && this.isColumnAllowed(sortBy)) {
				const sanitizedSortOrder = this.validateSortOrder(sortOrder);
				orderBy = `ORDER BY ${sortBy} ${sanitizedSortOrder}, ${this.primaryKey} ${sanitizedSortOrder}`;
			} else {
				// Default sort by relevance when searching
				orderBy = `ORDER BY ts_rank_cd(${searchVectorColumn}, plainto_tsquery($1, $2)) DESC, ${this.primaryKey} DESC`;
			}

			// Main search query
			const query = `
        SELECT ${validColumns.join(', ')}
        FROM ${this.tableName}
        ${finalWhereClause}
        ${orderBy}
        LIMIT $${currentParamCount + 1} OFFSET $${currentParamCount + 2}
      `;

			const result = await db.query(query, [...finalQueryParams, limit, offset]);

			return {
				items: result.rows,
				pagination: {
					page: parseInt(page),
					limit: parseInt(limit),
					totalItems,
					totalPages: Math.ceil(totalItems / limit)
				}
			};
		} catch (error) {
			// Re-throw known errors
			if (error instanceof ValidationError) {
				throw error;
			}
			console.error(`Error in ${this.tableName}.search():`, error);
			throw new DatabaseError(`Failed to search ${this.tableName}`, error);
		}
	}

	/**
	 * Execute a function within a database transaction
	 * @param {Function} callback - Async function to execute within transaction
	 * @returns {Promise<any>} - Result of the callback function
	 */
	async withTransaction(callback) {
		const client = await db.getClient();
		try {
			await client.query('BEGIN');
			const result = await callback(client);
			await client.query('COMMIT');
			return result;
		} catch (error) {
			await client.query('ROLLBACK');
			console.error(`Transaction error in ${this.tableName}:`, error);
			throw error;
		} finally {
			client.release();
		}
	}

	/**
	 * Check if a user can edit an entity
	 * Requires that the entity has created_by and is_editable_by_others columns
	 * @param {number|string} entityId - Entity ID
	 * @param {number|null} userId - User ID attempting edit
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<boolean>} - True if user can edit
	 * @throws {ForbiddenError} If user is not authorized
	 */
	async canUserEdit(entityId, userId, client = null) {
		// Use the provided client or the default db connection
		const dbInterface = client || db;

		// Check if user is admin
		if (userId) {
			const userResult = await dbInterface.query('SELECT role FROM users WHERE id = $1', [userId]);
			if (userResult.rows.length > 0 && userResult.rows[0].role === 'admin') {
				return true; // Admins can edit anything
			}
		}

		if (!this.useStandardPermissions) {
			// If permissions aren't configured, default to allowing (or throw error?)
			// console.warn(`Standard permissions not enabled for ${this.tableName} service - allowing edit by default`);
			return true;
		}

		if (!this.permissionConfig) {
			console.error(
				`Cannot check edit permission: Permission config missing for ${this.tableName}`
			);
			throw new InternalServerError(`Permission configuration error for ${this.tableName}`);
		}

		const { userIdColumn, editableByOthersColumn } = this.permissionConfig;

		try {
			// Fetch only necessary columns for permission check
			const query = `SELECT ${userIdColumn}, ${editableByOthersColumn} FROM ${this.tableName} WHERE ${this.primaryKey} = $1`;
			const result = await dbInterface.query(query, [entityId]);

			if (result.rows.length === 0) {
				throw new NotFoundError(
					`${this.tableName.slice(0, -1)} with ID ${entityId} not found for permission check`
				);
			}
			const entity = result.rows[0];

			// Can edit if:
			// 1. User created the entity (and userId is not null)
			// 2. Entity is editable by others
			// 3. Entity has no creator (creator column is null)
			// 4. User is admin (already checked above)
			const isCreator = userId !== null && entity[userIdColumn] === userId;
			const isEditable = entity[editableByOthersColumn] === true;
			const isUnowned = entity[userIdColumn] === null;

			if (!(isCreator || isEditable || isUnowned)) {
				throw new ForbiddenError(
					`User ${userId} is not authorized to edit ${this.tableName.slice(0, -1)} ${entityId}`
				);
			}

			return true; // Return true if no ForbiddenError was thrown
		} catch (error) {
			if (
				error instanceof NotFoundError ||
				error instanceof ForbiddenError ||
				error instanceof InternalServerError
			) {
				throw error; // Re-throw specific errors
			}
			console.error(`Error checking edit permission for ${this.tableName} ${entityId}:`, error);
			throw new DatabaseError(
				`Failed to check edit permission for ${this.tableName.slice(0, -1)}`,
				error
			);
		}
	}

	/**
	 * Check if user has permission to view entity
	 * @param {Object} entity - The entity to check
	 * @param {number|null} userId - User ID requesting access
	 * @returns {boolean} - True if user can view
	 */
	canUserView(entity, userId) {
		// If permissions aren't configured, or no entity provided, default to allowing view
		if (!this.useStandardPermissions || !this.permissionConfig || !entity) {
			return true;
		}

		const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
			this.permissionConfig;
		const visibility = entity[visibilityColumn];

		// Public or Unlisted entities can be viewed by anyone (including null/undefined visibility if public/unlisted values are not set)
		const isPublic =
			publicValue !== undefined && publicValue !== null
				? visibility === publicValue
				: visibility === null || visibility === undefined;
		const isUnlisted =
			unlistedValue !== undefined && unlistedValue !== null ? visibility === unlistedValue : false;

		if (isPublic || isUnlisted) {
			return true;
		}

		// Private entities can only be viewed by the creator (if privateValue and userId are valid)
		const isPrivate =
			privateValue !== undefined && privateValue !== null ? visibility === privateValue : false;
		return isPrivate && userId !== null && entity[userIdColumn] === userId;
	}

	/**
	 * Normalize array fields in data
	 * @param {Object} data - Raw data with potential arrays
	 * @param {Array<string>} arrayFields - Fields to ensure are arrays
	 * @returns {Object} - Data with normalized arrays
	 */
	normalizeArrayFields(data, arrayFields) {
		const normalized = { ...data };

		arrayFields.forEach((field) => {
			// Skip if field is not in data
			if (!(field in normalized)) {
				return;
			}

			// Convert string to array if needed
			if (typeof normalized[field] === 'string') {
				normalized[field] = [normalized[field]];
			}

			// Ensure field is an array
			if (!Array.isArray(normalized[field])) {
				normalized[field] = normalized[field] ? [normalized[field]] : [];
			}
		});

		return normalized;
	}

	/**
	 * Add timestamp fields to entity data
	 * @param {Object} data - Entity data
	 * @param {boolean} isNew - Whether this is a new entity
	 * @returns {Object} - Data with timestamps
	 */
	addTimestamps(data, isNew = true) {
		const now = new Date();
		const result = { ...data };

		if (isNew) {
			result.created_at = now;
		}

		result.updated_at = now;
		return result;
	}

	/**
	 * Builds Kysely query conditions for Full-Text Search (FTS) with prefix matching.
	 * It attaches an '_ftsAppliedInfo' object to the queryBuilder if a search term is processed.
	 * This info is used by _executeSearch for potential fallback.
	 *
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} queryBuilder - The Kysely query builder instance.
	 * @param {string | undefined | null} searchQuery - The raw search term.
	 * @param {string} [vectorColumn='search_vector'] - The tsvector column in the table.
	 * @param {string} [textSearchConfig='english'] - The PostgreSQL text search configuration.
	 * @param {string[]} [columnsToRankForFallback=['name', 'description']] - Columns for pg_trgm fallback.
	 * @param {number} [trigramThresholdForFallback=0.3] - Similarity threshold for pg_trgm.
	 * @returns {import('kysely').SelectQueryBuilder<any, any, any>} - The modified query builder.
	 */
	_buildSearchQuery(
		queryBuilder,
		searchQuery,
		vectorColumn = 'search_vector',
		textSearchConfig = 'english',
		columnsToRankForFallback = ['name', 'description'], // Default fallback columns
		trigramThresholdForFallback = 0.3
	) {
		const cleanedSearchTerm = searchQuery?.trim();

		if (!cleanedSearchTerm) {
			return queryBuilder;
		}

		const tsQuerySearchTerm = cleanedSearchTerm
			.split(/\s+/)
			.filter(Boolean)
			.map((term) => term + ':*') // Add prefix matching to each term
			.join(' & '); // Combine with AND operator

		if (tsQuerySearchTerm) {
			const qbWithFTS = queryBuilder.where(
				sql`${sql.ref(vectorColumn)} @@ to_tsquery(${textSearchConfig}, ${tsQuerySearchTerm})`
			);
			// Attach info needed for potential fallback search
			qbWithFTS._ftsAppliedInfo = {
				originalSearchTerm: cleanedSearchTerm,
				tsQueryUsed: tsQuerySearchTerm,
				textSearchConfig,
				columnsToRankForFallback,
				trigramThresholdForFallback,
				vectorColumn
			};
			return qbWithFTS;
		}
		return queryBuilder;
	}

	/**
	 * Executes a search query, attempting FTS first, then falling back to pg_trgm similarity search
	 * if FTS yields no results and was applicable.
	 *
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} ftsQueryBuilder - Query builder with FTS conditions applied by _buildSearchQuery.
	 * @param {import('kysely').SelectQueryBuilder<any, any, any>} baseQueryBuilderForFallback - The original query builder *before* any search conditions were applied, to be used for fallback.
	 * @param {object} paginationOptions - Options for limit and offset.
	 * @param {number} paginationOptions.limit - Max items per page.
	 * @param {number} paginationOptions.offset - Offset for pagination.
	 * @returns {Promise<{items: Array<any>, usedFallback: boolean}>} - The search results and a flag indicating if fallback was used.
	 */
	async _executeSearch(ftsQueryBuilder, baseQueryBuilderForFallback, { limit, offset }) {
		const ftsAppliedInfo = ftsQueryBuilder._ftsAppliedInfo;

		let items = await ftsQueryBuilder.limit(limit).offset(offset).execute();
		let usedFallback = false;

		if (items.length === 0 && ftsAppliedInfo) {
			console.log(
				`[BaseEntityService] FTS on ${this.tableName} returned 0 results for '${ftsAppliedInfo.originalSearchTerm}', trying pg_trgm fallback...`
			);
			usedFallback = true;

			const { originalSearchTerm, columnsToRankForFallback, trigramThresholdForFallback } =
				ftsAppliedInfo;

			// Ensure columnsToRankForFallback are valid columns of the current table.
			// This is a basic check; more robust validation might involve checking schema.
			const validFallbackColumns = columnsToRankForFallback.filter((col) =>
				this.isColumnAllowed(col)
			);
			if (validFallbackColumns.length === 0) {
				console.warn(
					`[BaseEntityService] pg_trgm fallback for ${this.tableName} skipped: no valid columns to rank were provided or allowed.`
				);
				return { items, usedFallback: false }; // Return original (empty) items
			}

			let fallbackQuery = baseQueryBuilderForFallback // Start from the base query, *without* FTS conditions
				.where((eb) =>
					eb.or(
						validFallbackColumns.map((col) =>
							eb(
								sql`similarity(${sql.ref(col)}, ${originalSearchTerm})`,
								'>',
								trigramThresholdForFallback
							)
						)
					)
				)
				.select((eb) => [
					// Kysely's dynamic way to add selections
					...(this.defaultColumns.includes('*')
						? []
						: this.defaultColumns.map((col) => sql.ref(col))), // Select default columns
					eb.fn
						.greatest(
							...validFallbackColumns.map(
								(col) => sql`similarity(${sql.ref(col)}, ${originalSearchTerm})`
							)
						)
						.as('similarity_score')
				]);

			// If defaultColumns was ['*'], we need to ensure all table columns are selected
			// Kysely doesn't have a simple way to re-add `select *` after specific selections,
			// so services using this should define their default columns explicitly if not already.
			// For now, assuming defaultColumns are explicit or handled by the initial baseQueryBuilder.
			// If baseQueryBuilderForFallback already has its selects, we just add similarity_score.

			fallbackQuery = fallbackQuery.orderBy('similarity_score', 'desc');
			items = await fallbackQuery.limit(limit).offset(offset).execute();
		}

		// Clean up the temporary property from the FTS query builder if it exists
		if (ftsQueryBuilder && '_ftsAppliedInfo' in ftsQueryBuilder) {
			delete ftsQueryBuilder._ftsAppliedInfo;
		}

		return { items, usedFallback };
	}
}
</file>

<file path="src/routes/api/practice-plans/+server.js">
import { json } from '@sveltejs/kit';
import { practicePlanService } from '$lib/server/services/practicePlanService.js';
import { FILTER_STATES } from '$lib/constants'; // Import FILTER_STATES
import { z } from 'zod'; // Import zod
import { createPracticePlanSchema } from '$lib/validation/practicePlanSchema'; // Import Zod schema
import { AppError, DatabaseError, ValidationError, NotFoundError } from '$lib/server/errors'; // Import error types
import { handleApiError } from '../utils/handleApiError.js';
import { generateClaimToken } from '$lib/server/utils/claimTokens.js';

// Previously contained a local copy of handleApiError and a custom
// PracticePlanError class. All routes now import the shared utility
// from ../utils/handleApiError.js for consistent behavior.

export async function GET({ url, locals }) {
	const userId = locals.user?.id;

	// Extract query parameters
	const page = parseInt(url.searchParams.get('page') || '1', 10);
	const limit = parseInt(url.searchParams.get('limit') || '10', 10);
	const sortBy = url.searchParams.get('sortBy') || 'upvotes';
	const sortOrder = url.searchParams.get('sortOrder') || 'desc';
	const searchQuery = url.searchParams.get('search') || '';

	// Extract filters
	const filters = {
		searchQuery: searchQuery || undefined,
		phase_of_season: extractFilterParam(url.searchParams, 'phase'),
		practice_goals: extractFilterParam(url.searchParams, 'goal'),
		min_participants: parseIntOrNull(url.searchParams.get('minP')),
		max_participants: parseIntOrNull(url.searchParams.get('maxP')),
		drill_ids: url.searchParams
			.getAll('drillId')
			.map((id) => parseInt(id, 10))
			.filter((id) => !isNaN(id))
	};

	// Handle team_id parameter - expect UUID only (internal use)
	const teamIdParam = url.searchParams.get('team_id');
	if (teamIdParam) {
		filters.team_id = teamIdParam;
	}

	// Handle is_template filter
	const isTemplate = url.searchParams.get('is_template');
	if (isTemplate !== null) {
		filters.is_template = isTemplate === 'true';
	}

	// Remove empty drill_ids array
	if (filters.drill_ids.length === 0) {
		delete filters.drill_ids;
	}

	try {
		const result = await practicePlanService.getAll({
			userId,
			page,
			limit,
			sortBy,
			sortOrder,
			filters
		});
		// Return the whole result object including items and pagination
		return json(result);
	} catch (err) {
		// Use the centralized error handler
		return handleApiError(err);
	}
}

/**
 * Helper to parse integer or return null
 * @param {string | null} value
 * @returns {number | null}
 */
function parseIntOrNull(value) {
	if (value === null || value === undefined || value === '') return null;
	const parsed = parseInt(value, 10);
	return isNaN(parsed) ? null : parsed;
}

/**
 * Helper to extract multi-state filter parameters
 * e.g., phase_req=Offseason&phase_exc=Mid season
 * @param {URLSearchParams} searchParams
 * @param {string} baseParamName e.g., 'phase'
 * @returns {{ required: string[], excluded: string[] } | undefined}
 */
function extractFilterParam(searchParams, baseParamName) {
	const required = searchParams.getAll(`${baseParamName}_req`);
	const excluded = searchParams.getAll(`${baseParamName}_exc`);

	if (required.length === 0 && excluded.length === 0) {
		return undefined; // No filter applied for this param
	}

	return {
		required,
		excluded
	};
}

export const POST = async ({ request, locals }) => {
	try {
		const rawData = await request.json();
		const userId = locals.user?.id;

		// --- Hydrate parallel group timeline data ---
		// FIXED: Preserve parallel_timeline values from the request
		if (rawData.sections && Array.isArray(rawData.sections)) {
			rawData.sections.forEach((section) => {
				if (section.items && Array.isArray(section.items)) {
					// Group items by parallel_group_id to collect all timelines
					const parallelGroups = new Map();

					// First pass: collect all timelines for each group
					section.items.forEach((item) => {
						if (item.parallel_group_id) {
							if (!parallelGroups.has(item.parallel_group_id)) {
								parallelGroups.set(item.parallel_group_id, new Set());
							}
							// Use the parallel_timeline if provided, otherwise use group_id
							const timeline = item.parallel_timeline || item.parallel_group_id;
							parallelGroups.get(item.parallel_group_id).add(timeline);
						}
					});

					// Second pass: set groupTimelines for all items in parallel groups
					section.items.forEach((item) => {
						if (item.parallel_group_id && parallelGroups.has(item.parallel_group_id)) {
							// Convert Set to Array for groupTimelines
							item.groupTimelines = Array.from(parallelGroups.get(item.parallel_group_id));
							// Preserve the parallel_timeline if it was already set
							// Only set it to group_id if it's not provided
							if (!item.parallel_timeline) {
								item.parallel_timeline = item.parallel_group_id;
							}
						}
					});
				}
			});
		}
		// --- End hydration ---

		// Add userId before validation
		const dataWithUser = { ...rawData, created_by: userId };

		// Validate using Zod schema
		const validationResult = createPracticePlanSchema.safeParse(dataWithUser);

		if (!validationResult.success) {
			// Throw ZodError to be caught by handleApiError
			throw validationResult.error;
		}

		// Use the validated data
		const validatedData = validationResult.data;

		// --- Add order to sections before calling the service ---
		if (validatedData.sections && Array.isArray(validatedData.sections)) {
			validatedData.sections = validatedData.sections.map((section, index) => ({
				...section,
				order: index // Add order based on array index
			}));
		}
		// --- End adding order to sections ---

		// Create practice plan using the service
		// Pass validated data (now with ordered sections) to the service
		const result = await practicePlanService.createPracticePlan(validatedData, userId);

		const body = { id: result.id, message: 'Practice plan created successfully' };
		if (!userId && result?.id) {
			body.claimToken = generateClaimToken('practice-plan', result.id);
		}

		return json(body, { status: 201 });
	} catch (err) {
		// Use the centralized error handler
		return handleApiError(err);
	}
};
</file>

<file path="src/lib/server/services/drillService.js">
import { BaseEntityService } from './baseEntityService.js';
import * as db from '$lib/server/db';
import { upsertSkillCounts } from './skillSql.js';
import {
	NotFoundError,
	ForbiddenError,
	ValidationError,
	DatabaseError,
	ConflictError,
	AppError
} from '$lib/server/errors.js'; // Added import
import { dev } from '$app/environment'; // Import dev environment variable
import { json } from '@sveltejs/kit';
import { kyselyDb, sql } from '$lib/server/db';
import { PREDEFINED_SKILLS } from '$lib/constants/skills';

// Canonical display labels for enum-like arrays
const SKILL_LEVEL_LABELS = ['New to Sport', 'Beginner', 'Intermediate', 'Advanced', 'Expert'];
const POSITION_LABELS = ['Chaser', 'Beater', 'Keeper', 'Seeker'];
const DRILL_TYPE_LABELS = [
	'Competitive',
	'Skill-focus',
	'Tactic-focus',
	'Warmup',
	'Conditioning',
	'Cooldown',
	'Contact',
	'Match-like situation'
];

const SKILL_LEVEL_MAP = Object.fromEntries(
	SKILL_LEVEL_LABELS.map((label) => [label.toLowerCase(), label])
);
const POSITION_MAP = Object.fromEntries(POSITION_LABELS.map((label) => [label.toLowerCase(), label]));
const DRILL_TYPE_MAP = Object.fromEntries(
	DRILL_TYPE_LABELS.map((label) => [label.toLowerCase(), label])
);
const PREDEFINED_SKILL_MAP = Object.fromEntries(
	PREDEFINED_SKILLS.map((label) => [label.toLowerCase(), label])
);

function mapEnumArray(values, map) {
	if (!Array.isArray(values)) return values;
	return values.map((v) => {
		if (typeof v !== 'string') return v;
		const key = v.toLowerCase();
		return map[key] || v;
	});
}

function denormalizeDrillForResponse(drill) {
	if (!drill || typeof drill !== 'object') return drill;
	const copy = { ...drill };
	copy.skill_level = mapEnumArray(copy.skill_level, SKILL_LEVEL_MAP);
	copy.positions_focused_on = mapEnumArray(copy.positions_focused_on, POSITION_MAP);
	copy.drill_type = mapEnumArray(copy.drill_type, DRILL_TYPE_MAP);
	copy.skills_focused_on = mapEnumArray(copy.skills_focused_on, PREDEFINED_SKILL_MAP);
	return copy;
}

/**
 * Service for managing drills
 * Extends the BaseEntityService with drill-specific functionality
 */
export class DrillService extends BaseEntityService {
	/**
	 * Creates a new DrillService
	 */
	constructor() {
		const allowedColumns = [
			'name',
			'brief_description',
			'detailed_description',
			'skill_level',
			'complexity',
			'number_of_people_min',
			'number_of_people_max',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'created_by',
			'visibility',
			'date_created',
			'is_editable_by_others',
			'parent_drill_id',
			'video_link',
			'diagrams',
			'images',
			'upload_source',
			'search_vector',
			'suggested_length_min',
			'suggested_length_max'
		];

		const columnTypes = {
			diagrams: 'json',
			skills_focused_on: 'array',
			positions_focused_on: 'array',
			skill_level: 'array',
			drill_type: 'array',
			images: 'array'
		};

		// Configure standard permissions (using default column names/values)
		const permissionConfig = {
			// userIdColumn: 'created_by', // default
			// visibilityColumn: 'visibility', // default
			// publicValue: 'public', // default
			// unlistedValue: 'unlisted', // default
			// privateValue: 'private', // default
			// editableByOthersColumn: 'is_editable_by_others' // default
		};

		// Explicitly define default columns for DrillService
		// to ensure _executeSearch fallback selects them correctly with similarity_score
		const defaultDrillColumns = [
			'id',
			'name',
			'brief_description',
			'detailed_description',
			'skill_level',
			'complexity',
			'number_of_people_min',
			'number_of_people_max',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'created_by',
			'visibility',
			'date_created',
			'is_editable_by_others',
			'parent_drill_id',
			'video_link',
			'diagrams',
			'images',
			'upload_source',
			'suggested_length_min',
			'suggested_length_max'
			// 'search_vector' is usually not needed in direct output
		];

		super('drills', 'id', defaultDrillColumns, allowedColumns, columnTypes, permissionConfig);

		// Define array fields for normalization
		this.arrayFields = [
			'skill_level',
			'skills_focused_on',
			'positions_focused_on',
			'drill_type',
			'images',
			'diagrams'
		];
	}

	/**
	 * Create a new drill
	 * @param {Object} drillData - Drill data
	 * @param {number|null} userId - User ID creating the drill (null if anonymous)
	 * @returns {Promise<Object>} - The created drill
	 */
	async createDrill(drillData, userId = null) {
		const dataWithMeta = {
			...drillData,
			created_by: userId,
			date_created: new Date()
		};
		const normalizedData = this.normalizeDrillData(dataWithMeta);

		return this.withTransaction(async (client) => {
			const drill = await this.create(normalizedData, client); // Pass client
			const skills = normalizedData.skills_focused_on || [];
			await this.updateSkills(skills, drill.id, client); // Pass client
			return denormalizeDrillForResponse(drill);
		});
	}

	/**
	 * Update an existing drill
	 * @param {number} id - Drill ID
	 * @param {Object} drillData - Updated drill data
	 * @param {number} userId - User ID updating the drill
	 * @returns {Promise<Object>} - The updated drill
	 * @throws {NotFoundError} - If drill not found
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async updateDrill(id, drillData, userId) {
		return this.withTransaction(async (client) => {
			await this.canUserEdit(id, userId, client);
			const existingDrill = await this.getById(id, this.defaultColumns, userId, client); // Use defaultColumns, pass client
			if (!existingDrill) {
				throw new NotFoundError('Drill not found');
			}
			const existingSkills = existingDrill.skills_focused_on || [];
			const normalizedData = this.normalizeDrillData(drillData);

			if (existingDrill.created_by === null && userId) {
				normalizedData.created_by = userId;
			}

			const updatedDrill = await this.update(id, normalizedData, client); // Pass client

			const skillsToRemove = existingSkills.filter(
				(skill) => !normalizedData.skills_focused_on?.includes(skill)
			);
			const skillsToAdd =
				normalizedData.skills_focused_on?.filter((skill) => !existingSkills.includes(skill)) || [];

			await this.updateSkillCounts(skillsToAdd, skillsToRemove, id, client); // Pass client

			if (normalizedData.name && normalizedData.name !== existingDrill.name) {
				await client.query(`UPDATE votes SET item_name = $1 WHERE drill_id = $2`, [
					normalizedData.name,
					id
				]);
			}
			return denormalizeDrillForResponse(updatedDrill);
		});
	}

	/**
	 * Delete a drill by ID
	 * @param {number} id - Drill ID to delete
	 * @param {number} userId - User ID attempting the deletion
	 * @param {Object} options - Additional options
	 * @param {boolean} [options.deleteRelated=false] - Whether to delete related votes and comments
	 * @returns {Promise<boolean>} - True if successful, false if not found
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async deleteDrill(id, userId, options = { deleteRelated: false }) {
		return this.withTransaction(async (client) => {
			let drill;
			const allowDevBypass = dev && process.env.ALLOW_DEV_DELETE_BYPASS === 'true';
			if (options.deleteRelated && allowDevBypass) {
				// In dev mode with explicit bypass enabled, fetch without user ID check
				console.log(`[DEV MODE - deleteDrill] Bypassing permission checks for drill ${id}`);
				try {
					// Directly fetch the needed columns to avoid permission checks in getById
					const result = await client.query(
						`SELECT ${this.permissionConfig.userIdColumn} as created_by, skills_focused_on FROM drills WHERE id = $1`,
						[id]
					);
					if (result.rows.length === 0) {
						throw new NotFoundError(`Drill not found for deletion (dev mode): ${id}`);
					}
					drill = result.rows[0];
				} catch (error) {
					if (error instanceof NotFoundError) {
						throw error; // Re-throw as NotFoundError already handled
					}
					throw error; // Re-throw other errors
				}
			} else {
				// Ensure client is passed to getById for permission check within transaction
				drill = await this.getById(
					id,
					[this.permissionConfig.userIdColumn, 'skills_focused_on'],
					userId,
					client
				);
			}

			if (!drill) {
				throw new NotFoundError(`Drill not found to delete: ${id}`);
			}

			if (!(options.deleteRelated && dev) && drill[this.permissionConfig.userIdColumn] !== userId) {
				throw new ForbiddenError(
					`Unauthorized to delete this drill: ${id}. User ${userId} is not owner ${drill[this.permissionConfig.userIdColumn]}.`
				);
			}

			if (options.deleteRelated) {
				// Delete related votes
				await client.query('DELETE FROM votes WHERE drill_id = $1', [id]);
				// Delete related comments
				await client.query('DELETE FROM comments WHERE drill_id = $1', [id]);
				// Potentially delete from practice_plan_drills, etc. if needed
				// TODO: Add deletion from practice_plan_drills if required
			}

			// Delete the drill itself using the base service method with the client
			await this.delete(id, client);

			// Decrement skill counts (only if deletion was successful)
			const skillsToDecrement = drill.skills_focused_on || [];
			if (skillsToDecrement.length > 0) {
				// Passing an empty array for skillsToAdd
				await this.updateSkillCounts([], skillsToDecrement, id, client);
			}

			return true; // Successfully deleted
		});
	}

	/**
	 * Get a drill with its variations and creator names
	 * @param {number} id - Drill ID
	 * @param {number|null} [userId=null] - User ID for permission filtering
	 * @returns {Promise<Object>} - Drill with variations and creator names
	 */
	async getDrillWithVariations(id, userId = null) {
		const drill = await this.getById(id, this.defaultColumns, userId);
		if (!drill) {
			return null;
		}

		// Get variations of this drill
		let variationsQuery = `
      SELECT d.*, 
             (SELECT COUNT(*) FROM drills v WHERE v.parent_drill_id = d.id) as variation_count
      FROM drills d
      WHERE d.parent_drill_id = $1
    `;

		const variationsParams = [id];

		// Apply standard visibility/ownership filtering for variations
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;

			variationsQuery += `
      AND (
        d.${visibilityColumn} = $2
        OR d.${visibilityColumn} = $3
        ${userId ? `OR (d.${visibilityColumn} = $4 AND d.${userIdColumn} = $5)` : ''}
      )
    `;

			variationsParams.push(publicValue, unlistedValue);
			if (userId) {
				variationsParams.push(privateValue, userId);
			}
		}

		variationsQuery += `
      ORDER BY d.date_created DESC
    `;

		const variationsResult = await db.query(variationsQuery, variationsParams);
		drill.variations = variationsResult.rows;

		// Fetch creator names for variations if any exist
		if (drill.variations && drill.variations.length > 0) {
			const userIds = [...new Set(drill.variations.map((v) => v.created_by).filter(Boolean))];

			if (userIds.length > 0) {
				try {
					// Fetch user names using a separate service or direct query for now
					// TODO: Consider a dedicated UserService for this
					const usersResult = await db.query(`SELECT id, name FROM users WHERE id = ANY($1)`, [
						userIds
					]);

					const userMap = {};
					usersResult.rows.forEach((user) => {
						userMap[user.id] = user.name;
					});

					// Add creator_name to each variation
					drill.variations.forEach((variation) => {
						if (variation.created_by) {
							variation.creator_name = userMap[variation.created_by] || 'Unknown User';
						}
					});
				} catch (userError) {
					console.error(`Error fetching user names for variations of drill ${id}:`, userError);
					// Proceed without creator names if fetching fails
					drill.variations.forEach((variation) => {
						variation.creator_name = 'Error fetching name';
					});
				}
			}
		}

		// Denormalize for client display
		if (drill.variations && Array.isArray(drill.variations)) {
			drill.variations = drill.variations.map(denormalizeDrillForResponse);
		}

		return denormalizeDrillForResponse(drill);
	}

	/**
	 * Create a variation of an existing drill
	 * @param {number} parentId - Parent drill ID
	 * @param {Object} variationData - Variation drill data
	 * @param {number} userId - User ID creating the variation
	 * @returns {Promise<Object>} - The created variation
	 * @throws {NotFoundError} - If parent drill not found
	 */
	async createVariation(parentId, variationData, userId) {
		const parentDrill = await this.getById(parentId, this.defaultColumns, userId);
		if (!parentDrill) {
			// Throw NotFoundError instead of generic Error
			throw new NotFoundError('Parent drill not found');
		}

		// Create a new drill as a variation
		const normalizedData = this.normalizeDrillData({
			...variationData,
			parent_drill_id: parentId,
			created_by: userId,
			date_created: new Date()
		});

		const variation = await this.create(normalizedData);

		// Update skills used in this variation
		if (normalizedData.skills_focused_on && normalizedData.skills_focused_on.length > 0) {
			await this.updateSkills(normalizedData.skills_focused_on, variation.id);
		}

		return denormalizeDrillForResponse(variation);
	}

	/**
	 * Get options for drill filters (distinct values, ranges).
	 * @returns {Promise<Object>} - Object containing filter options.
	 */
	async getDrillFilterOptions() {
		try {
			// Helper function to process distinct values
			const processDistinctResults = (rows) => {
				return rows
					.map((row) => row.value)
					.filter(Boolean) // Ensure value is not null/undefined/empty string
					.sort();
			};

			// Query for distinct values (using LOWER + TRIM in SQL)
			const skillLevelsQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(skill_level))) as value FROM drills WHERE array_length(skill_level, 1) > 0 ORDER BY value;`;
			const complexitiesQuery = `SELECT DISTINCT LOWER(TRIM(complexity)) as value FROM drills WHERE complexity IS NOT NULL ORDER BY value;`;
			const skillsFocusedQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(skills_focused_on))) as value FROM drills WHERE array_length(skills_focused_on, 1) > 0 ORDER BY value;`;
			const positionsFocusedQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(positions_focused_on))) as value FROM drills WHERE array_length(positions_focused_on, 1) > 0 ORDER BY value;`;
			const drillTypesQuery = `SELECT DISTINCT LOWER(TRIM(UNNEST(drill_type))) as value FROM drills WHERE array_length(drill_type, 1) > 0 ORDER BY value;`;

			// Query for min/max number of people
			const peopleRangeQuery = `
        SELECT 
          MIN(number_of_people_min) as min_people,
          MAX(number_of_people_max) as max_people
        FROM drills
        WHERE number_of_people_min IS NOT NULL OR number_of_people_max IS NOT NULL;
      `;

			// Query for min/max suggested length
			const lengthRangeQuery = `
        SELECT 
          MIN(suggested_length_min) as min_length,
          MAX(suggested_length_max) as max_length
        FROM drills
        WHERE suggested_length_min IS NOT NULL OR suggested_length_max IS NOT NULL;
      `;

			// Execute all queries in parallel
			const [
				skillLevelsResult,
				complexitiesResult,
				skillsFocusedResult,
				positionsFocusedResult,
				drillTypesResult,
				peopleRangeResult,
				lengthRangeResult // Add lengthRangeResult
			] = await Promise.all([
				db.query(skillLevelsQuery),
				db.query(complexitiesQuery),
				db.query(skillsFocusedQuery),
				db.query(positionsFocusedQuery),
				db.query(drillTypesQuery),
				db.query(peopleRangeQuery),
				db.query(lengthRangeQuery) // Execute length query
			]);

			return {
				skillLevels: processDistinctResults(skillLevelsResult.rows),
				complexities: processDistinctResults(complexitiesResult.rows),
				skillsFocusedOn: processDistinctResults(skillsFocusedResult.rows),
				positionsFocusedOn: processDistinctResults(positionsFocusedResult.rows),
				drillTypes: processDistinctResults(drillTypesResult.rows),
				numberOfPeopleOptions: {
					min: peopleRangeResult.rows[0]?.min_people ?? 0, // Use nullish coalescing
					max: peopleRangeResult.rows[0]?.max_people ?? 100 // Use nullish coalescing
				},
				// Update suggestedLengths based on DB query
				suggestedLengths: {
					min: lengthRangeResult.rows[0]?.min_length ?? 0, // Default to 0 if null
					max: lengthRangeResult.rows[0]?.max_length ?? 120 // Default to 120 if null
				}
			};
		} catch (error) {
			console.error('Error in drillService.getDrillFilterOptions:', error);
			// Re-throw the error to be handled by the API route
			throw new DatabaseError('Failed to retrieve filter options from database.', error);
		}
	}

	/**
	 * Search drills by name, description, and other criteria
	 * @param {string} searchTerm - Search term
	 * @param {Object} options - Search options including filters
	 * @returns {Promise<Object>} - Search results with pagination
	 */
	async searchDrills(searchTerm, options = {}) {
		// Consolidate search logic into getFilteredDrills
		const filters = {
			...(options.filters || {}), // Preserve any existing filters from options
			searchQuery: searchTerm
		};
		// Remove options.filters if it exists, as it's merged into the main filters object
		const { filters: _, ...remainingOptions } = options;
		return this.getFilteredDrills(filters, remainingOptions);
	}

	/**
	 * Get drills with advanced filtering, sorting, and pagination
	 * Overrides base getAll functionality for complex drill filtering
	 * @param {Object} [filters={}] - Filters object
	 * @param {string[]} [filters.skill_level] - Skill levels to filter by (match any)
	 * @param {string} [filters.complexity] - Complexity level
	 * @param {string[]} [filters.skills_focused_on] - Skills to filter by (match any)
	 * @param {string[]} [filters.positions_focused_on] - Positions to filter by (match any)
	 * @param {string[]} [filters.drill_type] - Drill types to filter by (match any)
	 * @param {number} [filters.number_of_people_min] - Minimum number of people
	 * @param {number} [filters.number_of_people_max] - Maximum number of people
	 * @param {number} [filters.suggested_length_min] - Minimum suggested length (e.g., minutes)
	 * @param {number} [filters.suggested_length_max] - Maximum suggested length (e.g., minutes)
	 * @param {boolean} [filters.hasVideo] - Filter by presence of video
	 * @param {boolean} [filters.hasDiagrams] - Filter by presence of diagrams
	 * @param {boolean} [filters.hasImages] - Filter by presence of images
	 * @param {string} [filters.searchQuery] - Text search query (searches name, descriptions)
	 * @param {Object} [options={}] - Sorting and pagination options
	 * @param {string} [options.sortBy='date_created'] - Column to sort by (e.g., 'name', 'date_created')
	 * @param {'asc'|'desc'} [options.sortOrder='desc'] - Sort order
	 * @param {number} [options.page=1] - Page number
	 * @param {number} [options.limit=10] - Items per page
	 * @param {number|null} [options.userId] - User ID for permission filtering
	 * @param {string[]} [options.columns] - Columns to include in the result
	 * @returns {Promise<Object>} - Object containing `items` array and `pagination` info
	 */
	async getFilteredDrills(filters = {}, options = {}) {
		const {
			page = 1,
			limit = 10,
			sortBy = 'date_created',
			sortOrder = 'desc',
			columns = ['*'],
			userId = null
		} = options;

		const offset = (page - 1) * limit;

		// Helper to build the Kysely base query with specific drill table and common filters.
		const buildDrillBaseQuery = () => {
			let qb = kyselyDb.selectFrom('drills').selectAll(); // Start with selectAll, specific columns handled by _executeSearch or defaultColumns

			// Apply standard visibility/ownership filters from BaseEntityService
			// This part needs to be aligned with how _buildWhereClause works or be replicated if _buildWhereClause is not Kysely-native.
			// For now, assuming _buildWhereClause is not Kysely native and permissions are applied here directly for Kysely.
			if (this.useStandardPermissions && this.permissionConfig) {
				const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
					this.permissionConfig;
				qb = qb.where((eb) => {
					const conditions = [
						eb(visibilityColumn, '=', publicValue),
						eb(visibilityColumn, '=', unlistedValue)
					];
					if (userId) {
						conditions.push(
							eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
						);
					}
					return eb.or(conditions);
				});
			}

            // Apply specific drill filters using Kysely
            if (filters.skill_level?.length)
                qb = qb.where(sql`skill_level && ${sql.array(filters.skill_level, 'text')}`); // Array overlap
			// Handle complexity as either array or string for backward compatibility
			if (Array.isArray(filters.complexity) && filters.complexity.length) {
				qb = qb.where('complexity', 'in', filters.complexity);
			} else if (typeof filters.complexity === 'string' && filters.complexity) {
				qb = qb.where('complexity', '=', filters.complexity);
			}
            if (filters.skills_focused_on?.length)
                qb = qb.where(sql`skills_focused_on && ${sql.array(filters.skills_focused_on, 'text')}`);
            if (filters.positions_focused_on?.length)
                qb = qb.where(sql`positions_focused_on && ${sql.array(filters.positions_focused_on, 'text')}`);
            if (filters.drill_type?.length)
                qb = qb.where(sql`drill_type && ${sql.array(filters.drill_type, 'text')}`);
            if (filters.number_of_people_min != null)
                qb = qb.where('number_of_people_min', '>=', filters.number_of_people_min);
			if (filters.number_of_people_max != null)
				qb = qb.where('number_of_people_max', '<=', filters.number_of_people_max);
			if (filters.suggested_length_min != null)
				qb = qb.where('suggested_length_min', '>=', filters.suggested_length_min);
			if (filters.suggested_length_max != null)
				qb = qb.where('suggested_length_max', '<=', filters.suggested_length_max);
			if (filters.hasVideo === true)
				qb = qb.where('video_link', 'is not', null).where('video_link', '!=', '');
			if (filters.hasVideo === false)
				qb = qb.where((eb) => eb.or([eb('video_link', 'is', null), eb('video_link', '=', '')]));
			if (filters.hasDiagrams === true)
				qb = qb.where(sql`array_length(diagrams, 1) > 0`);
			if (filters.hasDiagrams === false)
				qb = qb.where(sql`diagrams IS NULL OR array_length(diagrams, 1) IS NULL OR array_length(diagrams, 1) = 0`);
			if (filters.hasImages === true) qb = qb.where(sql`array_length(images, 1) > 0`);
            if (filters.hasImages === false)
                qb = qb.where(sql`images IS NULL OR array_length(images, 1) IS NULL OR array_length(images, 1) = 0`);

            return qb;
        };

		const baseQuery = buildDrillBaseQuery();
		const baseQueryForFallback = buildDrillBaseQuery(); // Separate instance for fallback path

		const ftsQueryBuilder = this._buildSearchQuery(
			baseQuery,
			filters.searchQuery,
			'search_vector',
			'english',
			['name', 'brief_description', 'detailed_description'] // Columns for pg_trgm fallback
		);

		// Apply sorting - _executeSearch handles similarity sort for fallback
		let finalQuery = ftsQueryBuilder;
		if (
			!ftsQueryBuilder._ftsAppliedInfo ||
			(options.sortBy && options.sortBy !== 'similarity_score')
		) {
			const validSortColumns = ['name', 'date_created', 'complexity' /* other allowed columns */];
			const sortCol = validSortColumns.includes(sortBy) ? sortBy : 'date_created';
			const direction = sortOrder === 'asc' ? 'asc' : 'desc';
			finalQuery = finalQuery.orderBy(sortCol, direction).orderBy('id', direction); // Add secondary sort by ID
		}

		const { items, usedFallback } = await this._executeSearch(finalQuery, baseQueryForFallback, {
			limit,
			offset
		});

		await this._addVariationCounts(items); // Add variation counts to results

		// Count total items matching the successful search strategy
		let countQueryBaseForFiltersOnly = buildDrillBaseQuery(); // Rebuild for count to ensure filters are clean
		// We need a new Kysely instance for count that doesn't have prior .selectAll()
		let countQuery = kyselyDb
			.selectFrom('drills')
			.select(kyselyDb.fn.count('drills.id').as('total'));

		// Apply WHERE clauses from countQueryBaseForFiltersOnly to the new countQuery
		// This is a bit manual; Kysely doesn't have a direct way to copy just WHERE clauses.
		// We re-apply filters based on the logic in buildDrillBaseQuery and search conditions.

		// Re-apply visibility/ownership from buildDrillBaseQuery structure
		if (this.useStandardPermissions && this.permissionConfig) {
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			countQuery = countQuery.where((eb) => {
				const conditions = [
					eb(visibilityColumn, '=', publicValue),
					eb(visibilityColumn, '=', unlistedValue)
				];
				if (userId) {
					conditions.push(
						eb.and([eb(visibilityColumn, '=', privateValue), eb(userIdColumn, '=', userId)])
					);
				}
				return eb.or(conditions);
			});
		}
		// Re-apply specific drill filters
        if (filters.skill_level?.length)
            countQuery = countQuery.where(sql`skill_level && ${sql.array(filters.skill_level, 'text')}`);
		// Handle complexity as either array or string for backward compatibility
		if (Array.isArray(filters.complexity) && filters.complexity.length) {
			countQuery = countQuery.where('complexity', 'in', filters.complexity);
		} else if (typeof filters.complexity === 'string' && filters.complexity) {
			countQuery = countQuery.where('complexity', '=', filters.complexity);
		}
        if (filters.skills_focused_on?.length)
            countQuery = countQuery.where(sql`skills_focused_on && ${sql.array(filters.skills_focused_on, 'text')}`);
        if (filters.positions_focused_on?.length)
            countQuery = countQuery.where(sql`positions_focused_on && ${sql.array(filters.positions_focused_on, 'text')}`);
        if (filters.drill_type?.length)
            countQuery = countQuery.where(sql`drill_type && ${sql.array(filters.drill_type, 'text')}`);
		if (filters.number_of_people_min != null)
			countQuery = countQuery.where('number_of_people_min', '>=', filters.number_of_people_min);
		if (filters.number_of_people_max != null)
			countQuery = countQuery.where('number_of_people_max', '<=', filters.number_of_people_max);
		if (filters.suggested_length_min != null)
			countQuery = countQuery.where('suggested_length_min', '>=', filters.suggested_length_min);
		if (filters.suggested_length_max != null)
			countQuery = countQuery.where('suggested_length_max', '<=', filters.suggested_length_max);
		if (filters.hasVideo === true)
			countQuery = countQuery.where('video_link', 'is not', null).where('video_link', '!=', '');
		if (filters.hasVideo === false)
			countQuery = countQuery.where((eb) =>
				eb.or([eb('video_link', 'is', null), eb('video_link', '=', '')])
			);
		if (filters.hasDiagrams === true)
			countQuery = countQuery.where(
				sql`array_length(diagrams, 1) > 0`
			);
		if (filters.hasDiagrams === false)
			countQuery = countQuery.where(
				sql`diagrams IS NULL OR array_length(diagrams, 1) IS NULL OR array_length(diagrams, 1) = 0`
			);
		if (filters.hasImages === true) countQuery = countQuery.where(sql`array_length(images, 1) > 0`);
		if (filters.hasImages === false)
			countQuery = countQuery.where(sql`images IS NULL OR array_length(images, 1) IS NULL OR array_length(images, 1) = 0`);

		if (filters.searchQuery) {
			const cleanedSearchTerm = filters.searchQuery.trim();
			if (cleanedSearchTerm) {
				if (usedFallback) {
					countQuery = countQuery.where((eb) =>
						eb.or([
							eb(sql`similarity(name, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(brief_description, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(detailed_description, ${cleanedSearchTerm})`, '>', 0.3)
						])
					);
				} else {
					const tsQuerySearchTerm = cleanedSearchTerm
						.split(/\s+/)
						.filter(Boolean)
						.map((term) => term + ':*')
						.join(' & ');
					if (tsQuerySearchTerm) {
						countQuery = countQuery.where(
							sql`search_vector @@ to_tsquery('english', ${tsQuerySearchTerm})`
						);
					}
				}
			}
		}

		const countResult = await countQuery.executeTakeFirst();
		const totalItems = parseInt(countResult?.total ?? '0', 10);

		const formattedItems = items.map(denormalizeDrillForResponse);

		return {
			items: formattedItems,
			pagination: {
				page: parseInt(page),
				limit: parseInt(limit),
				totalItems,
				totalPages: Math.ceil(totalItems / limit)
			}
		};
	}

	/**
	 * Helper method to add variation counts to an array of drills
	 * @param {Array<Object>} drills - Array of drill objects
	 * @returns {Promise<void>}
	 * @private
	 */
	async _addVariationCounts(drills) {
		if (!drills || !drills.length) return;

		try {
			// Get all drill IDs
			const drillIds = drills.map((drill) => drill.id);

			// Get variation counts for all drills in a single query
			const query = `
        SELECT parent_drill_id, COUNT(*) AS count
        FROM drills
        WHERE parent_drill_id = ANY($1)
        GROUP BY parent_drill_id
      `;

			const result = await db.query(query, [drillIds]);

			// Create a map of drill ID to variation count
			const countMap = {};

			// Safely process query results
			if (result && result.rows) {
				result.rows.forEach((row) => {
					countMap[row.parent_drill_id] = parseInt(row.count);
				});
			}

			// Set variation counts on drill objects
			drills.forEach((drill) => {
				drill.variation_count = countMap[drill.id] || 0;
			});
		} catch (error) {
			console.error('Error while adding variation counts:', error);
			// Don't let variation count errors disrupt the main functionality
			// Just ensure all drills have a variation_count property
			drills.forEach((drill) => {
				if (!drill.hasOwnProperty('variation_count')) {
					drill.variation_count = 0;
				}
			});
		}
	}

	/**
	 * Fetches all drill names and their IDs.
	 * Used for mapping generated names to existing drills or providing context.
	 * @returns {Promise<Array<{id: number, name: string}>>}
	 */
	async getAllDrillNames() {
		try {
			const drills = await kyselyDb
				.selectFrom('drills')
				.select(['id', 'name'])
				.orderBy('name', 'asc')
				.execute();

			return drills;
		} catch (error) {
			console.error('Error fetching drill names:', error);
			// Consider throwing a specific error type
			throw new DatabaseError('Failed to fetch drill names', error);
		}
	}

	/**
	 * Fetches detailed information for drills, suitable for AI context.
	 * Excludes large fields like diagrams.
	 * @param {number|null} [userId=null] - The ID of the user requesting the drills.
	 * @returns {Promise<Array<Object>>} - Array of drill detail objects.
	 */
	async getAllDrillDetailsForAI(userId = null) {
		try {
			// Define columns to select, excluding diagrams and non-existent ones
			const columnsToSelect = [
				'id',
				'name',
				'brief_description',
				'detailed_description',
				'skill_level',
				'complexity',
				'suggested_length_min',
				'suggested_length_max',
				'number_of_people_min',
				'number_of_people_max',
				'skills_focused_on',
				'positions_focused_on',
				'drill_type',
				'visibility',
				'is_editable_by_others'
				// Removed created_by, date_created, parent_id, upload_source, search_vector for brevity
			];

			const drills = await kyselyDb
				.selectFrom('drills')
				.select(columnsToSelect)
				.orderBy('name', 'asc') // Keep ordering consistent
				// Add WHERE clause for visibility/ownership
				.$if(userId !== null, (qb) =>
					qb
						// If userId is provided, get public drills OR drills created by this user
						.where((eb) => eb.or([eb('visibility', '=', 'public'), eb('created_by', '=', userId)]))
				)
				.$if(userId === null, (qb) =>
					qb
						// If no userId (anonymous), only get public drills
						.where('visibility', '=', 'public')
				)
				.execute();

			// No need for JS filtering anymore, SQL handles it.
			return drills;
		} catch (error) {
			console.error('Error fetching detailed drill data for AI:', error);
			throw new DatabaseError('Failed to fetch detailed drill data', error);
		}
	}

	/**
	 * Set a drill as the primary variant
	 * @param {number} drillId - Drill ID to make primary
	 * @param {number} userId - User attempting the action
	 * @returns {Promise<Object>} - Updated drill
	 * @throws {NotFoundError} - If drill not found
	 * @throws {ValidationError} - If the drill is not a variation
	 * @throws {ForbiddenError} - If user not authorized
	 */
	async setAsPrimaryVariant(drillId, userId) {
		return this.withTransaction(async (client) => {
			const drill = await this.getById(drillId, ['*', 'parent_drill_id'], userId, client);
			if (!drill) {
				// Throw NotFoundError instead of generic Error
				throw new NotFoundError('Drill not found');
			}

			if (!drill.parent_drill_id) {
				// Throw ValidationError instead of generic Error
				throw new ValidationError('This drill is not a variation');
			}

			const parentDrill = await this.getById(drill.parent_drill_id, ['*'], userId, client);
			// Add check for parentDrill existence (though getById should handle it)
			if (!parentDrill) {
				throw new NotFoundError('Parent drill not found');
			}

			// Safer approach: keep IDs stable and swap content/roles only
			// 1) Copy content fields from variant (drill) to primary (parentDrill)
			const fields = [
				'name',
				'brief_description',
				'detailed_description',
				'skill_level',
				'complexity',
				'number_of_people_min',
				'number_of_people_max',
				'skills_focused_on',
				'positions_focused_on',
				'drill_type',
				'video_link',
				'diagrams',
				'images'
			];

			// Compute skill count diffs before update
			const oldSkills = parentDrill.skills_focused_on || [];
			const newSkills = drill.skills_focused_on || [];

			const setSql = fields.map((f, i) => `${f} = $${i + 3}`).join(', ');
			await client.query(`UPDATE drills SET ${setSql} WHERE id = $1`, [
				parentDrill.id,
				null,
				...fields.map((f) => drill[f])
			]);

			// Update votes.item_name if name changed on primary
			if (drill.name && drill.name !== parentDrill.name) {
				await client.query(`UPDATE votes SET item_name = $1 WHERE drill_id = $2`, [
					drill.name,
					parentDrill.id
				]);
			}

			// 2) Rewire children of the variant to the primary
			await client.query('UPDATE drills SET parent_drill_id = $1 WHERE parent_drill_id = $2', [
				parentDrill.id,
				drill.id
			]);

			// 3) Ensure the variant remains a child of primary
			await client.query('UPDATE drills SET parent_drill_id = $1 WHERE id = $2', [
				parentDrill.id,
				drill.id
			]);

			// 4) Adjust skill usage counts based on diff
			const skillsToRemove = oldSkills.filter((s) => !newSkills.includes(s));
			const skillsToAdd = newSkills.filter((s) => !oldSkills.includes(s));
			await this.updateSkillCounts(skillsToAdd, skillsToRemove, parentDrill.id, client);

			// Return the updated primary drill with new content
			return this.getById(parentDrill.id, ['*'], userId, client);
		});
	}

	/**
	 * Update skills usage counts
	 * @param {Array<string>} skillsToAdd - Skills to increment
	 * @param {Array<string>} skillsToRemove - Skills to decrement
	 * @param {number} drillId - Drill ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>}
	 */
	async updateSkillCounts(skillsToAdd, skillsToRemove, drillId, client = null) {
		const dbInterface = client || db;
		// Add new skills
		if (skillsToAdd && skillsToAdd.length > 0) {
			// Pass client to updateSkills
			await this.updateSkills(skillsToAdd, drillId, client);
		}

		// Remove skills no longer used
		if (skillsToRemove && skillsToRemove.length > 0) {
			for (const skill of skillsToRemove) {
				await dbInterface.query(
					// Use dbInterface (client or db)
					`UPDATE skills SET drills_used_in = drills_used_in - 1 WHERE skill = $1`,
					[skill]
				);
			}
		}
	}

	/**
	 * Update skills for a drill
	 * @param {Array<string>} skills - Skills to update
	 * @param {number} drillId - Drill ID
	 * @param {pg.Client} [client=null] - Optional DB client for transactions
	 * @returns {Promise<void>}
	 */
	async updateSkills(skills, drillId, client = null) {
		// Use the provided client or the default db module
		const dbInterface = client || db;

		for (const skill of skills) {
			await upsertSkillCounts(dbInterface, skill, drillId);
		}
	}

	/**
	 * Toggle upvote for a drill
	 * @param {number} drillId - Drill ID
	 * @param {number} userId - User ID performing the upvote
	 * @returns {Promise<Object>} - Updated vote count
	 * @throws {ValidationError} - If IDs are missing
	 * @throws {NotFoundError} - If drill not found
	 */
	async toggleUpvote(drillId, userId) {
		if (!drillId || !userId) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('Both drill ID and user ID are required');
		}

		return this.withTransaction(async (client) => {
			// First verify the drill exists using the base method (which might throw NotFoundError itself)
			try {
				// Pass undefined for columns to use default, null for userId, then the client
				await this.getById(drillId, undefined, null, client);
			} catch (err) {
				if (err instanceof NotFoundError) {
					throw new NotFoundError('Drill not found for upvoting');
				}
				throw err; // Re-throw other unexpected errors
			}

			// Check if user has already voted
			const voteCheckQuery = `
        SELECT * FROM votes 
        WHERE user_id = $1 AND drill_id = $2
      `;
			const voteCheck = await client.query(voteCheckQuery, [userId, drillId]);

			if (voteCheck.rows.length > 0) {
				// User has already voted, remove their vote
				await client.query('DELETE FROM votes WHERE user_id = $1 AND drill_id = $2', [
					userId,
					drillId
				]);
			} else {
				// Add new vote
				await client.query('INSERT INTO votes (user_id, drill_id, vote) VALUES ($1, $2, $3)', [
					userId,
					drillId,
					1
				]);
			}

			// Get updated vote count
			const voteCountQuery = `
        SELECT COUNT(CASE WHEN vote = 1 THEN 1 END) as upvotes
        FROM votes 
        WHERE drill_id = $1
      `;
			const result = await client.query(voteCountQuery, [drillId]);

			return {
				upvotes: parseInt(result.rows[0].upvotes),
				hasVoted: voteCheck.rows.length === 0 // True if we just added a vote
			};
		});
	}

	/**
	 * Set variant relationship for a drill
	 * @param {number} drillId - Drill ID to update
	 * @param {number|null} parentDrillId - Parent drill ID or null to remove the relationship
	 * @returns {Promise<Object>} - Updated drill with variant relationship
	 * @throws {ValidationError} - If drill ID is missing
	 * @throws {NotFoundError} - If drill or parent drill not found
	 * @throws {ConflictError} - If trying to make a parent a variant, or a variant a parent, or self-parenting
	 */
	async setVariant(drillId, parentDrillId) {
		if (!drillId) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('Drill ID is required');
		}

		return this.withTransaction(async (client) => {
			// Check if the current drill exists and get its details
			const drillQuery = `
        SELECT d.*, 
               (SELECT COUNT(*) FROM drills WHERE parent_drill_id = d.id) as child_count
        FROM drills d 
        WHERE d.id = $1
      `;
			const drillResult = await client.query(drillQuery, [drillId]);

			if (drillResult.rows.length === 0) {
				// Throw NotFoundError instead of generic Error
				throw new NotFoundError('Drill not found');
			}

			const currentDrill = drillResult.rows[0];

			if (parentDrillId) {
				// Check if the parent drill exists and is valid
				const parentQuery = `
          SELECT d.*, 
                 (SELECT COUNT(*) FROM drills WHERE parent_drill_id = d.id) as child_count
          FROM drills d 
          WHERE d.id = $1
        `;
				const parentResult = await client.query(parentQuery, [parentDrillId]);

				if (parentResult.rows.length === 0) {
					// Throw NotFoundError instead of generic Error
					throw new NotFoundError('Parent drill not found');
				}

				const parentDrill = parentResult.rows[0];

				// Validate constraints
				if (currentDrill.child_count > 0) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Cannot make a parent drill into a variant');
				}

				if (parentDrill.parent_drill_id) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Cannot set a variant as a parent');
				}

				// Prevent drill from being its own parent
				if (parentDrillId === drillId) {
					// Throw ConflictError instead of generic Error
					throw new ConflictError('Drill cannot be its own parent');
				}
			}

			// Update the parent_drill_id
			const updateQuery = `
        UPDATE drills 
        SET parent_drill_id = $1 
        WHERE id = $2 
        RETURNING *, 
          (SELECT name FROM drills WHERE id = $1) as parent_drill_name
      `;
			const result = await client.query(updateQuery, [parentDrillId, drillId]);

			return result.rows[0];
		});
	}

	/**
	 * Normalize drill data for consistent database storage
	 * @param {Object} data - Raw drill data
	 * @returns {Object} - Normalized data
	 */
	normalizeDrillData(data) {
		let normalizedData = { ...data };

		// Remove id field if it's null or undefined
		if (normalizedData.id === null || normalizedData.id === undefined) {
			delete normalizedData.id;
		}

		// Use base helper to normalize array fields to ensure they are arrays
		normalizedData = this.normalizeArrayFields(normalizedData, this.arrayFields);

		// --- Map number_of_people object to min/max columns ---
		if (normalizedData.number_of_people && typeof normalizedData.number_of_people === 'object') {
			const { min, max } = normalizedData.number_of_people;

			if (
				normalizedData.number_of_people_min === undefined ||
				normalizedData.number_of_people_min === ''
			) {
				const parsedMin = parseInt(min);
				normalizedData.number_of_people_min = !isNaN(parsedMin) ? parsedMin : null;
			}

			if (
				normalizedData.number_of_people_max === undefined ||
				normalizedData.number_of_people_max === ''
			) {
				const parsedMax = parseInt(max);
				normalizedData.number_of_people_max = !isNaN(parsedMax) ? parsedMax : null;
			}

			delete normalizedData.number_of_people;
		}

		// Convert diagrams to JSON strings (only if not already strings)
		if (normalizedData.diagrams && Array.isArray(normalizedData.diagrams)) {
			normalizedData.diagrams = normalizedData.diagrams.map((diagram) =>
				typeof diagram === 'object' && diagram !== null ? JSON.stringify(diagram) : diagram
			);
		} else if (normalizedData.diagrams === null || normalizedData.diagrams === undefined) {
			// Ensure it's an empty array if null/undefined before DB insert
			normalizedData.diagrams = [];
		}

		// For enum-like array fields, ensure items are trimmed. Lowercasing is re-added.
		['skill_level', 'skills_focused_on', 'positions_focused_on', 'drill_type'].forEach((field) => {
			if (normalizedData[field] && Array.isArray(normalizedData[field])) {
				normalizedData[field] = normalizedData[field]
					.map(
						(item) => (typeof item === 'string' ? item.trim().toLowerCase() : item) // RE-ADDED .toLowerCase()
					)
					.filter(Boolean); // Remove empty strings after trimming
			} else if (normalizedData[field] === null || normalizedData[field] === undefined) {
				normalizedData[field] = [];
			}
		});

		// Ensure images is an array
		if (normalizedData.images === null || normalizedData.images === undefined) {
			normalizedData.images = [];
		}

		// Handle special number fields
		if (
			normalizedData.number_of_people_max === '' ||
			normalizedData.number_of_people_max === undefined
		) {
			normalizedData.number_of_people_max = null;
		} else {
			const parsedMax = parseInt(normalizedData.number_of_people_max);
			normalizedData.number_of_people_max = !isNaN(parsedMax) ? parsedMax : null;
		}

		if (
			normalizedData.number_of_people_min === '' ||
			normalizedData.number_of_people_min === undefined
		) {
			normalizedData.number_of_people_min = null;
		} else {
			const parsedMin = parseInt(normalizedData.number_of_people_min);
			normalizedData.number_of_people_min = !isNaN(parsedMin) ? parsedMin : null;
		}

		// --- Map suggested_length object to min/max columns ---
		if (normalizedData.suggested_length && typeof normalizedData.suggested_length === 'object') {
			const { min, max } = normalizedData.suggested_length;

			const parsedMin = parseInt(min);
			const parsedMax = parseInt(max);

			normalizedData.suggested_length_min = !isNaN(parsedMin) ? parsedMin : null;
			normalizedData.suggested_length_max = !isNaN(parsedMax) ? parsedMax : null;

			// Remove the original object
			delete normalizedData.suggested_length;
		} else {
			// Ensure columns exist even if input object is missing/invalid
			if (!normalizedData.hasOwnProperty('suggested_length_min')) {
				normalizedData.suggested_length_min = null;
			}
			if (!normalizedData.hasOwnProperty('suggested_length_max')) {
				normalizedData.suggested_length_max = null;
			}
			// Still remove the original field if it existed but wasn't an object
			if (normalizedData.hasOwnProperty('suggested_length')) {
				delete normalizedData.suggested_length;
			}
		}

		return normalizedData;
	}

	/**
	 * Associate an anonymously created drill with a user
	 * @param {number} id - Drill ID
	 * @param {number} userId - User ID to associate with
	 * @returns {Promise<Object>} - The updated drill
	 * @throws {NotFoundError} - If drill not found
	 */
	async associateDrill(id, userId) {
		const drill = await this.getById(id);

		if (!drill) {
			// getById should throw NotFoundError, but double-check
			throw new NotFoundError('Drill not found for association');
		}

		// Check if already owned
		if (drill.created_by !== null) {
			// Return existing drill if already owned
			return drill;
		}

		// Update the created_by field
		return await this.update(id, { created_by: userId });
	}

	/**
	 * Import multiple drills from an array.
	 * @param {Array<Object>} drillsData - Array of drill objects to import.
	 * @param {string} fileName - Original name of the file being imported.
	 * @param {number|null} userId - ID of the user performing the import.
	 * @param {string} visibility - Default visibility for imported drills.
	 * @returns {Promise<Object>} - Object containing importedCount and uploadSource.
	 * @throws {ValidationError} - If input data is invalid or missing required fields
	 * @throws {DatabaseError} - If database insertion fails
	 */
	async importDrills(drillsData, fileName, userId, visibility = 'public') {
		if (!Array.isArray(drillsData) || drillsData.length === 0) {
			// Throw ValidationError instead of generic Error
			throw new ValidationError('No drills provided for import');
		}

		// Generate a unique upload_source ID (using timestamp + partial UUID for uniqueness)
		const uploadSource = `${fileName}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;

		return this.withTransaction(async (client) => {
			try {
				const insertPromises = drillsData.map(async (drillInput) => {
					// Mark inner function as async
					// Destructure and prepare data for insertion
					const {
						name,
						brief_description,
						detailed_description,
						skill_level,
						complexity,
						suggested_length, // Keep the object here initially
						number_of_people,
						skills_focused_on,
						positions_focused_on,
						video_link,
						images,
						diagrams,
						drill_type // Add drill_type
					} = drillInput;

					// Basic validation for required fields within the service
					if (!name || !brief_description) {
						// Throw ValidationError instead of generic Error
						throw new ValidationError(
							`Drill missing required field (name or brief_description): ${JSON.stringify(drillInput)}`
						);
					}

					// Prepare data object for normalization
					let drillToNormalize = {
						name,
						brief_description,
						detailed_description: detailed_description || null,
						skill_level,
						complexity: complexity || null,
						suggested_length: suggested_length, // Pass the object for normalization
						number_of_people_min: number_of_people?.min, // Extract min/max before normalization handles defaults
						number_of_people_max: number_of_people?.max,
						skills_focused_on,
						positions_focused_on,
						drill_type, // Include drill_type
						video_link: video_link || null,
						images: images || [],
						diagrams: diagrams || [], // Ensure diagrams is an array
						upload_source: uploadSource,
						created_by: userId,
						visibility,
						is_editable_by_others: false, // Default for imported drills
						date_created: new Date() // Add creation timestamp
					};

					// Normalize the individual drill data
					let drillToInsert = this.normalizeDrillData(drillToNormalize);

					// Use base create method logic for consistency
					// Assuming base `create` can work within the transaction using the passed client.
					// Ensure base `create` accepts a client argument.
					return this.create(drillToInsert, client);
				});

				// Wait for all insertions to complete
				const results = await Promise.all(insertPromises);
				// The base `create` method now returns the created object directly (not wrapped in rows)
				const insertedDrills = results;

				// Optionally, update skill counts for all imported drills
				for (const drill of insertedDrills) {
					if (drill.skills_focused_on && drill.skills_focused_on.length > 0) {
						// Use the existing updateSkills method, passing the client for transaction safety
						await this.updateSkills(drill.skills_focused_on, drill.id, client);
					}
				}

				return { importedCount: drillsData.length, uploadSource };
			} catch (error) {
				// Add specific error wrapping for import failures
				if (
					error instanceof ValidationError ||
					error instanceof DatabaseError ||
					error instanceof AppError
				) {
					throw error; // Re-throw known app errors
				}
				console.error('Error during bulk drill import:', error);
				throw new DatabaseError('Failed during bulk drill import.', error);
			}
		});
	}
}

// Export a singleton instance of the service
export const drillService = new DrillService();
</file>

<file path="src/lib/server/services/practicePlanService.js">
import { BaseEntityService } from './baseEntityService.js';
import { kyselyDb } from '$lib/server/db'; // Import Kysely instance
import { jsonObjectFrom } from 'kysely/helpers/postgres';
import { sql } from 'kysely'; // Import sql tag
import {
	NotFoundError,
	ForbiddenError,
	ValidationError,
	DatabaseError,
	ConflictError
} from '$lib/server/errors';
import { z } from 'zod'; // Import Zod
import { practicePlanSchema } from '$lib/validation/practicePlanSchema'; // Import the Zod schema
import { dev } from '$app/environment';

/**
 * Service for managing practice plans
 * Extends the BaseEntityService with practice plan-specific functionality
 */
export class PracticePlanService extends BaseEntityService {
	/**
	 * Creates a new PracticePlanService
	 */
	constructor() {
		const allowedColumns = [
			'name',
			'description',
			'practice_goals',
			'phase_of_season',
			'estimated_number_of_participants',
			'created_by',
			'visibility',
			'is_editable_by_others',
			'start_time',
			'created_at',
			'updated_at',
			'search_vector' // Add search_vector for FTS
		];

		const columnTypes = {
			practice_goals: 'array' // Assuming practice_goals is stored as text[]
		};

		// Configure standard permissions (using default column names/values)
		const permissionConfig = {
			// userIdColumn: 'created_by', // default
			// visibilityColumn: 'visibility', // default
			// publicValue: 'public', // default
			// unlistedValue: 'unlisted', // default
			// privateValue: 'private', // default
			// editableByOthersColumn: 'is_editable_by_others' // default
		};

		super('practice_plans', 'id', ['*'], allowedColumns, columnTypes, permissionConfig);
	}

	/**
	 * Get practice plans with optional filtering/pagination/sorting
	 * @param {Object} options - Options for fetching plans
	 * @param {number} [options.userId=null] - User ID for visibility checks
	 * @param {number} [options.page=1] - Page number
	 * @param {number} [options.limit=10] - Items per page
	 * @param {string} [options.sortBy='created_at'] - Field to sort by
	 * @param {'asc' | 'desc'} [options.sortOrder='desc'] - Sort order
	 * @param {Object} [options.filters={}] - Filtering criteria
	 * @param {string[]} [options.filters.phase_of_season] - Filter by phase of season
	 * @param {string[]} [options.filters.practice_goals] - Filter by practice goals
	 * @param {number} [options.filters.min_participants] - Min estimated participants
	 * @param {number} [options.filters.max_participants] - Max estimated participants
	 * @param {number[]} [options.filters.drill_ids] - Filter by contained drill IDs
	 * @param {string} [options.filters.searchQuery] - Search query for name/description
	 * @returns {Promise<{items: Array<Object>, pagination: Object}>} - List of plans and pagination info
	 */
	async getAll(options = {}) {
		const {
			userId = null,
			page = 1,
			limit = 10,
			sortBy = 'upvotes',
			sortOrder = 'desc',
			filters = {}
		} = options;

		const offset = (page - 1) * limit;

		// Helper to build the base query (before search and pagination)
		const buildBaseQueryWithFilters = () => {
			let q = kyselyDb
				.selectFrom('practice_plans as pp')
				.leftJoin('practice_plan_drills as ppd', 'pp.id', 'ppd.practice_plan_id')
				.leftJoin('votes as v', (join) => 
					join.onRef('pp.id', '=', 'v.practice_plan_id').on('v.vote', '=', 1)
				)
				.select([
					'pp.id',
					'pp.name',
					'pp.description',
					'pp.practice_goals',
					'pp.phase_of_season',
					'pp.estimated_number_of_participants',
					'pp.created_by',
					'pp.visibility',
					'pp.is_editable_by_others',
					'pp.start_time',
					'pp.team_id',
					'pp.season_id',
					'pp.scheduled_date',
					'pp.created_at',
					'pp.updated_at'
				])
				.select(sql`array_agg(DISTINCT ppd.drill_id)`.as('drills'))
				.select(sql`COALESCE(COUNT(DISTINCT v.id), 0)`.as('upvote_count'))
				.groupBy('pp.id');

			// Apply visibility filters from permissionConfig
			const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
				this.permissionConfig;
			q = q.where((eb) => {
				const conditions = [
					eb(`pp.${visibilityColumn}`, '=', publicValue),
					eb(`pp.${visibilityColumn}`, '=', unlistedValue)
				];
				if (userId) {
					conditions.push(
						eb.and([
							eb(`pp.${visibilityColumn}`, '=', privateValue),
							eb(`pp.${userIdColumn}`, '=', userId)
						])
					);
				}
				return eb.or(conditions);
			});

			// For public listing, exclude team-specific draft plans
			// Team plans with team_id should be filtered differently
			if (!filters.team_id) {
				// Only exclude drafts that belong to teams (have team_id)
				// Public practice plans without team_id can be shown even if draft
				q = q.where((eb) => 
					eb.or([
						eb('pp.team_id', 'is', null),  // Public plans without teams
						eb('pp.status', '!=', 'draft')  // Or non-draft plans
					])
				);
			}

			// Apply specific filters (excluding search, which is handled by _buildSearchQuery)
			// Add support for team_id and scheduled_date filters
			if (filters.team_id) {
				q = q.where('pp.team_id', '=', filters.team_id);
			}
			if (filters.scheduled_date) {
				q = q.where('pp.scheduled_date', '=', filters.scheduled_date);
			}
			if (filters.is_template !== undefined) {
				q = q.where('pp.is_template', '=', filters.is_template);
			}
			if (filters.phase_of_season?.required?.length) {
				q = q.where('pp.phase_of_season', 'in', filters.phase_of_season.required);
			}
			if (filters.phase_of_season?.excluded?.length) {
				q = q.where('pp.phase_of_season', 'not in', filters.phase_of_season.excluded);
			}
			if (filters.practice_goals?.required?.length) {
				filters.practice_goals.required.forEach((goal) => {
					q = q.where(sql`pp.practice_goals @> ${sql.array([goal], 'text')}`);
				});
			}
			if (filters.practice_goals?.excluded?.length) {
				q = q.where(sql`NOT (pp.practice_goals && ${sql.array(filters.practice_goals.excluded, 'text')})`);
			}
			if (filters.min_participants != null) {
				q = q.where('pp.estimated_number_of_participants', '>=', filters.min_participants);
			}
			if (filters.max_participants != null) {
				q = q.where('pp.estimated_number_of_participants', '<=', filters.max_participants);
			}
			if (filters.drill_ids?.length) {
				q = q.where((eb) =>
					eb.exists(
						eb
							.selectFrom('practice_plan_drills as sub_ppd')
							.select(sql`1`.as('one'))
							.whereRef('sub_ppd.practice_plan_id', '=', 'pp.id')
							.where('sub_ppd.drill_id', 'in', filters.drill_ids)
							.groupBy('sub_ppd.practice_plan_id')
							.having(sql`count(DISTINCT sub_ppd.drill_id)`, '=', filters.drill_ids.length)
					)
				);
			}
			return q;
		};

		// --- Main Query Execution ---
		const baseQuery = buildBaseQueryWithFilters();
		// Clone baseQuery for fallback, as _buildSearchQuery modifies its input and _executeSearch might clear its where clause
		const baseQueryForFallback = buildBaseQueryWithFilters();

		const ftsQuery = this._buildSearchQuery(
			baseQuery, // Pass the original baseQuery here
			filters.searchQuery,
			'search_vector',
			'english',
			['name', 'description'], // Columns for pg_trgm fallback
			0.3 // Trigram threshold
		);

		// Execute first to determine whether fallback was used and avoid use-before-definition
		let finalQuery = ftsQuery;
		const executed = await this._executeSearch(finalQuery, baseQueryForFallback, {
			limit,
			offset
		});
		let { items, usedFallback } = executed;

		// If fallback used, similarity ordering is already applied by _executeSearch
		// Otherwise, apply standard sorting and re-execute to get correctly ordered items
		if (!usedFallback) {
			const validSortColumns = [
				'name',
				'created_at',
				'estimated_number_of_participants',
				'updated_at',
				'upvotes'
			];
			const sortCol = validSortColumns.includes(sortBy) ? sortBy : 'upvotes';
			const direction = sortOrder === 'asc' ? 'asc' : 'desc';

			if (sortCol === 'upvotes') {
				finalQuery = finalQuery.orderBy('upvote_count', direction);
			} else {
				finalQuery = finalQuery.orderBy(`pp.${sortCol}`, direction);
			}

			const reexecuted = await this._executeSearch(finalQuery, baseQueryForFallback, {
				limit,
				offset
			});
			items = reexecuted.items;
		}

		// --- Count Query Execution ---
		let countQuery = kyselyDb
			.selectFrom('practice_plans as pp') // Must match the alias used in buildBaseQueryWithFilters if reusing parts of it
			.select(kyselyDb.fn.count('pp.id').distinct().as('total'));

		// Apply the same non-search filters to countQuery as were applied to baseQuery
		const { visibilityColumn, publicValue, unlistedValue, privateValue, userIdColumn } =
			this.permissionConfig;
		countQuery = countQuery.where((eb) => {
			const conditions = [
				eb(`pp.${visibilityColumn}`, '=', publicValue),
				eb(`pp.${visibilityColumn}`, '=', unlistedValue)
			];
			if (userId) {
				conditions.push(
					eb.and([
						eb(`pp.${visibilityColumn}`, '=', privateValue),
						eb(`pp.${userIdColumn}`, '=', userId)
					])
				);
			}
			return eb.or(conditions);
		});
		
		// For public listing count, exclude team-specific draft plans
		if (!filters.team_id) {
			countQuery = countQuery.where((eb) => 
				eb.or([
					eb('pp.team_id', 'is', null),  // Public plans without teams
					eb('pp.status', '!=', 'draft')  // Or non-draft plans
				])
			);
		}
		
		// Add support for team_id and scheduled_date filters in count query
		if (filters.team_id) {
			countQuery = countQuery.where('pp.team_id', '=', filters.team_id);
		}
		if (filters.scheduled_date) {
			countQuery = countQuery.where('pp.scheduled_date', '=', filters.scheduled_date);
		}
		if (filters.is_template !== undefined) {
			countQuery = countQuery.where('pp.is_template', '=', filters.is_template);
		}
		if (filters.phase_of_season?.required?.length) {
			countQuery = countQuery.where('pp.phase_of_season', 'in', filters.phase_of_season.required);
		}
		if (filters.phase_of_season?.excluded?.length) {
			countQuery = countQuery.where(
				'pp.phase_of_season',
				'not in',
				filters.phase_of_season.excluded
			);
		}
		if (filters.practice_goals?.required?.length) {
			filters.practice_goals.required.forEach((goal) => {
				countQuery = countQuery.where(sql`pp.practice_goals @> ${sql.array([goal], 'text')}`);
			});
		}
		if (filters.practice_goals?.excluded?.length) {
			countQuery = countQuery.where(
				sql`NOT (pp.practice_goals && ${sql.array(filters.practice_goals.excluded, 'text')})`
			);
		}
		if (filters.min_participants != null) {
			countQuery = countQuery.where(
				'pp.estimated_number_of_participants',
				'>=',
				filters.min_participants
			);
		}
		if (filters.max_participants != null) {
			countQuery = countQuery.where(
				'pp.estimated_number_of_participants',
				'<=',
				filters.max_participants
			);
		}
		if (filters.drill_ids?.length) {
			countQuery = countQuery.where((eb) =>
				eb.exists(
					eb
						.selectFrom('practice_plan_drills as sub_ppd')
						.select(sql`1`.as('one'))
						.whereRef('sub_ppd.practice_plan_id', '=', 'pp.id')
						.where('sub_ppd.drill_id', 'in', filters.drill_ids)
						.groupBy('sub_ppd.practice_plan_id')
						.having(sql`count(DISTINCT sub_ppd.drill_id)`, '=', filters.drill_ids.length)
				)
			);
		}

		// Apply the correct search condition to the count query based on what was used for items
		if (filters.searchQuery) {
			const cleanedSearchTerm = filters.searchQuery.trim();
			if (cleanedSearchTerm) {
				if (usedFallback) {
					countQuery = countQuery.where((eb) =>
						eb.or([
							eb(sql`similarity(pp.name, ${cleanedSearchTerm})`, '>', 0.3),
							eb(sql`similarity(pp.description, ${cleanedSearchTerm})`, '>', 0.3)
						])
					);
				} else {
					const tsQuerySearchTerm = cleanedSearchTerm
						.split(/\s+/)
						.filter(Boolean)
						.map((term) => term + ':*')
						.join(' & ');
					if (tsQuerySearchTerm) {
						countQuery = countQuery.where(
							sql`pp.search_vector @@ to_tsquery('english', ${tsQuerySearchTerm})`
						);
					}
				}
			}
		}

		const countResult = await countQuery.executeTakeFirst();
		const totalItems = parseInt(countResult?.total ?? '0', 10);
		const totalPages = Math.ceil(totalItems / limit);

		return {
			items: items,
			pagination: {
				page: page,
				limit: limit,
				totalItems: totalItems,
				totalPages: totalPages
			}
		};
	}

	/**
	 * Create a new practice plan
	 * @param {Object} planData - Practice plan data
	 * @param {number|null} userId - User ID creating the plan (null if anonymous)
	 * @returns {Promise<Object>} - The created practice plan with ID
	 * @throws {ValidationError} If validation fails
	 * @throws {ForbiddenError} If anonymous user tries to create non-public plan
	 * @throws {DatabaseError} On database error
	 */
	async createPracticePlan(planData, userId = null) {
		// Reinstate validation call - Now using Zod schema at the API boundary, but keep internal check for direct service usage?
		// Decide whether to keep this internal validation. For now, let's assume validation happens *before* calling the service.
		// If direct service calls are possible elsewhere without API validation, this should be reinstated:
		// this.validatePracticePlan(planData);

		// If user is not logged in, force public visibility and editable by others
		if (!userId) {
			planData.visibility = 'public';
			planData.is_editable_by_others = true;
		}

		// Validate visibility
		const validVisibilities = ['public', 'unlisted', 'private'];
		if (!planData.visibility || !validVisibilities.includes(planData.visibility)) {
			// Use ValidationError for invalid visibility input
			throw new ValidationError('Invalid visibility setting provided.', {
				visibility: 'Must be public, unlisted, or private'
			});
		}

		// If user is logged out, they can only create public plans
		if (!userId && planData.visibility !== 'public') {
			// Use ForbiddenError as anonymous users are not allowed this action
			throw new ForbiddenError('Anonymous users can only create public plans');
		}

		const {
			name,
			description,
			practice_goals,
			phase_of_season,
			estimated_number_of_participants,
			is_editable_by_others = false,
			visibility = 'public',
			sections = [],
			start_time = null
		} = planData;

		// Use transaction helper
		return this.withTransaction(async (client) => {
			// Add timestamps and metadata
			const planWithTimestamps = this.addTimestamps(
				{
					name,
					description,
					practice_goals,
					phase_of_season,
					estimated_number_of_participants,
					created_by: userId,
					visibility,
					is_editable_by_others,
					start_time
				},
				true
			);

			// Insert practice plan
			const planResult = await client.query(
				`INSERT INTO practice_plans (
          name, description, practice_goals, phase_of_season, 
          estimated_number_of_participants, created_by, 
          visibility, is_editable_by_others, start_time, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) 
        RETURNING id`,
				[
					planWithTimestamps.name,
					planWithTimestamps.description,
					planWithTimestamps.practice_goals,
					planWithTimestamps.phase_of_season,
					planWithTimestamps.estimated_number_of_participants,
					planWithTimestamps.created_by,
					planWithTimestamps.visibility,
					planWithTimestamps.is_editable_by_others,
					planWithTimestamps.start_time,
					planWithTimestamps.created_at,
					planWithTimestamps.updated_at
				]
			);

			const planId = planResult.rows[0].id;

			// Insert sections and their items
			for (const section of sections) {
				// Validate section data before inserting?
				if (!section || typeof section.name !== 'string' || typeof section.order !== 'number') {
					// Rollback transaction and throw ValidationError
					throw new ValidationError('Invalid section data provided.', {
						section: section?.name || 'unknown'
					});
				}

				const sectionResult = await client.query(
					`INSERT INTO practice_plan_sections 
           (practice_plan_id, name, "order", goals, notes)
           VALUES ($1, $2, $3, $4, $5)
           RETURNING id`,
					[planId, section.name, section.order, section.goals, section.notes]
				);

				const dbSectionId = sectionResult.rows[0].id;

				// Insert items for this section
				if (section.items?.length > 0) {
					for (const [index, item] of section.items.entries()) {
						// Validate item data before inserting?
						if (!item || typeof item.duration !== 'number' || typeof item.type !== 'string') {
							// Rollback transaction and throw ValidationError
							throw new ValidationError('Invalid item data provided in section.', {
								item: item?.name || 'unknown'
							});
						}

						await client.query(
							`INSERT INTO practice_plan_drills 
               (practice_plan_id, section_id, drill_id, formation_id, order_in_plan, duration, type, diagram_data, parallel_group_id, parallel_timeline, group_timelines, name)
               VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,
							[
								planId,
								dbSectionId,
								// Logic for determining drill_id
								(() => {
									// For one-off items, use null
									if (item.type === 'one-off' || (typeof item.id === 'number' && item.id < 0)) {
										return null;
									}
									// For drills, use drill_id, item.id, or drill.id if available
									if (item.type === 'drill') {
										return item.drill_id || item.id || item.drill?.id || null;
									}
									// For other types (e.g., breaks), use null
									return null;
								})(),
								// Logic for determining formation_id
								item.type === 'formation' ? item.formation_id || item.formation?.id || null : null,
								index,
								item.duration,
								// Map 'one-off' type to 'drill' to conform to database constraints
								item.type === 'one-off' || item.type === 'activity' ? 'drill' : item.type,
								item.diagram_data,
								item.parallel_group_id,
								item.parallel_timeline,
								item.groupTimelines || item.group_timelines
									? `{${(item.groupTimelines || item.group_timelines).join(',')}}`
									: null,
								// Save the name field
								item.name ||
									(item.type === 'drill' && item.drill?.name
										? item.drill.name
										: item.type === 'formation' && item.formation?.name
											? item.formation.name
											: item.type === 'one-off'
												? 'Quick Activity'
												: 'Break')
							]
						);
					}
				}
			}

			return { id: planId };
		}); // Transaction automatically handles rollback on error
	}

	/**
	 * Validate a practice plan using the Zod schema.
	 * This is kept for potential direct service usage, but primary validation should be at API boundary.
	 * @param {Object} plan - Practice plan to validate
	 * @throws {ValidationError} If validation fails
	 */
	validatePracticePlan(plan) {
		const result = practicePlanSchema.safeParse(plan);
		if (!result.success) {
			// Format Zod errors into the structure expected by ValidationError
			const formattedErrors = result.error.flatten().fieldErrors;
			console.warn('[Service Validation Warn] Practice plan validation failed:', formattedErrors);
			throw new ValidationError('Practice plan validation failed', formattedErrors);
		}
		// No return value needed, throws on failure
	}

	/**
	 * Get a practice plan with all its details
	 * @param {number} id - Practice plan ID
	 * @param {number|null} userId - User ID requesting the plan
	 * @returns {Promise<Object>} - Complete practice plan with sections and items
	 * @throws {NotFoundError} If plan not found
	 * @throws {ForbiddenError} If user lacks permission to view
	 * @throws {DatabaseError} On database error
	 */
	async getPracticePlanById(id, userId = null) {
		try {
			// First fetch the practice plan using base service method
			// Pass userId here to enforce view permissions early via getById
			// This will throw NotFoundError if the plan doesn't exist.
			// It will throw ForbiddenError if user cannot view.
			const practicePlan = await this.getById(id, ['*'], userId);

			// Fetch sections and items within a transaction for consistency
			return this.withTransaction(async (client) => {
				// Fetch sections
				const sectionsResult = await client.query(
					`SELECT * FROM practice_plan_sections 
           WHERE practice_plan_id = $1 
           ORDER BY "order"`,
					[id]
				);

				// Fetch items with their section assignments
				const itemsResult = await client.query(
					`SELECT 
            ppd.id,
            ppd.practice_plan_id,
            ppd.section_id,
            ppd.drill_id,
	            ppd.formation_id,
	            ppd.order_in_plan,
            ppd.duration AS item_duration,
            ppd.type,
            ppd.name,
            ppd.parallel_group_id,
            ppd.parallel_timeline,
            ppd.diagram_data AS ppd_diagram_data,
            ppd.group_timelines::text[] AS "groupTimelines",
            d.id AS drill_id,
            d.name AS drill_name,
            d.brief_description,
            d.detailed_description,
            d.suggested_length_min,
            d.suggested_length_max,
            d.skill_level,
            d.complexity,
            d.number_of_people_min,
            d.number_of_people_max,
            d.skills_focused_on,
            d.positions_focused_on,
            d.video_link,
            d.diagrams,
	            f.id AS formation_id,
	            f.name AS formation_name,
	            f.brief_description AS formation_brief_description,
	            f.detailed_description AS formation_detailed_description,
	            f.diagrams AS formation_diagrams
	           FROM practice_plan_drills ppd
	           LEFT JOIN drills d ON ppd.drill_id = d.id
	           LEFT JOIN formations f ON ppd.formation_id = f.id
           WHERE ppd.practice_plan_id = $1
           ORDER BY ppd.section_id, ppd.order_in_plan`,
					[id]
				);

				// Organize items by section
				const sections = sectionsResult.rows.map((section) => ({
					...section,
					items: itemsResult.rows
						.filter((item) => item.section_id === section.id)
						.map((item) => this.formatDrillItem(item))
				}));

				// Calculate duration for each section
				sections.forEach((section) => {
					section.duration = this.calculateSectionDuration(section.items);
				});

				// If no sections exist, create a default one
				if (sections.length === 0) {
					const defaultSection = {
						id: 'default',
						name: 'Main Section',
						order: 0,
						goals: [],
						notes: '',
						items: itemsResult.rows.map((item) => this.formatDrillItem(item))
					};
					defaultSection.duration = this.calculateSectionDuration(defaultSection.items);
					sections.push(defaultSection);
				}

				// Add sections to practice plan
				practicePlan.sections = sections;

				return practicePlan;
			}); // End transaction
		} catch (error) {
			// Re-throw known errors (NotFoundError, ForbiddenError from above)
			if (error instanceof NotFoundError || error instanceof ForbiddenError) {
				throw error;
			}
			// Wrap other potential errors (e.g., DB errors during section/item fetch) in DatabaseError
			console.error(`Error fetching practice plan details for ID ${id}:`, error);
			throw new DatabaseError('Failed to fetch practice plan details', error);
		}
	}

	/**
	 * Update a practice plan
	 * @param {number} id - Practice plan ID
	 * @param {Object} planData - Updated practice plan data
	 * @param {number|null} userId - User ID updating the plan
	 * @returns {Promise<Object>} - Updated practice plan
	 * @throws {NotFoundError} If plan not found
	 * @throws {ForbiddenError} If user lacks permission to edit
	 * @throws {ValidationError} If validation fails
	 * @throws {DatabaseError} On database error
	 */
	async updatePracticePlan(id, planData, userId = null) {
		// Validate incoming data structure (basic checks)
		// More specific validation (like visibility) happens later
		if (!planData || typeof planData !== 'object') {
			throw new ValidationError('Invalid update data provided.');
		}

		// Use base canUserEdit which now throws errors
		try {
			await this.canUserEdit(id, userId);
		} catch (error) {
			// Re-throw NotFoundError or ForbiddenError from canUserEdit
			if (error instanceof NotFoundError || error instanceof ForbiddenError) {
				throw error;
			}
			// Wrap other errors (e.g., DB error during permission check) as DatabaseError
			console.error(`Error checking edit permission for plan ${id}:`, error);
			throw new DatabaseError('Failed to check edit permission', error);
		}

		// If anonymous user, force public visibility and editable
		if (!userId) {
			planData.visibility = 'public';
			planData.is_editable_by_others = true;
		}

		// Use transaction helper
		return this.withTransaction(async (client) => {
			// --- Check permissions again inside transaction ---
			await this.canUserEdit(id, userId, client);

			// --- Prepare data for update ---
			// Exclude sections and items from the main plan update data
			const { sections, ...planUpdateData } = planData;
			const planWithTimestamp = this.addTimestamps(planUpdateData, false);

			// Remove fields that shouldn't be directly updated or are handled by permissions/logic
			delete planWithTimestamp.created_by; // Don't allow changing creator
			// visibility and is_editable_by_others might be updated based on logic above

			// --- Update the main practice_plans table using base method ---
			// const result = await client.query(
			//   `UPDATE practice_plans SET
			//    name = $1,
			//    description = $2,
			//    practice_goals = $3,
			//    phase_of_season = $4,
			//    estimated_number_of_participants = $5,
			//    is_editable_by_others = $6,
			//    visibility = $7,
			//    start_time = $8,
			//    updated_at = $9
			//    WHERE id = $10 -- Permission check moved to canUserEdit
			//    RETURNING *`,
			//   [
			//     planWithTimestamp.name,
			//     planWithTimestamp.description,
			//     planWithTimestamp.practice_goals,
			//     planWithTimestamp.phase_of_season,
			//     planWithTimestamp.estimated_number_of_participants,
			//     planWithTimestamp.is_editable_by_others,
			//     planWithTimestamp.visibility,
			//     planWithTimestamp.start_time,
			//     planWithTimestamp.updated_at,
			//     id
			//   ]
			// );

			// Use base update method, passing the client
			const updatedPlan = await this.update(id, planWithTimestamp, client);

			// --- Update sections and drills (delete and re-insert) ---
			// Note: This delete/re-insert is simple but can be inefficient for large plans.
			// A more complex update strategy could compare/update/insert/delete rows individually.

			// Delete existing sections and drills for this plan
			await client.query(`DELETE FROM practice_plan_drills WHERE practice_plan_id = $1`, [id]);
			await client.query(`DELETE FROM practice_plan_sections WHERE practice_plan_id = $1`, [id]);

			// Insert sections
			if (sections?.length > 0) {
				for (const section of sections) {
					// Validate section data before inserting?
					if (!section || typeof section.name !== 'string' || typeof section.order !== 'number') {
						throw new ValidationError('Invalid section data provided during update.', {
							section: section?.name || 'unknown'
						});
					}

					// Insert section
					const sectionResult = await client.query(
						`INSERT INTO practice_plan_sections 
             (practice_plan_id, id, name, "order", goals, notes)
             VALUES ($1, $2, $3, $4, $5, $6)
             RETURNING id`,
						[id, section.id, section.name, section.order, section.goals, section.notes]
					);

					// Insert items with explicit ordering
					if (section.items?.length > 0) {
						for (const [index, item] of section.items.entries()) {
							// Validate item data before inserting?
							if (!item || typeof item.duration !== 'number' || typeof item.type !== 'string') {
								throw new ValidationError('Invalid item data provided in section during update.', {
									item: item?.name || 'unknown'
								});
							}

							await client.query(
								`INSERT INTO practice_plan_drills 
	                 (practice_plan_id, section_id, drill_id, formation_id, order_in_plan, duration, type, 
	                  parallel_group_id, parallel_timeline, group_timelines, name, diagram_data)
	                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,
								[
									id,
									section.id,
									(() => {
										// For one-off items, use null
										if (item.type === 'one-off' || (typeof item.id === 'number' && item.id < 0)) {
											return null;
										}
										// For drills, use drill_id, item.id, or drill.id if available
										if (item.type === 'drill') {
											return item.drill_id || item.id || item.drill?.id || null;
										}
										// For other types (e.g., breaks), use null
										return null;
									})(),
									// Logic for determining formation_id
									// For formation items, use formation_id
									item.type === 'formation'
										? item.formation_id || item.formation?.id || null
										: null,
									index,
									item.duration || item.selected_duration,
									// Map 'one-off' type to 'drill' to conform to database constraints
									item.type === 'one-off' || item.type === 'activity' ? 'drill' : item.type,
									item.parallel_group_id,
									item.parallel_timeline || null,
									item.groupTimelines || item.group_timelines
										? `{${(item.groupTimelines || item.group_timelines).join(',')}}`
										: null,
									// Name field
									item.name ||
										(item.type === 'drill' && item.drill?.name
											? item.drill.name
											: item.type === 'one-off'
												? 'Quick Activity'
												: 'Break'),
									// Diagram data
									item.diagram_data
								]
							);
						}
						// Call resequence after inserting all items for this section
						await this._resequenceItems(section.id, client);
					}
				}
			}

			// Return the result from the base update method
			return updatedPlan;
		}); // Transaction handles rollback
	}

	/**
	 * Resequence the order_in_plan for items within a specific section.
	 * Ensures the order is sequential (0, 1, 2...) based on the current order.
	 * This is a protected method, intended for internal use or subclass overrides, and for testing purposes.
	 * @param {string|number} sectionId - The ID of the section to resequence.
	 * @param {object} client - The database transaction client.
	 * @returns {Promise<void>}
	 * @private // This @private is now more of a convention, as it's _resequenceItems
	 */
	async _resequenceItems(sectionId, client) {
		try {
			// Get item IDs in their current order within the section
			const itemsResult = await client.query(
				`SELECT id 
         FROM practice_plan_drills 
         WHERE section_id = $1 
         ORDER BY order_in_plan ASC`,
				[sectionId]
			);

			const itemIds = itemsResult.rows.map((row) => row.id);

			// If there are items, build and execute an UPDATE query with CASE
			if (itemIds.length > 0) {
				let caseStatement = 'CASE id ';
				const values = [sectionId]; // Start parameters array with sectionId
				itemIds.forEach((id, index) => {
					caseStatement += `WHEN $${values.length + 1} THEN $${values.length + 2} `;
					values.push(id, index); // Add id and new order to parameters
				});
				caseStatement += 'END';

				const updateQuery = `
          UPDATE practice_plan_drills 
          SET order_in_plan = (${caseStatement})::integer
          WHERE section_id = $1 AND id = ANY($${values.length + 1}::int[])`;

				// Add the array of item IDs as the last parameter
				values.push(itemIds);

				await client.query(updateQuery, values);
			}
			// No need to do anything if there are no items
		} catch (error) {
			// Log the error but don't necessarily halt the entire update if resequencing fails,
			// though it indicates a potential data integrity issue. Consider how critical this is.
			console.error(`Error resequencing items for section ${sectionId}:`, error);
			// Re-throwing might be appropriate depending on desired error handling strategy
			// throw new DatabaseError('Failed to resequence items', error);
		}
	}

	/**
	 * Delete a practice plan
	 * @param {number} id - Practice plan ID
	 * @param {number} userId - User ID requesting deletion
	 * @returns {Promise<void>} - Resolves if successful
	 * @throws {NotFoundError} If plan not found
	 * @throws {ForbiddenError} If user lacks permission to delete
	 * @throws {DatabaseError} On database error
	 */
	async deletePracticePlan(id, userId) {
		// Ensure user is authenticated for deletion, unless in dev mode where we might allow anonymous deletion for testing.
		if (!userId && !dev) {
			// Modified to allow no userId in dev
			throw new ForbiddenError('Authentication required to delete practice plans.');
		}

		// Use transaction helper for the entire deletion process
		try {
			return await this.withTransaction(async (client) => {
				// Fetch the plan's creator and visibility directly.
				// This serves as an existence check and gets necessary data for permission validation.
				const planDetailsQuery = `
          SELECT "${this.permissionConfig.userIdColumn}", "${this.permissionConfig.visibilityColumn}"
          FROM ${this.tableName}
          WHERE ${this.primaryKey} = $1
        `;
				const planDetailsResult = await client.query(planDetailsQuery, [id]);

				if (planDetailsResult.rows.length === 0) {
					throw new NotFoundError(`${this.tableName.slice(0, -1)} with ID ${id} not found.`);
				}
				const plan = planDetailsResult.rows[0];

				// Explicitly check if the current user is the creator.
				// is_editable_by_others does not grant delete permission.
				// Bypass this check in development mode.
				if (!dev) {
					// Check if NOT in dev mode for the following conditions
					if (!userId) {
						// If not in dev, userId is strictly required
						throw new ForbiddenError('Authentication required to delete this practice plan.');
					}
					if (plan[this.permissionConfig.userIdColumn] !== userId) {
						throw new ForbiddenError('Only the creator can delete this practice plan.');
					}
				} else {
					// In dev mode, log if bypassing creator check (optional)
					if (userId && plan[this.permissionConfig.userIdColumn] !== userId) {
						console.log(
							`[DEV MODE] Bypassing creator check for deleting plan ${id}. User ${userId} is not creator ${plan[this.permissionConfig.userIdColumn]}.`
						);
					} else if (!userId && plan[this.permissionConfig.userIdColumn] !== null) {
						console.log(
							`[DEV MODE] Bypassing creator check for deleting plan ${id}. No user, plan created by ${plan[this.permissionConfig.userIdColumn]}.`
						);
					}
				}

				// If all checks pass, proceed with deletion
				// Delete related records first (important for foreign key constraints)
				await client.query('DELETE FROM practice_plan_drills WHERE practice_plan_id = $1', [id]);

				await client.query('DELETE FROM practice_plan_sections WHERE practice_plan_id = $1', [id]);

				// Finally delete the practice plan using the base method, passing the client
				// The base delete method will also throw NotFoundError if the plan somehow disappeared.
				await this.delete(id, client);

				// Explicit success signal for callers/tests
				return true;
			});
		} catch (error) {
			// Re-throw known errors (NotFoundError, ForbiddenError from checks or base delete)
			if (error instanceof NotFoundError || error instanceof ForbiddenError) {
				throw error;
			}
			console.error(`Error deleting practice plan ${id}:`, error);
			// Wrap other errors (e.g., DB errors during deletion) as DatabaseError
			throw new DatabaseError('Failed to delete practice plan', error);
		}
	}

	/**
	 * Duplicate a practice plan
	 * @param {number} id - Practice plan ID to duplicate
	 * @param {number|null} userId - User ID creating the duplicate
	 * @returns {Promise<Object>} - New practice plan ID
	 * @throws {NotFoundError} If original plan not found
	 * @throws {ForbiddenError} If user cannot view original plan
	 * @throws {DatabaseError} On database error
	 */
	async duplicatePracticePlan(id, userId = null) {
		// First fetch the original practice plan details, including checking view permissions
		// getPracticePlanById handles NotFoundError and ForbiddenError.
		let originalPlanWithDetails;
		try {
			originalPlanWithDetails = await this.getPracticePlanById(id, userId);
		} catch (error) {
			// Re-throw known errors
			if (error instanceof NotFoundError || error instanceof ForbiddenError) {
				throw error;
			}
			console.error(`Error fetching original plan ${id} for duplication:`, error);
			throw new DatabaseError('Failed to fetch original plan for duplication', error);
		}

		// Use transaction helper for duplication process
		try {
			return await this.withTransaction(async (client) => {
				// Create data for new plan with timestamps
				const newPlanData = this.addTimestamps(
					{
						name: `${originalPlanWithDetails.name} (Copy)`,
						description: originalPlanWithDetails.description,
						practice_goals: originalPlanWithDetails.practice_goals,
						phase_of_season: originalPlanWithDetails.phase_of_season,
						estimated_number_of_participants:
							originalPlanWithDetails.estimated_number_of_participants,
						created_by: userId,
						// New plan visibility/editability depends on user creating it, or defaults?
						// Let's default to private for the user, or public if anonymous
						visibility: userId ? 'private' : 'public',
						is_editable_by_others: !userId, // Editable if anonymous, not otherwise by default
						start_time: originalPlanWithDetails.start_time
					},
					true
				);

				// Create new practice plan
				const newPlanResult = await client.query(
					`INSERT INTO practice_plans (
            name, description, practice_goals, phase_of_season,
            estimated_number_of_participants, created_by,
            visibility, is_editable_by_others, start_time, created_at, updated_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
          RETURNING *`,
					[
						newPlanData.name,
						newPlanData.description,
						newPlanData.practice_goals,
						newPlanData.phase_of_season,
						newPlanData.estimated_number_of_participants,
						newPlanData.created_by,
						newPlanData.visibility,
						newPlanData.is_editable_by_others,
						newPlanData.start_time,
						newPlanData.created_at,
						newPlanData.updated_at
					]
				);

				const newPlanId = newPlanResult.rows[0].id;

				// Copy sections
				const sectionsResult = await client.query(
					`SELECT * FROM practice_plan_sections 
           WHERE practice_plan_id = $1 
           ORDER BY "order"`,
					[id]
				);

				for (const section of sectionsResult.rows) {
					// Insert section
					const newSectionResult = await client.query(
						`INSERT INTO practice_plan_sections 
             (practice_plan_id, name, "order", goals, notes)
             VALUES ($1, $2, $3, $4, $5)
             RETURNING id`,
						[newPlanId, section.name, section.order, section.goals, section.notes]
					);

					const newSectionId = newSectionResult.rows[0].id;

					// Copy drills for this section
					const drillsResult = await client.query(
						`SELECT * FROM practice_plan_drills 
             WHERE practice_plan_id = $1 AND section_id = $2
             ORDER BY order_in_plan`,
						[id, section.id]
					);

					for (const drill of drillsResult.rows) {
						await client.query(
							`INSERT INTO practice_plan_drills 
	               (practice_plan_id, section_id, drill_id, formation_id, order_in_plan, 
	                duration, type, diagram_data, parallel_group_id, parallel_timeline,
	                group_timelines, name)
	               VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,
							[
								newPlanId,
								newSectionId,
								drill.drill_id,
								drill.formation_id,
								drill.order_in_plan,
								drill.duration,
								drill.type,
								drill.diagram_data,
								drill.parallel_group_id,
								drill.parallel_timeline,
								drill.group_timelines,
								drill.name
							]
						);
					}
				}

				return { id: newPlanId };
			}); // End transaction
		} catch (error) {
			console.error(`Error duplicating practice plan ${id}:`, error);
			// Wrap errors during the duplication transaction
			throw new DatabaseError('Failed to duplicate practice plan', error);
		}
	}

	/**
	 * Format a drill item from database row to client format
	 * @param {Object} item - Database row for drill item
	 * @returns {Object} - Formatted drill item
	 */
	formatDrillItem(item) {
		// Check if this is a one-off drill (when type is 'drill' but drill_id is null)
		const isOneOff = item.type === 'drill' && item.drill_id === null;

		if (item.type === 'formation') {
			return {
				id: item.id,
				practice_plan_id: item.practice_plan_id,
				type: 'formation',
				duration: item.item_duration,
				order_in_plan: item.order_in_plan,
				section_id: item.section_id,
				parallel_group_id: item.parallel_group_id,
				parallel_timeline: item.parallel_timeline,
				groupTimelines: item.groupTimelines,
				diagram_data: item.ppd_diagram_data,
				name: item.name || item.formation_name,
				formation_id: item.formation_id,
				formation: item.formation_id
					? {
							id: item.formation_id,
							name: item.formation_name,
							brief_description: item.formation_brief_description,
							detailed_description: item.formation_detailed_description,
							diagrams: item.formation_diagrams
						}
					: null
			};
		} else if (item.type === 'drill') {
			return {
				id: item.id,
				practice_plan_id: item.practice_plan_id,
				type: isOneOff ? 'one-off' : 'drill',
				duration: item.item_duration,
				order_in_plan: item.order_in_plan,
				section_id: item.section_id,
				parallel_group_id: item.parallel_group_id,
				parallel_timeline: item.parallel_timeline,
				groupTimelines: item.groupTimelines,
				diagram_data: item.ppd_diagram_data,
				name: item.name || (isOneOff ? 'Quick Activity' : item.drill_name),
				drill_id: item.drill_id,
				drill: isOneOff
					? null
					: {
							id: item.drill_id,
							name: item.drill_name,
							brief_description: item.brief_description,
							detailed_description: item.detailed_description,
							suggested_length: item.suggested_length_min,
							skill_level: item.skill_level,
							complexity: item.complexity,
							number_of_people_min: item.number_of_people_min,
							number_of_people_max: item.number_of_people_max,
							skills_focused_on: item.skills_focused_on,
							positions_focused_on: item.positions_focused_on,
							video_link: item.video_link,
							diagrams: item.diagrams
						}
			};
		} else {
			return {
				id: item.id,
				practice_plan_id: item.practice_plan_id,
				type: 'break',
				duration: item.item_duration,
				order_in_plan: item.order_in_plan,
				section_id: item.section_id,
				name: item.name || 'Break',
				parallel_group_id: item.parallel_group_id,
				parallel_timeline: item.parallel_timeline,
				groupTimelines: item.groupTimelines
			};
		}
	}

	/**
	 * Calculate section duration considering parallel drills
	 * @param {Array<Object>} items - Items in the section
	 * @returns {number} - Total section duration
	 */
	calculateSectionDuration(items) {
		const parallelGroups = new Map();
		let totalDuration = 0;

		items.forEach((item) => {
			// Skip formations - they don't contribute to duration
			if (item.type === 'formation') {
				return;
			}

			if (item.parallel_group_id) {
				const group = parallelGroups.get(item.parallel_group_id) || { duration: 0 };
				group.duration = Math.max(group.duration, item.duration || 0);
				parallelGroups.set(item.parallel_group_id, group);
			} else {
				totalDuration += item.duration || 0;
			}
		});

		// Add durations of parallel groups
		parallelGroups.forEach((group) => {
			totalDuration += group.duration;
		});

		return totalDuration;
	}

	/**
	 * Associate an anonymously created practice plan with a user
	 * @param {number} id - Practice Plan ID
	 * @param {number} userId - User ID to associate with
	 * @returns {Promise<Object>} - The updated practice plan
	 * @throws {NotFoundError} - If plan not found
	 * @throws {ConflictError} - If plan already owned by another user
	 * @throws {DatabaseError} - On database error
	 */
	async associatePracticePlan(id, userId) {
		// getById will throw NotFoundError if plan doesn't exist
		// Pass userId=null initially to fetch regardless of current owner, but check visibility
		const plan = await this.getById(id, [this.permissionConfig.userIdColumn], null);

		// Check if already owned by a *different* user
		if (
			plan[this.permissionConfig.userIdColumn] !== null &&
			plan[this.permissionConfig.userIdColumn] !== userId
		) {
			// Use ConflictError as the resource state prevents association
			throw new ConflictError('Practice plan is already associated with another user.');
		}

		// If already owned by the *same* user, return the plan (idempotent)
		if (plan[this.permissionConfig.userIdColumn] === userId) {
			return plan;
		}

		// Update the created_by field using base update method
		// This will also throw NotFoundError if the plan disappears mid-operation
		try {
			return await this.update(id, { [this.permissionConfig.userIdColumn]: userId });
		} catch (error) {
			// Re-throw known errors (like NotFoundError from update)
			if (error instanceof NotFoundError) {
				throw error;
			}
			// Wrap other errors as DatabaseError
			console.error(`Error associating plan ${id} with user ${userId}:`, error);
			throw new DatabaseError('Failed to associate practice plan', error);
		}
	}

	/**
	 * Links a practice plan item (activity) to a newly created drill.
	 * @param {number} practicePlanItemId - The ID of the item in practice_plan_drills.
	 * @param {number} newDrillId - The ID of the newly created drill to link to.
	 * @param {number} practicePlanId - The ID of the practice plan for permission checking.
	 * @param {number} userId - The ID of the user performing the action.
	 * @returns {Promise<Object>} - The updated practice plan item.
	 * @throws {NotFoundError} If practice plan or item not found.
	 * @throws {ForbiddenError} If user lacks permission to edit the practice plan.
	 * @throws {DatabaseError} On database error.
	 */
		async linkPracticePlanItemToDrill(practicePlanItemId, newDrillId, practicePlanId, userId) {
			return this.withTransaction(async (client) => {
			// 1. Check if user can edit the practice plan
			await this.canUserEdit(practicePlanId, userId, client); // Throws ForbiddenError if not allowed

			// 2. Update the practice plan item
			const updateQuery = `
        UPDATE practice_plan_drills
        SET drill_id = $1, type = 'drill' 
        WHERE id = $2 AND practice_plan_id = $3
        RETURNING *;
      `;
			// Ensure practice_plan_id condition is also met for safety, though item ID should be unique.
			const result = await client.query(updateQuery, [
				newDrillId,
				practicePlanItemId,
				practicePlanId
			]);

			if (result.rows.length === 0) {
				throw new NotFoundError(
					`Practice plan item with ID ${practicePlanItemId} in plan ${practicePlanId} not found or update failed.`
				);
			}

			// 3. Format and return the updated item (optional, could also return success status)
			// The formatDrillItem expects a row that might have joined drill data.
			// For simplicity here, we return the raw updated row from practice_plan_drills.
			// If full formatting is needed, a subsequent fetch/join might be required.
				return result.rows[0];
			});
		}

		// --- Season planning helpers (moved from prototype patching) ---

		async getByTeamAndDate(teamId, scheduledDate) {
			const result = await this.getAll({
				filters: {
					team_id: teamId,
					scheduled_date: scheduledDate
				},
				limit: 1
			});
			return result.items[0] || null;
		}

		async getByIdWithContent(planId, existingClient = null) {
			console.log('getByIdWithContent called with planId:', planId);

			const runWithClient = async (client) => {
				const planQuery = 'SELECT * FROM practice_plans WHERE id = $1';
				const planResult = await client.query(planQuery, [planId]);
				console.log('getByIdWithContent query result rows:', planResult.rows.length);
				if (planResult.rows.length === 0) return null;

				const plan = planResult.rows[0];

				const sectionsQuery = `
      SELECT * FROM practice_plan_sections 
      WHERE practice_plan_id = $1 
      ORDER BY "order"
    `;
				const sectionsResult = await client.query(sectionsQuery, [planId]);
				plan.sections = sectionsResult.rows;

				const drillsQuery = `
      SELECT 
        ppd.*,
        d.name as drill_name,
        d.brief_description as drill_description,
        f.name as formation_name,
        f.brief_description as formation_description,
        pps.name as section_name
      FROM practice_plan_drills ppd
      LEFT JOIN drills d ON ppd.drill_id = d.id
      LEFT JOIN formations f ON ppd.formation_id = f.id
      LEFT JOIN practice_plan_sections pps ON ppd.section_id = pps.id
      WHERE ppd.practice_plan_id = $1
      ORDER BY ppd.order_in_plan
    `;
				const drillsResult = await client.query(drillsQuery, [planId]);
				plan.drills = drillsResult.rows;

				return plan;
			};

			if (existingClient) {
				return await runWithClient(existingClient);
			}

			return await this.withTransaction(async (client) => runWithClient(client));
		}

		async createWithContent(data, userId) {
			try {
				return await this.withTransaction(async (client) => {
					console.log(
						'createWithContent starting with data:',
						JSON.stringify(data).substring(0, 300)
					);

					const planData = {
						name: data.name,
						description: data.description,
						practice_goals: data.practice_goals || [],
						phase_of_season: data.phase_of_season,
						estimated_number_of_participants: data.estimated_number_of_participants,
						created_by: userId,
						visibility: data.visibility || 'private',
						is_editable_by_others: false,
						start_time: data.start_time,
						team_id: data.team_id,
						season_id: data.season_id,
						scheduled_date: data.scheduled_date,
						is_template: data.is_template || false,
						template_plan_id: data.template_plan_id,
						is_edited: data.is_edited || false
					};

					const planQuery = `
      INSERT INTO practice_plans (
        name, description, practice_goals, phase_of_season,
        estimated_number_of_participants, created_by, visibility,
        is_editable_by_others, start_time, team_id, season_id,
        scheduled_date, is_template, template_plan_id, is_edited
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
      ) RETURNING *
    `;

					const planResult = await client.query(planQuery, [
						planData.name,
						planData.description,
						planData.practice_goals || [],
						planData.phase_of_season,
						planData.estimated_number_of_participants,
						planData.created_by,
						planData.visibility,
						planData.is_editable_by_others,
						planData.start_time,
						planData.team_id,
						planData.season_id,
						planData.scheduled_date,
						planData.is_template,
						planData.template_plan_id,
						planData.is_edited
					]);

					const plan = planResult.rows[0];

					console.log(
						'Created practice plan in DB with ID:',
						plan?.id,
						'Full plan:',
						JSON.stringify(plan).substring(0, 200)
					);

					const sectionMap = {};
					for (const section of data.sections || []) {
						const sectionQuery = `
        INSERT INTO practice_plan_sections (
          practice_plan_id, name, "order", goals, notes
        ) VALUES ($1, $2, $3, $4, $5)
        RETURNING *
      `;

						const sectionResult = await client.query(sectionQuery, [
							plan.id,
							section.name,
							section.order || 0,
							JSON.stringify(section.goals || []),
							section.notes
						]);

						sectionMap[section.name] = sectionResult.rows[0].id;
					}

					for (const drill of data.drills || []) {
						const sectionId = drill.section_name ? sectionMap[drill.section_name] : drill.section_id;

						const drillQuery = `
        INSERT INTO practice_plan_drills (
          practice_plan_id, drill_id, formation_id, type, name,
          selected_duration, order_in_plan, section_id, parallel_group_id,
          parallel_timeline, group_timelines
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      `;

						await client.query(drillQuery, [
							plan.id,
							drill.drill_id,
							drill.formation_id,
							drill.type || 'drill',
							drill.name,
							drill.duration || 30,
							drill.order_in_plan || 0,
							sectionId,
							drill.parallel_group_id,
							drill.parallel_timeline,
							JSON.stringify(drill.group_timelines || [])
						]);
					}

					const result = await this.getByIdWithContent(plan.id, client);

					if (!result) {
						console.log('getByIdWithContent returned null, returning basic plan');
						return {
							...plan,
							sections: data.sections || [],
							drills: data.drills || []
						};
					}

					return result;
				});
			} catch (error) {
				console.error('Error in createWithContent:', error);
				console.error('Error stack:', error.stack);
				throw error;
			}
		}

		async publishPracticePlan(planId, userId) {
			const plan = await this.getById(planId);

			const { teamMemberService } = await import('./teamMemberService.js');
			if (plan.team_id) {
				const member = await teamMemberService.getMember(plan.team_id, userId);
				if (!member || (member.role !== 'admin' && plan.created_by !== userId)) {
					throw new ForbiddenError('Only team admins or the creator can publish plans');
				}
			} else if (plan.created_by !== userId) {
				throw new ForbiddenError('Only the creator can publish this plan');
			}

			return await this.withTransaction(async (client) => {
				const query = `
      UPDATE practice_plans 
      SET is_published = true,
          published_at = NOW(),
          updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `;

				const result = await client.query(query, [planId]);
				return result.rows[0];
			});
		}

		async unpublishPracticePlan(planId, userId) {
			const plan = await this.getById(planId);

			const { teamMemberService } = await import('./teamMemberService.js');
			if (plan.team_id) {
				const member = await teamMemberService.getMember(plan.team_id, userId);
				if (!member || (member.role !== 'admin' && plan.created_by !== userId)) {
					throw new ForbiddenError('Only team admins or the creator can unpublish plans');
				}
			} else if (plan.created_by !== userId) {
				throw new ForbiddenError('Only the creator can unpublish this plan');
			}

			return await this.withTransaction(async (client) => {
				const query = `
      UPDATE practice_plans 
      SET is_published = false,
          published_at = NULL,
          updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `;

				const result = await client.query(query, [planId]);
				return result.rows[0];
			});
		}
	}

// Create and export an instance of the service
export const practicePlanService = new PracticePlanService();
</file>

</files>
