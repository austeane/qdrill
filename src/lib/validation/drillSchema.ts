import { z } from 'zod';

// Constants reused from frontend/backend
const skillLevelOptions = [
	'New to Sport',
	'Beginner',
	'Intermediate',
	'Advanced',
	'Expert'
] as const;

const complexityOptions = ['Low', 'Medium', 'High'] as const;

const positionOptions = ['Chaser', 'Beater', 'Keeper', 'Seeker'] as const;

const drillTypeOptions = [
	'Competitive',
	'Skill-focus',
	'Tactic-focus',
	'Warmup',
	'Conditioning',
	'Cooldown',
	'Contact',
	'Match-like situation'
] as const;

const visibilityOptions = ['public', 'unlisted', 'private'] as const;

// Base schema for a drill
export const drillSchema = z.object({
	id: z.number().int().positive().optional(), // Optional for creation
	name: z.string().trim().min(1, 'Name is required'),
	brief_description: z.string().trim().min(1, 'Brief description is required'),
	detailed_description: z.string().trim().optional(), // Made optional based on Yup schema, tighten if needed
	skill_level: z.array(z.enum(skillLevelOptions)).min(1, 'At least one skill level is required'),
	complexity: z.enum(complexityOptions).nullable().optional(), // Optional field
	suggested_length: z
		.object({
			min: z.number().int().min(0, 'Suggested length min must be a non-negative integer'),
			max: z.number().int().min(0, 'Suggested length max must be a non-negative integer')
		})
		.refine((data) => data.max >= data.min, {
			message: 'Suggested length max must be greater than or equal to min',
			path: ['max'] // Attach error to the 'max' field
		}),
	number_of_people: z
		.object({
			min: z
				.number()
				.int()
				.positive('Number of people min must be a positive integer')
				.nullable()
				.optional(),
			max: z
				.number()
				.int()
				.positive('Number of people max must be a positive integer')
				.nullable()
				.optional()
		})
		.refine((data) => data.max == null || data.min == null || data.max >= data.min, {
			message: 'Number of people max must be greater than or equal to min',
			path: ['max'] // Attach error to the 'max' field
		})
		.nullable()
		.optional(), // The whole object is optional
	skills_focused_on: z
		.array(z.string().trim().min(1)) // Allow any non-empty string for now
		.min(1, 'At least one skill is required'),
	positions_focused_on: z
		.array(z.enum(positionOptions))
		.min(1, 'At least one position is required'),
	video_link: z.string().url('Video link must be a valid URL').nullable().optional(),
	diagrams: z.array(z.any()).optional(), // Representing Excalidraw data; could be stricter later
	drill_type: z.array(z.enum(drillTypeOptions)).min(1, 'At least one drill type is required'),

	// Metadata fields (useful for creation/update)
	// Better Auth user IDs are strings; accept legacy numeric IDs too.
	created_by: z.union([z.string().min(1), z.number().int().positive()]).nullable().optional(), // Nullable for anonymous uploads/creations initially
	visibility: z.enum(visibilityOptions).default('public').optional(),
	is_editable_by_others: z.boolean().default(false).optional(),

	// Timestamps (generally handled by service, but useful for validation context)
	created_at: z.string().datetime().optional(),
	updated_at: z.string().datetime().optional(),

	// Added for bulk upload context if needed, not part of core drill data
	errors: z.array(z.string()).optional(),
	row: z.number().int().optional(),
	isEditing: z.boolean().optional(),
	editableDiagramIndex: z.number().int().nullable().optional()
});

// Schema specifically for creating a new drill (e.g., POST request)
// Omits fields generated by the server (id, timestamps, etc.)
export const createDrillSchema = drillSchema.omit({
	id: true,
	created_at: true,
	errors: true, // Not relevant for creation payload
	row: true,
	isEditing: true,
	editableDiagramIndex: true
});

// Schema for updating an existing drill (e.g., PUT request)
// Requires 'id' and makes other fields potentially optional if using PATCH semantics,
// but for PUT, usually, all relevant fields are expected.
// Let's assume PUT requires most fields but makes server-managed ones optional.
export const updateDrillSchema = drillSchema
	.extend({
		id: z.number().int().positive('Valid Drill ID is required for update')
	})
	.omit({
		created_at: true,
		errors: true, // Not relevant for update payload
		row: true,
		isEditing: true,
		editableDiagramIndex: true
	});

// Schema for the bulk upload *input* from the CSV parsing stage
// This needs to match the structure created by `parseDrill` before Yup validation was run
// Mapping the numeric codes back for skill/complexity
export const bulkUploadDrillInputSchema = z.object({
	name: z.string().trim().min(1, 'Name is required'),
	brief_description: z.string().trim().min(1, 'Brief description is required'),
	detailed_description: z.string().trim().optional(),
	skill_level: z.array(z.enum(skillLevelOptions)).min(1, 'At least one skill level is required'), // Already mapped in parseDrill
	complexity: z.enum(complexityOptions).nullable().optional(), // Already mapped in parseDrill
	suggested_length: z
		.object({
			min: z
				.number()
				.int()
				.min(0, 'Suggested length min must be a non-negative integer')
				.nullable(), // Allow null from parseInteger
			max: z.number().int().min(0, 'Suggested length max must be a non-negative integer').nullable() // Allow null from parseInteger
		})
		.refine((data) => data.min !== null, {
			message: 'Suggested length min is required',
			path: ['min']
		})
		.refine((data) => data.max !== null, {
			message: 'Suggested length max is required',
			path: ['max']
		})
		.refine((data) => data.min === null || data.max === null || data.max >= data.min, {
			message: 'Suggested length max must be greater than or equal to min',
			path: ['max']
		}),
	number_of_people: z
		.object({
			min: z
				.number()
				.int()
				.positive('Number of people min must be a positive integer')
				.nullable()
				.optional(), // Allow null from parseInteger
			max: z
				.number()
				.int()
				.positive('Number of people max must be a positive integer')
				.nullable()
				.optional() // Allow null from parseInteger
		})
		.refine((data) => data.max == null || data.min == null || data.max >= data.min, {
			message: 'Number of people max must be greater than or equal to min',
			path: ['max']
		})
		.nullable()
		.optional(),
	skills_focused_on: z.array(z.string().trim().min(1)).min(1, 'At least one skill is required'),
	positions_focused_on: z
		.array(z.enum(positionOptions))
		.min(1, 'At least one position is required'),
	video_link: z
		.string()
		.url('Video link must be a valid URL')
		.or(z.literal(''))
		.nullable()
		.optional(), // Allow empty string from CSV
	drill_type: z.array(z.enum(drillTypeOptions)).min(1, 'At least one drill type is required'),

	// Metadata added during parsing
	created_by: z.number().int().positive().nullable(), // Will be set from locals
	visibility: z.enum(visibilityOptions), // Will be set from form data
	is_editable_by_others: z.boolean(), // Will be set
	diagrams: z.array(z.any()).optional(), // Defaulted to []
	errors: z.array(z.string()).optional() // Defaulted to []
});

// Type helper
export type Drill = z.infer<typeof drillSchema>;
export type CreateDrillInput = z.infer<typeof createDrillSchema>;
export type UpdateDrillInput = z.infer<typeof updateDrillSchema>;
export type BulkUploadDrillInput = z.infer<typeof bulkUploadDrillInputSchema>;
