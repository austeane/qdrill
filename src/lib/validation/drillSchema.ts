import { z } from 'zod';

// Constants reused from frontend/backend
const skillLevelOptions = [
  'New to Sport',
  'Beginner',
  'Intermediate',
  'Advanced',
  'Expert'
] as const;

const complexityOptions = [
  'Low',
  'Medium',
  'High'
] as const;

const positionOptions = ['Chaser', 'Beater', 'Keeper', 'Seeker'] as const;

const drillTypeOptions = [
  'Competitive', 
  'Skill-focus', 
  'Tactic-focus', 
  'Warmup', 
  'Conditioning', 
  'Cooldown', 
  'Contact', 
  'Match-like situation'
] as const;

const visibilityOptions = ['public', 'unlisted', 'private'] as const;

// Base schema for a drill
export const drillSchema = z.object({
  id: z.number().int().positive().optional(), // Optional for creation
  name: z.string().trim().min(1, 'Name is required'),
  brief_description: z.string().trim().min(1, 'Brief description is required'),
  detailed_description: z.string().trim().optional(), // Made optional based on Yup schema, tighten if needed
  skill_level: z.array(z.enum(skillLevelOptions))
    .min(1, 'At least one skill level is required'),
  complexity: z.enum(complexityOptions).nullable().optional(), // Optional field
  suggested_length: z.object({
    min: z.number().int().positive('Suggested length min must be a positive integer'),
    max: z.number().int().positive('Suggested length max must be a positive integer'),
  }).refine(data => data.max >= data.min, {
    message: 'Suggested length max must be greater than or equal to min',
    path: ['max'], // Attach error to the 'max' field
  }),
  number_of_people: z.object({
    min: z.number().int().positive('Number of people min must be a positive integer').nullable().optional(),
    max: z.number().int().positive('Number of people max must be a positive integer').nullable().optional(),
  }).refine(data => data.max == null || data.min == null || data.max >= data.min, {
    message: 'Number of people max must be greater than or equal to min',
    path: ['max'], // Attach error to the 'max' field
  }).nullable().optional(), // The whole object is optional
  skills_focused_on: z.array(z.string().trim().min(1)) // Allow any non-empty string for now
    .min(1, 'At least one skill is required'),
  positions_focused_on: z.array(z.enum(positionOptions))
    .min(1, 'At least one position is required'),
  video_link: z.string().url('Video link must be a valid URL').nullable().optional(),
  diagrams: z.array(z.any()).optional(), // Representing Excalidraw data; could be stricter later
  drill_type: z.array(z.enum(drillTypeOptions))
    .min(1, 'At least one drill type is required'),
    
  // Metadata fields (useful for creation/update)
  created_by: z.number().int().positive().nullable().optional(), // Nullable for anonymous uploads/creations initially
  visibility: z.enum(visibilityOptions).default('public').optional(),
  is_editable_by_others: z.boolean().default(false).optional(),
  
  // Timestamps (generally handled by service, but useful for validation context)
  created_at: z.string().datetime().optional(),
  updated_at: z.string().datetime().optional(),

  // Added for bulk upload context if needed, not part of core drill data
  errors: z.array(z.string()).optional(), 
  row: z.number().int().optional(),
  isEditing: z.boolean().optional(),
  editableDiagramIndex: z.number().int().nullable().optional(),
});

// Schema specifically for creating a new drill (e.g., POST request)
// Omits fields generated by the server (id, timestamps, etc.)
export const createDrillSchema = drillSchema.omit({ 
  id: true, 
  created_at: true, 
  updated_at: true,
  errors: true, // Not relevant for creation payload
  row: true,
  isEditing: true,
  editableDiagramIndex: true,
});

// Schema for updating an existing drill (e.g., PUT request)
// Requires 'id' and makes other fields potentially optional if using PATCH semantics,
// but for PUT, usually, all relevant fields are expected.
// Let's assume PUT requires most fields but makes server-managed ones optional.
export const updateDrillSchema = drillSchema.extend({
  id: z.number().int().positive('Valid Drill ID is required for update'),
}).omit({
  created_at: true, 
  updated_at: true,
  errors: true, // Not relevant for update payload
  row: true,
  isEditing: true,
  editableDiagramIndex: true,
});

// Schema for the bulk upload *input* from the CSV parsing stage
// This needs to match the structure created by `parseDrill` before Yup validation was run
// Mapping the numeric codes back for skill/complexity
export const bulkUploadDrillInputSchema = z.object({
  name: z.string().trim().min(1, 'Name is required'),
  brief_description: z.string().trim().min(1, 'Brief description is required'),
  detailed_description: z.string().trim().optional(),
  skill_level: z.array(z.enum(skillLevelOptions)).min(1, 'At least one skill level is required'), // Already mapped in parseDrill
  complexity: z.enum(complexityOptions).nullable().optional(), // Already mapped in parseDrill
  suggested_length: z.object({
    min: z.number().int().positive('Suggested length min must be a positive integer').nullable(), // Allow null from parseInteger
    max: z.number().int().positive('Suggested length max must be a positive integer').nullable(), // Allow null from parseInteger
  }).refine(data => data.min !== null, { 
      message: 'Suggested length min is required', 
      path: ['min'] 
  }).refine(data => data.max !== null, { 
      message: 'Suggested length max is required', 
      path: ['max'] 
  }).refine(data => data.min === null || data.max === null || data.max >= data.min, {
    message: 'Suggested length max must be greater than or equal to min',
    path: ['max'],
  }),
  number_of_people: z.object({
    min: z.number().int().positive('Number of people min must be a positive integer').nullable().optional(), // Allow null from parseInteger
    max: z.number().int().positive('Number of people max must be a positive integer').nullable().optional(), // Allow null from parseInteger
  }).refine(data => data.max == null || data.min == null || data.max >= data.min, {
    message: 'Number of people max must be greater than or equal to min',
    path: ['max'],
  }).nullable().optional(),
  skills_focused_on: z.array(z.string().trim().min(1)).min(1, 'At least one skill is required'),
  positions_focused_on: z.array(z.enum(positionOptions)).min(1, 'At least one position is required'),
  video_link: z.string().url('Video link must be a valid URL').or(z.literal('')).nullable().optional(), // Allow empty string from CSV
  drill_type: z.array(z.enum(drillTypeOptions)).min(1, 'At least one drill type is required'),
  
  // Metadata added during parsing
  created_by: z.number().int().positive().nullable(), // Will be set from locals
  visibility: z.enum(visibilityOptions), // Will be set from form data
  is_editable_by_others: z.boolean(), // Will be set
  diagrams: z.array(z.any()).optional(), // Defaulted to []
  errors: z.array(z.string()).optional(), // Defaulted to []
});

// Type helper
export type Drill = z.infer<typeof drillSchema>;
export type CreateDrillInput = z.infer<typeof createDrillSchema>;
export type UpdateDrillInput = z.infer<typeof updateDrillSchema>;
export type BulkUploadDrillInput = z.infer<typeof bulkUploadDrillInputSchema>; 