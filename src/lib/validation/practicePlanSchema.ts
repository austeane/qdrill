import { z } from 'zod';

// Base schema for Practice Plan Item (shape only)
const practicePlanItemBaseSchema = z.object({
	id: z.number().optional(), // Optional for creation, required for update/association
	type: z.enum(['drill', 'break', 'activity', 'formation']), // Added 'activity' and 'formation'
	name: z.string().min(1, 'Item name is required'),
	// Formation placeholders intentionally use duration 0
	duration: z.number().int().min(0, 'Duration must be a non-negative integer'),
	drill_id: z.number().int().nullable().optional(), // Null for breaks or one-offs/activities
	formation_id: z.number().int().nullable().optional(), // For formation items
	diagram_data: z.string().nullable().optional(),
	parallel_group_id: z.string().nullable().optional(), // This identifies the item's role/timeline name
	parallel_timeline: z.string().nullable().optional(), // Will be hydrated to be same as parallel_group_id
	// Canonical wire shape is camelCase; accept snake_case for backward compatibility
	groupTimelines: z.array(z.string()).nullable().optional(),
	group_timelines: z.array(z.string()).nullable().optional(),
	order: z.number().int().optional() // Handled server-side during creation/update usually
});

// Reused refined schema for reads/updates
const practicePlanItemSchema = practicePlanItemBaseSchema.superRefine((item, ctx) => {
	if (item.type !== 'formation' && item.duration < 1) {
		ctx.addIssue({
			code: z.ZodIssueCode.custom,
			path: ['duration'],
			message: 'Duration must be at least 1 minute'
		});
	}
});

// Schema for creation (no id)
const practicePlanItemCreateSchema = practicePlanItemBaseSchema
	.omit({ id: true })
	.superRefine((item, ctx) => {
		if (item.type !== 'formation' && item.duration < 1) {
			ctx.addIssue({
				code: z.ZodIssueCode.custom,
				path: ['duration'],
				message: 'Duration must be at least 1 minute'
			});
		}
	});

// Base schema for Practice Plan Section (reused in Create/Update)
const practicePlanSectionSchema = z.object({
	id: z.number().optional(),
	name: z.string().min(1, 'Section name is required'),
	order: z.number().int().optional(), // Handled server-side
	goals: z.array(z.string()).optional(), // Assuming goals are strings
	notes: z.string().optional(),
	items: z
		.array(practicePlanItemSchema)
		.min(1, 'Each section must have at least one item')
		.refine(
			(items) => {
				// Ensure parallel items have group_id and timeline
				const parallelItems = items.filter((item) => item.parallel_group_id);
				return parallelItems.every((item) => item.parallel_group_id && item.parallel_timeline);
			},
			{ message: 'Parallel items must have both a group ID and a timeline.' }
		)
});

// Full Practice Plan schema (potentially for retrieval or updates including everything)
export const practicePlanSchema = z.object({
	id: z.number().optional(),
	name: z
		.string()
		.min(1, 'Plan name is required')
		.max(255, 'Plan name cannot exceed 255 characters'),
	description: z.string().optional(),
	phase_of_season: z.string().nullable().optional(), // Could add enum if phases are fixed
	estimated_number_of_participants: z
		.number()
		.int()
		.positive('Number of participants must be positive')
		.nullable()
		.optional(),
	practice_goals: z.array(z.string().min(1, 'Goal cannot be empty')).optional(),
	visibility: z.enum(['public', 'private', 'unlisted']).default('public'),
	is_editable_by_others: z.boolean().default(false),
	start_time: z
		.string()
		.regex(/^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/, 'Invalid start time format (HH:MM:SS)')
		.nullable()
		.optional(), // HH:MM:SS format
	sections: z
		.array(practicePlanSectionSchema)
		.min(1, 'A practice plan must have at least one section'),
	// Include other fields like user_id, created_at, updated_at if needed for validation context,
	// but they are usually handled server-side.
	total_duration: z.number().int().positive().optional(), // Often calculated, might not be directly validated
	user_id: z.string().optional(),
	created_at: z.string().datetime().optional(),
	updated_at: z.string().datetime().optional()
});

// Schema specifically for CREATING a new practice plan via API
export const createPracticePlanSchema = practicePlanSchema
	.omit({
		id: true, // ID is generated by DB
		user_id: true, // Should be set based on authenticated user server-side
		created_at: true,
		updated_at: true,
		total_duration: true // Calculated server-side
	})
	.extend({
		// Make sections/items require necessary fields for creation
		sections: z
			.array(
				practicePlanSectionSchema.omit({ id: true }).extend({
					// Omit section ID for creation
					items: z
						.array(
							practicePlanItemCreateSchema // Omit item ID for creation
						)
						.min(1, 'Each section must have at least one item')
				})
			)
			.min(1, 'A practice plan must have at least one section')
	});

// Schema specifically for UPDATING an existing practice plan via API
// Might need refinement based on how updates work (e.g., partial updates)
export const updatePracticePlanSchema = practicePlanSchema.partial().required({
	id: true // Require ID for updating
});

// Schema for validating just the metadata (e.g., in the form before sections/items are added)
export const practicePlanMetadataSchema = practicePlanSchema
	.pick({
		name: true,
		description: true,
		phase_of_season: true,
		estimated_number_of_participants: true,
		practice_goals: true,
		visibility: true,
		is_editable_by_others: true,
		start_time: true
	})
	.extend({
		// Adjust types/validation if the form input differs slightly from the final DB model
		estimated_number_of_participants: z.preprocess(
			(val) => (val === '' || val === null || val === undefined ? null : Number(val)),
			z.number().int().positive('Number of participants must be positive').nullable().optional()
		),
		practice_goals: z
			.array(z.string().min(1, 'Goal cannot be empty'))
			.refine((goals) => goals.length > 0, { message: 'At least one practice goal is required' })
			.optional()
	});

// Schema specifically for the Wizard's Basic Info step
export const practicePlanBasicInfoSchema = z.object({
	name: z
		.string()
		.min(1, 'Plan name is required')
		.max(255, 'Plan name cannot exceed 255 characters'),
	description: z.string().optional(),
	phaseOfSeason: z.string().nullable().optional(), // Renamed from phase_of_season to match form state
	participants: z.preprocess(
		// Renamed from estimated_number_of_participants
		(val) => (val === '' || val === null || val === undefined ? null : Number(val)),
		z.number().int().positive('Number of participants must be positive').nullable().optional()
	),
	practiceGoals: z
		.array(z.string().min(1, 'Goal cannot be empty')) // Renamed from practice_goals
		.refine((goals) => goals.length > 0, { message: 'At least one practice goal is required' })
		.optional(),
	visibility: z.enum(['public', 'private', 'unlisted']).default('public'),
	isEditableByOthers: z.boolean().default(false) // Renamed from is_editable_by_others
	// Omitting start_time as it's not currently in the basic-info form
	// Omitting skillLevel, totalTime as they aren't in the final plan metadata schema
});

// Schema for Associating Drills/Breaks (e.g., adding items to a section)
export const associateItemSchema = z.object({
	sectionId: z.number().int(),
	item: practicePlanItemSchema // Validate the item being added
});

// Schema for associating existing drills/formations to a practice plan item
export const associateExistingSchema = z.object({
	practicePlanId: z.number().int(),
	sectionId: z.number().int(),
	itemId: z.number().int(), // The practice plan item ID (break/placeholder)
	resourceId: z.number().int(), // The ID of the drill or formation
	resourceType: z.enum(['drill', 'formation'])
});

// Type helpers
export type PracticePlan = z.infer<typeof practicePlanSchema>;
export type PracticePlanSection = z.infer<typeof practicePlanSectionSchema>;
export type PracticePlanItem = z.infer<typeof practicePlanItemSchema>;
export type CreatePracticePlanInput = z.infer<typeof createPracticePlanSchema>;
export type UpdatePracticePlanInput = z.infer<typeof updatePracticePlanSchema>;
export type PracticePlanMetadata = z.infer<typeof practicePlanMetadataSchema>;
